namespace;

// TO-DO add mutex
class ref_counter
{
    var shared_ref int;
    var weak_ref int;
    var object pointer;

    function retain_shared()
    {
        this.strong_ref++;

                VERIFY( m_ObjectState == ObjectState::Alive, "Attempting to increment strong reference counter for a destroyed or not itialized object!" );
        VERIFY( m_ObjectWrapperBuffer[0] != 0 && m_ObjectWrapperBuffer[1] != 0, "Object wrapper is not initialized")
        return Atomics::AtomicIncrement(m_lNumStrongReferences);
    }

    function release_shared()
    {
VERIFY( m_ObjectState == ObjectState::Alive, "Attempting to decrement strong reference counter for an object that is not alive" )
        VERIFY( m_ObjectWrapperBuffer[0] != 0 && m_ObjectWrapperBuffer[1] != 0, "Object wrapper is not initialized")

        // Decrement strong reference counter without acquiring the lock. 
        auto RefCount = Atomics::AtomicDecrement(m_lNumStrongReferences);
        VERIFY( RefCount >= 0, "Inconsistent call to ReleaseStrongRef()" );
        if( RefCount == 0 )
        {
            // Since RefCount==0, there are no more strong references and the only place 
            // where strong ref counter can be incremented is from GetObject().

            // If several threads were allowed to get to this point, there would 
            // be serious risk that <this> had already been destroyed and m_LockFlag expired. 
            // Consider the following scenario:
            //                                      |
            //             This thread              |             Another thread
            //                                      |
            //                      m_lNumStrongReferences == 1
            //                      m_lNumWeakReferences == 1
            //                                      |  
            // 1. Decrement m_lNumStrongReferences  |   
            //    Read RefCount==0, no lock acquired|      
            //                                      |   1. Run GetObject()
            //                                      |      - acquire the lock
            //                                      |      - increment m_lNumStrongReferences
            //                                      |      - release the lock
            //                                      |   
            //                                      |   2. Run ReleaseWeakRef()
            //                                      |      - decrement m_lNumWeakReferences
            //                                      |  
            //                                      |   3. Run ReleaseStrongRef()
            //                                      |      - decrement m_lNumStrongReferences
            //                                      |      - read RefCount==0
            //
            //         Both threads will get to this point. The first one will destroy <this>
            //         The second one will read expired m_LockFlag

            //  IT IS CRUCIALLY IMPORTANT TO ASSURE THAT ONLY ONE THREAD WILL EVER
            //  EXECUTE THIS CODE

            // The sloution is to atomically increment strong ref counter in GetObject().
            // There are two possible scenarios depending on who first increments the counter:


            //                                                     Scenario I
            //
            //             This thread              |      Another thread - GetObject()         |   One more thread - GetObject()
            //                                      |                                           |
            //                       m_lNumStrongReferences == 1                                |
            //                                      |                                           |
            //                                      |   1. Acquire the lock                     |
            // 1. Decrement m_lNumStrongReferences  |                                           |   1. Wait for the lock
            // 2. Read RefCount==0                  |   2. Increment m_lNumStrongReferences     |
            // 3. Start destroying the object       |   3. Read StrongRefCnt == 1               |
            // 4. Wait for the lock                 |   4. DO NOT return the reference          |
            //                                      |      to the object                        |
            //                                      |   5. Decrement m_lNumStrongReferences     |
            // _  _  _  _  _  _  _  _  _  _  _  _  _|   6. Release the lock _  _  _  _  _  _  _ |_  _  _  _  _  _  _  _  _  _  _  _  _  _
            //                                      |                                           |   2. Acquire the lock  
            //                                      |                                           |   3. Increment m_lNumStrongReferences
            //                                      |                                           |   4. Read StrongRefCnt == 1
            //                                      |                                           |   5. DO NOT return the reference 
            //                                      |                                           |      to the object
            //                                      |                                           |   6. Decrement m_lNumStrongReferences         
            //  _  _  _  _  _  _  _  _  _  _  _  _  | _  _  _  _  _  _  _  _  _  _  _  _  _  _  | _ 7. Release the lock _  _  _  _  _  _
            // 5. Acquire the lock                  |                                           |
            //   - m_lNumStrongReferences==0        |                                           |
            // 6. DESTROY the object                |                                           |
            //                                      |                                           |

            //  GetObject() MUST BE SERIALIZED for this to work properly!


            //                                   Scenario II
            //
            //             This thread              |      Another thread - GetObject()
            //                                      |
            //                       m_lNumStrongReferences == 1
            //                                      |
            //                                      |   1. Acquire the lock  
            //                                      |   2. Increment m_lNumStrongReferences
            // 1. Decrement m_lNumStrongReferences  |
            // 2. Read RefCount>0                   |   
            // 3. DO NOT destroy the object         |   3. Read StrongRefCnt > 1 (while m_lNumStrongReferences == 1)
            //                                      |   4. Return the reference to the object
            //                                      |       - Increment m_lNumStrongReferences
            //                                      |   5. Decrement m_lNumStrongReferences

#ifdef _DEBUG
            Atomics::Long NumStrongRefs = m_lNumStrongReferences;
            VERIFY( NumStrongRefs == 0 || NumStrongRefs == 1, "Num strong references (", NumStrongRefs, ") is expected to be 0 or 1" );
#endif

            // Acquire the lock.
            ThreadingTools::LockHelper Lock(m_LockFlag);

            // GetObject() first acquires the lock, and only then increments and 
            // decrements the ref counter. If it reads 1 after incremeting the counter,
            // it does not return the reference to the object and decrements the counter.
            // If we acquired the lock, GetObject() will not start until we are done
            VERIFY_EXPR( m_lNumStrongReferences == 0 && m_ObjectState == ObjectState::Alive )
                
            // Extra caution
            if(m_lNumStrongReferences == 0 && m_ObjectState == ObjectState::Alive)
            {
                VERIFY(m_ObjectWrapperBuffer[0] != 0 && m_ObjectWrapperBuffer[1] != 0, "Object wrapper is not initialized")
                // We cannot destroy the object while reference counters are locked as this will  
                // cause a deadlock in cases like this:
                //
                //    A ==sp==> B ---wp---> A
                //    
                //    RefCounters_A.Lock();
                //    delete A{
                //      A.~dtor(){
                //          B.~dtor(){
                //              wpA.ReleaseWeakRef(){
                //                  RefCounters_A.Lock(); // Deadlock
                //

                // So we copy the object wrapper and destroy the object after unlocking the
                // reference counters
                size_t ObjectWrapperBufferCopy[ObjectWrapperBufferSize];
                for(size_t i=0; i < ObjectWrapperBufferSize; ++i)
                    ObjectWrapperBufferCopy[i] = m_ObjectWrapperBuffer[i];
#ifdef _DEBUG
                memset(m_ObjectWrapperBuffer, 0, sizeof(m_ObjectWrapperBuffer));
#endif
                auto *pWrapper = reinterpret_cast<ObjectWrapperBase*>(ObjectWrapperBufferCopy);

                // In a multithreaded environment, reference counters object may 
                // be destroyed at any time while m_pObject->~dtor() is running.
                // NOTE: m_pObject may not be the only object referencing m_pRefCounters.
                //       All objects that are owned by m_pObject will point to the same 
                //       reference counters object.

                // Note that this is the only place where m_ObjectState is
                // modified after the ref counters object has been created
                m_ObjectState = ObjectState::Destroyed;
                // The object is now detached from the reference counters and it is if
                // it was destroyed since no one can obtain access to it.


                // It is essentially important to check the number of weak references
                // while the object is locked. Otherwise reference counters object
                // may be destroyed twice if ReleaseWeakRef() is executed by other thread:
                //
                //             This thread             |    Another thread - ReleaseWeakRef()
                //                                     |           
                // 1. Decrement m_lNumStrongReferences,|   
                //    m_lNumStrongReferences==0,       |   
                //    acquire the lock, destroy        |
                //    the obj, release the lock        |
                //    m_lNumWeakReferences == 1        | 
                //                                     |   1. Aacquire the lock, 
                //                                     |      decrement m_lNumWeakReferences,
                //                                     |      m_lNumWeakReferences == 0, 
                //                                     |      m_ObjectState == ObjectState::Destroyed
                //                                     |
                // 2. Read m_lNumWeakReferences == 0   |
                // 3. Destroy the ref counters obj     |   2. Destroy the ref counters obj
                //
                bool bDestroyThis = m_lNumWeakReferences == 0;
                // ReleaseWeakRef() decrements m_lNumWeakReferences, and checks it for
                // zero only after acquiring the lock. So if m_lNumWeakReferences==0, no 
                // weak reference-related code may be running


                // We must explicitly unlock the object now to avoid deadlocks. Also, 
                // if this is deleted, this->m_LockFlag will expire, which will cause 
                // Lock.~LockHelper() to crash
                Lock.Unlock();

                // Destroy referenced object
                pWrapper->DestroyObject();

                // Note that <this> may be destroyed here already, 
                // see comments in ~ControlledObjectType()
                if( bDestroyThis )
                    SelfDestroy();
            }
    }

    function retain_weak()
    {
        return Atomics::AtomicIncrement(m_lNumWeakReferences);
    }

    function release_weak()
    {
 // The method must be serialized!
        ThreadingTools::LockHelper Lock(m_LockFlag);
        // It is essentially important to check the number of weak references
        // while holding the lock. Otherwise reference counters object
        // may be destroyed twice if ReleaseStrongRef() is executed by other 
        // thread.
        auto NumWeakReferences = Atomics::AtomicDecrement(m_lNumWeakReferences);
        VERIFY( NumWeakReferences >= 0, "Inconsistent call to ReleaseWeakRef()" );

        // There are two special case when we must not destroy the ref counters object even
        // when NumWeakReferences == 0 && m_lNumStrongReferences == 0 :
        //
        //             This thread             |    Another thread - ReleaseStrongRef()
        //                                     |
        // 1. Lock the object                  |
        //                                     |           
        // 2. Decrement m_lNumWeakReferences,  |   1. Decrement m_lNumStrongReferences,
        //    m_lNumWeakReferences==0          |      RefCount == 0
        //                                     |
        //                                     |   2. Start waiting for the lock to destroy
        //                                     |      the object, m_ObjectState != ObjectState::Destroyed
        // 3. Do not destroy reference         |
        //    counters, unlock                 |
        //                                     |   3. Acquire the lock, 
        //                                     |      destroy the object, 
        //                                     |      read m_lNumWeakReferences==0 
        //                                     |      destroy the reference counters
        //

        // If an exception is thrown during the object construction and there is a weak pointer to the object itself,
        // we may get to this point, but should not destroy the reference counters, because it will be destroyed by MakeNewRCObj
        // Consider this example:
        //
        //   A ==sp==> B ---wp---> A
        //
        //   MakeNewRCObj::operator()
        //    try
        //    {
        //     A.ctor()
        //       B.ctor()
        //        wp.ctor m_lNumWeakReferences==1
        //        throw
        //        wp.dtor m_lNumWeakReferences==0, destroy this
        //    }
        //    catch(...)
        //    {
        //       Destory ref counters second time
        //    }
        // 
        if( NumWeakReferences == 0 && /*m_lNumStrongReferences == 0 &&*/ m_ObjectState == ObjectState::Destroyed )
        {
            VERIFY_EXPR(m_lNumStrongReferences == 0);
            VERIFY( m_ObjectWrapperBuffer[0] == 0 && m_ObjectWrapperBuffer[1] == 0, "Object wrapper must be null")
            // m_ObjectState is set to ObjectState::Destroyed under the lock. If the state is not Destroyed, 
            // ReleaseStrongRef() will take care of it. 
            // Access to Object wrapper and decrementing m_lNumWeakReferences is atomic. Since we acquired the lock, 
            // no other thread can access either of them. 
            // Access to m_lNumStrongReferences is NOT PROTECTED by lock.

            // There are no more references to the ref counters object and the object itself
            // is already destroyed.
            // We can safely unlock it and destroy.
            // If we do not unlock it, this->m_LockFlag will expire, 
            // which will cause Lock.~LockHelper() to crash.
            Lock.Unlock();
            SelfDestroy();
        }
        return NumWeakReferences;
    }

    function shared() int
    {
        return this.shared_ref;
    }

    function weak() int
    {
        return this.weak_ref;
    }

    function get_object()
    {
        if( m_ObjectState != ObjectState::Alive)
            return; // Early exit

        // It is essential to INCREMENT REF COUNTER while HOLDING THE LOCK to make sure that 
        // StrongRefCnt > 1 guarantees that the object is alive.

        // If other thread started deleting the object in ReleaseStrongRef(), then m_lNumStrongReferences==0
        // We must make sure only one thread is allowed to increment the counter to guarantee that if StrongRefCnt > 1,
        // there is at least one real strong reference left. Otherwise the following scenario may occur:
        //
        //                                      m_lNumStrongReferences == 1
        //                                                                              
        //    Thread 1 - ReleaseStrongRef()    |     Thread 2 - GetObject()        |     Thread 3 - GetObject()
        //                                     |                                   |
        //  - Decrement m_lNumStrongReferences | -Increment m_lNumStrongReferences | -Increment m_lNumStrongReferences
        //  - Read RefCount == 0               | -Read StrongRefCnt==1             | -Read StrongRefCnt==2 
        //    Destroy the object               |                                   | -Return reference to the soon
        //                                     |                                   |  to expire object
        //     
        ThreadingTools::LockHelper Lock(m_LockFlag);

        auto StrongRefCnt = Atomics::AtomicIncrement(m_lNumStrongReferences);
            
        // Checking if m_ObjectState == ObjectState::Alive only is not reliable:
        //
        //           This thread                    |          Another thread
        //                                          |                                         
        //   1. Acquire the lock                    |                                         
        //                                          |    1. Decrement m_lNumStrongReferences  
        //   2. Increment m_lNumStrongReferences    |    2. Test RefCount==0                  
        //   3. Read StrongRefCnt == 1              |    3. Start destroying the object       
        //      m_ObjectState == ObjectState::Alive |
        //   4. DO NOT return the reference to      |    4. Wait for the lock, m_ObjectState == ObjectState::Alive
        //      the object                          |
        //   5. Decrement m_lNumStrongReferences    |
        //                                          |    5. Destroy the object

        if( m_ObjectState == ObjectState::Alive && StrongRefCnt > 1 )
        {
            VERIFY( m_ObjectWrapperBuffer[0] != 0 && m_ObjectWrapperBuffer[1] != 0, "Object wrapper is not initialized")
            // QueryInterface() must not lock the object, or a deadlock happens.
            // The only other two methods that lock the object are ReleaseStrongRef()
            // and ReleaseWeakRef(), which are never called by QueryInterface()
            auto *pWrapper = reinterpret_cast<ObjectWrapperBase*>(m_ObjectWrapperBuffer);
            pWrapper->QueryInterface(Diligent::IID_Unknown, ppObject);
        }
        Atomics::AtomicDecrement(m_lNumStrongReferences);
    }
}

/*
class IReferenceCounters
{
public:
    virtual Atomics::Long AddStrongRef() = 0;
    virtual Atomics::Long ReleaseStrongRef() = 0;
    virtual Atomics::Long AddWeakRef() = 0;
    virtual Atomics::Long ReleaseWeakRef() = 0;
    virtual void GetObject(class IObject **ppObject) = 0;
    virtual Atomics::Long GetNumStrongRefs()const = 0;
    virtual Atomics::Long GetNumWeakRefs()const = 0;
};*/