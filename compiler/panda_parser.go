// Code generated from PandaParser.g4 by ANTLR 4.7.1. DO NOT EDIT.

package compiler // PandaParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 111, 1377,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 3, 2, 5, 2, 264, 10, 2, 3, 2, 3,
	2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 276, 10, 3, 3,
	4, 3, 4, 5, 4, 280, 10, 4, 3, 5, 3, 5, 3, 5, 5, 5, 285, 10, 5, 3, 6, 3,
	6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 297, 10, 7, 3,
	7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 7, 7, 306, 10, 7, 12, 7, 14, 7,
	309, 11, 7, 3, 8, 5, 8, 312, 10, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9,
	5, 9, 320, 10, 9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 327, 10, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 334, 10, 10, 3, 10, 3, 10, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 5, 10, 352, 10, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 367,
	10, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 7, 10,
	377, 10, 10, 12, 10, 14, 10, 380, 11, 10, 3, 11, 3, 11, 3, 12, 3, 12, 3,
	12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 393, 10, 12, 3, 13,
	3, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 15, 3, 15, 5, 15, 403, 10, 15, 3,
	15, 3, 15, 5, 15, 407, 10, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 7, 16, 421, 10, 16, 12, 16, 14,
	16, 424, 11, 16, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
	3, 17, 7, 17, 435, 10, 17, 12, 17, 14, 17, 438, 11, 17, 3, 18, 3, 18, 3,
	18, 3, 18, 3, 18, 3, 18, 3, 18, 7, 18, 447, 10, 18, 12, 18, 14, 18, 450,
	11, 18, 3, 19, 3, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 7, 20, 469, 10,
	20, 12, 20, 14, 20, 472, 11, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 7, 21, 483, 10, 21, 12, 21, 14, 21, 486, 11, 21,
	3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 494, 10, 22, 12, 22, 14,
	22, 497, 11, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 7, 23, 505,
	10, 23, 12, 23, 14, 23, 508, 11, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24,
	3, 24, 7, 24, 516, 10, 24, 12, 24, 14, 24, 519, 11, 24, 3, 25, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 7, 25, 527, 10, 25, 12, 25, 14, 25, 530, 11, 25,
	3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 7, 26, 538, 10, 26, 12, 26, 14,
	26, 541, 11, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27,
	550, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 558, 10,
	28, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 568,
	10, 30, 12, 30, 14, 30, 571, 11, 30, 3, 31, 3, 31, 3, 32, 3, 32, 3, 32,
	3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 583, 10, 32, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 596,
	10, 33, 3, 34, 5, 34, 599, 10, 34, 3, 34, 3, 34, 3, 35, 3, 35, 5, 35, 605,
	10, 35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 7, 36, 614, 10,
	36, 12, 36, 14, 36, 617, 11, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 639, 10, 37, 3, 38, 3, 38, 3, 38, 3,
	38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38, 651, 10, 38, 3, 39,
	3, 39, 3, 39, 3, 39, 5, 39, 657, 10, 39, 3, 39, 3, 39, 5, 39, 661, 10,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 5, 39, 674, 10, 39, 3, 40, 3, 40, 5, 40, 678, 10, 40, 3, 41, 3,
	41, 3, 41, 3, 42, 3, 42, 5, 42, 685, 10, 42, 3, 43, 3, 43, 3, 43, 3, 43,
	3, 43, 3, 43, 5, 43, 693, 10, 43, 3, 43, 3, 43, 3, 43, 3, 43, 3, 43, 5,
	43, 700, 10, 43, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45,
	709, 10, 45, 12, 45, 14, 45, 712, 11, 45, 3, 46, 3, 46, 3, 46, 3, 46, 5,
	46, 718, 10, 46, 3, 47, 3, 47, 5, 47, 722, 10, 47, 3, 48, 5, 48, 725, 10,
	48, 3, 48, 5, 48, 728, 10, 48, 3, 48, 3, 48, 3, 49, 3, 49, 3, 50, 3, 50,
	3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 740, 10, 51, 3, 52, 3, 52, 3, 52, 5,
	52, 745, 10, 52, 3, 53, 3, 53, 5, 53, 749, 10, 53, 3, 54, 3, 54, 3, 54,
	3, 54, 5, 54, 755, 10, 54, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55, 761, 10,
	55, 3, 56, 5, 56, 764, 10, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56,
	3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3,
	56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5, 56, 791,
	10, 56, 3, 57, 3, 57, 3, 57, 5, 57, 796, 10, 57, 3, 58, 3, 58, 3, 59, 3,
	59, 3, 59, 5, 59, 803, 10, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59,
	3, 59, 3, 59, 5, 59, 813, 10, 59, 3, 60, 3, 60, 5, 60, 817, 10, 60, 3,
	60, 5, 60, 820, 10, 60, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63,
	3, 63, 3, 63, 3, 63, 3, 63, 7, 63, 833, 10, 63, 12, 63, 14, 63, 836, 11,
	63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64, 5, 64, 843, 10, 64, 3, 65, 3, 65,
	3, 66, 3, 66, 3, 67, 3, 67, 5, 67, 851, 10, 67, 3, 68, 3, 68, 5, 68, 855,
	10, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 72, 5, 72, 875,
	10, 72, 3, 73, 5, 73, 878, 10, 73, 3, 73, 3, 73, 3, 74, 3, 74, 5, 74, 884,
	10, 74, 3, 74, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75,
	7, 75, 895, 10, 75, 12, 75, 14, 75, 898, 11, 75, 3, 76, 3, 76, 5, 76, 902,
	10, 76, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 909, 10, 77, 3, 78, 3,
	78, 3, 78, 3, 78, 5, 78, 915, 10, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79,
	3, 79, 5, 79, 923, 10, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79, 930,
	10, 79, 3, 79, 7, 79, 933, 10, 79, 12, 79, 14, 79, 936, 11, 79, 3, 80,
	3, 80, 3, 80, 3, 80, 5, 80, 942, 10, 80, 3, 80, 5, 80, 945, 10, 80, 3,
	81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 83, 3, 83, 3, 84, 5, 84, 955, 10, 84,
	3, 84, 3, 84, 3, 85, 3, 85, 3, 86, 5, 86, 962, 10, 86, 3, 86, 5, 86, 965,
	10, 86, 3, 86, 3, 86, 3, 86, 3, 86, 5, 86, 971, 10, 86, 3, 87, 3, 87, 3,
	87, 3, 87, 3, 87, 3, 87, 7, 87, 979, 10, 87, 12, 87, 14, 87, 982, 11, 87,
	3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3,
	88, 3, 88, 3, 88, 5, 88, 997, 10, 88, 3, 89, 5, 89, 1000, 10, 89, 3, 89,
	3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 5, 90, 1010, 10, 90, 3,
	91, 3, 91, 3, 91, 3, 91, 3, 91, 5, 91, 1017, 10, 91, 3, 92, 3, 92, 3, 92,
	5, 92, 1022, 10, 92, 3, 93, 3, 93, 5, 93, 1026, 10, 93, 3, 94, 3, 94, 3,
	94, 5, 94, 1031, 10, 94, 3, 94, 3, 94, 3, 94, 3, 94, 5, 94, 1037, 10, 94,
	7, 94, 1039, 10, 94, 12, 94, 14, 94, 1042, 11, 94, 3, 95, 3, 95, 3, 95,
	5, 95, 1047, 10, 95, 3, 95, 3, 95, 3, 95, 3, 95, 5, 95, 1053, 10, 95, 3,
	96, 3, 96, 5, 96, 1057, 10, 96, 3, 97, 3, 97, 3, 97, 5, 97, 1062, 10, 97,
	3, 97, 3, 97, 3, 98, 3, 98, 3, 98, 5, 98, 1069, 10, 98, 3, 98, 3, 98, 5,
	98, 1073, 10, 98, 5, 98, 1075, 10, 98, 3, 99, 5, 99, 1078, 10, 99, 3, 99,
	3, 99, 3, 100, 3, 100, 5, 100, 1084, 10, 100, 3, 100, 3, 100, 3, 100, 5,
	100, 1089, 10, 100, 5, 100, 1091, 10, 100, 3, 101, 5, 101, 1094, 10, 101,
	3, 101, 5, 101, 1097, 10, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1102, 10,
	101, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 7, 102, 1110, 10,
	102, 12, 102, 14, 102, 1113, 11, 102, 3, 103, 3, 103, 3, 103, 5, 103, 1118,
	10, 103, 3, 103, 5, 103, 1121, 10, 103, 3, 103, 3, 103, 5, 103, 1125, 10,
	103, 3, 104, 3, 104, 3, 104, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3,
	105, 7, 105, 1136, 10, 105, 12, 105, 14, 105, 1139, 11, 105, 3, 106, 3,
	106, 3, 106, 3, 106, 5, 106, 1145, 10, 106, 3, 107, 5, 107, 1148, 10, 107,
	3, 107, 3, 107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 110, 3, 110, 5, 110,
	1158, 10, 110, 3, 110, 3, 110, 5, 110, 1162, 10, 110, 3, 110, 3, 110, 3,
	110, 5, 110, 1167, 10, 110, 3, 111, 3, 111, 3, 111, 5, 111, 1172, 10, 111,
	3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 5, 111, 1179, 10, 111, 3, 112,
	3, 112, 5, 112, 1183, 10, 112, 3, 113, 3, 113, 3, 113, 3, 114, 3, 114,
	3, 114, 3, 114, 3, 114, 3, 114, 7, 114, 1194, 10, 114, 12, 114, 14, 114,
	1197, 11, 114, 3, 115, 3, 115, 5, 115, 1201, 10, 115, 3, 116, 3, 116, 5,
	116, 1205, 10, 116, 3, 116, 5, 116, 1208, 10, 116, 3, 116, 3, 116, 5, 116,
	1212, 10, 116, 3, 116, 3, 116, 3, 116, 5, 116, 1217, 10, 116, 3, 116, 5,
	116, 1220, 10, 116, 3, 116, 5, 116, 1223, 10, 116, 3, 116, 3, 116, 3, 116,
	3, 116, 3, 116, 3, 116, 3, 116, 5, 116, 1232, 10, 116, 3, 116, 5, 116,
	1235, 10, 116, 3, 116, 3, 116, 3, 116, 3, 116, 3, 116, 5, 116, 1242, 10,
	116, 3, 116, 3, 116, 3, 116, 5, 116, 1247, 10, 116, 3, 117, 3, 117, 3,
	117, 5, 117, 1252, 10, 117, 3, 117, 3, 117, 3, 118, 3, 118, 3, 119, 3,
	119, 3, 119, 3, 119, 3, 119, 3, 119, 7, 119, 1264, 10, 119, 12, 119, 14,
	119, 1267, 11, 119, 3, 120, 3, 120, 3, 120, 5, 120, 1272, 10, 120, 3, 121,
	3, 121, 3, 121, 3, 121, 3, 121, 3, 121, 5, 121, 1280, 10, 121, 3, 122,
	3, 122, 3, 122, 3, 122, 3, 123, 3, 123, 3, 123, 3, 123, 3, 124, 3, 124,
	5, 124, 1292, 10, 124, 3, 125, 3, 125, 3, 125, 3, 125, 3, 125, 3, 125,
	3, 126, 3, 126, 3, 126, 3, 126, 3, 126, 5, 126, 1305, 10, 126, 3, 127,
	3, 127, 5, 127, 1309, 10, 127, 3, 128, 3, 128, 3, 128, 5, 128, 1314, 10,
	128, 3, 128, 3, 128, 3, 129, 3, 129, 3, 129, 5, 129, 1321, 10, 129, 3,
	129, 3, 129, 3, 129, 3, 129, 5, 129, 1327, 10, 129, 7, 129, 1329, 10, 129,
	12, 129, 14, 129, 1332, 11, 129, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130,
	3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130,
	3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130,
	3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130,
	3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 3, 130, 5, 130, 1373, 10,
	130, 3, 131, 3, 131, 3, 131, 2, 27, 12, 18, 30, 32, 34, 38, 40, 42, 44,
	46, 48, 50, 58, 70, 88, 124, 148, 156, 172, 186, 202, 208, 226, 236, 256,
	132, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36,
	38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72,
	74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106,
	108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136,
	138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166,
	168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196,
	198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226,
	228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256,
	258, 260, 2, 8, 4, 2, 59, 60, 66, 68, 3, 2, 79, 80, 5, 2, 69, 69, 72, 78,
	81, 82, 4, 2, 65, 65, 87, 87, 3, 2, 33, 35, 4, 2, 99, 99, 104, 107, 2,
	1495, 2, 263, 3, 2, 2, 2, 4, 275, 3, 2, 2, 2, 6, 279, 3, 2, 2, 2, 8, 284,
	3, 2, 2, 2, 10, 286, 3, 2, 2, 2, 12, 296, 3, 2, 2, 2, 14, 311, 3, 2, 2,
	2, 16, 315, 3, 2, 2, 2, 18, 351, 3, 2, 2, 2, 20, 381, 3, 2, 2, 2, 22, 392,
	3, 2, 2, 2, 24, 394, 3, 2, 2, 2, 26, 396, 3, 2, 2, 2, 28, 406, 3, 2, 2,
	2, 30, 408, 3, 2, 2, 2, 32, 425, 3, 2, 2, 2, 34, 439, 3, 2, 2, 2, 36, 451,
	3, 2, 2, 2, 38, 453, 3, 2, 2, 2, 40, 473, 3, 2, 2, 2, 42, 487, 3, 2, 2,
	2, 44, 498, 3, 2, 2, 2, 46, 509, 3, 2, 2, 2, 48, 520, 3, 2, 2, 2, 50, 531,
	3, 2, 2, 2, 52, 549, 3, 2, 2, 2, 54, 557, 3, 2, 2, 2, 56, 559, 3, 2, 2,
	2, 58, 561, 3, 2, 2, 2, 60, 572, 3, 2, 2, 2, 62, 582, 3, 2, 2, 2, 64, 595,
	3, 2, 2, 2, 66, 598, 3, 2, 2, 2, 68, 602, 3, 2, 2, 2, 70, 608, 3, 2, 2,
	2, 72, 638, 3, 2, 2, 2, 74, 650, 3, 2, 2, 2, 76, 673, 3, 2, 2, 2, 78, 677,
	3, 2, 2, 2, 80, 679, 3, 2, 2, 2, 82, 684, 3, 2, 2, 2, 84, 699, 3, 2, 2,
	2, 86, 701, 3, 2, 2, 2, 88, 703, 3, 2, 2, 2, 90, 717, 3, 2, 2, 2, 92, 721,
	3, 2, 2, 2, 94, 724, 3, 2, 2, 2, 96, 731, 3, 2, 2, 2, 98, 733, 3, 2, 2,
	2, 100, 739, 3, 2, 2, 2, 102, 744, 3, 2, 2, 2, 104, 748, 3, 2, 2, 2, 106,
	754, 3, 2, 2, 2, 108, 760, 3, 2, 2, 2, 110, 790, 3, 2, 2, 2, 112, 795,
	3, 2, 2, 2, 114, 797, 3, 2, 2, 2, 116, 812, 3, 2, 2, 2, 118, 814, 3, 2,
	2, 2, 120, 821, 3, 2, 2, 2, 122, 823, 3, 2, 2, 2, 124, 826, 3, 2, 2, 2,
	126, 842, 3, 2, 2, 2, 128, 844, 3, 2, 2, 2, 130, 846, 3, 2, 2, 2, 132,
	850, 3, 2, 2, 2, 134, 854, 3, 2, 2, 2, 136, 856, 3, 2, 2, 2, 138, 862,
	3, 2, 2, 2, 140, 868, 3, 2, 2, 2, 142, 874, 3, 2, 2, 2, 144, 877, 3, 2,
	2, 2, 146, 881, 3, 2, 2, 2, 148, 888, 3, 2, 2, 2, 150, 899, 3, 2, 2, 2,
	152, 908, 3, 2, 2, 2, 154, 914, 3, 2, 2, 2, 156, 922, 3, 2, 2, 2, 158,
	937, 3, 2, 2, 2, 160, 946, 3, 2, 2, 2, 162, 949, 3, 2, 2, 2, 164, 951,
	3, 2, 2, 2, 166, 954, 3, 2, 2, 2, 168, 958, 3, 2, 2, 2, 170, 970, 3, 2,
	2, 2, 172, 972, 3, 2, 2, 2, 174, 996, 3, 2, 2, 2, 176, 999, 3, 2, 2, 2,
	178, 1009, 3, 2, 2, 2, 180, 1016, 3, 2, 2, 2, 182, 1021, 3, 2, 2, 2, 184,
	1025, 3, 2, 2, 2, 186, 1027, 3, 2, 2, 2, 188, 1052, 3, 2, 2, 2, 190, 1056,
	3, 2, 2, 2, 192, 1058, 3, 2, 2, 2, 194, 1074, 3, 2, 2, 2, 196, 1077, 3,
	2, 2, 2, 198, 1090, 3, 2, 2, 2, 200, 1101, 3, 2, 2, 2, 202, 1103, 3, 2,
	2, 2, 204, 1124, 3, 2, 2, 2, 206, 1126, 3, 2, 2, 2, 208, 1129, 3, 2, 2,
	2, 210, 1144, 3, 2, 2, 2, 212, 1147, 3, 2, 2, 2, 214, 1151, 3, 2, 2, 2,
	216, 1153, 3, 2, 2, 2, 218, 1166, 3, 2, 2, 2, 220, 1178, 3, 2, 2, 2, 222,
	1182, 3, 2, 2, 2, 224, 1184, 3, 2, 2, 2, 226, 1187, 3, 2, 2, 2, 228, 1200,
	3, 2, 2, 2, 230, 1246, 3, 2, 2, 2, 232, 1248, 3, 2, 2, 2, 234, 1255, 3,
	2, 2, 2, 236, 1257, 3, 2, 2, 2, 238, 1271, 3, 2, 2, 2, 240, 1279, 3, 2,
	2, 2, 242, 1281, 3, 2, 2, 2, 244, 1285, 3, 2, 2, 2, 246, 1289, 3, 2, 2,
	2, 248, 1293, 3, 2, 2, 2, 250, 1304, 3, 2, 2, 2, 252, 1306, 3, 2, 2, 2,
	254, 1310, 3, 2, 2, 2, 256, 1317, 3, 2, 2, 2, 258, 1372, 3, 2, 2, 2, 260,
	1374, 3, 2, 2, 2, 262, 264, 5, 88, 45, 2, 263, 262, 3, 2, 2, 2, 263, 264,
	3, 2, 2, 2, 264, 265, 3, 2, 2, 2, 265, 266, 7, 2, 2, 3, 266, 3, 3, 2, 2,
	2, 267, 276, 5, 260, 131, 2, 268, 276, 7, 40, 2, 2, 269, 270, 7, 53, 2,
	2, 270, 271, 5, 58, 30, 2, 271, 272, 7, 54, 2, 2, 272, 276, 3, 2, 2, 2,
	273, 276, 5, 6, 4, 2, 274, 276, 5, 14, 8, 2, 275, 267, 3, 2, 2, 2, 275,
	268, 3, 2, 2, 2, 275, 269, 3, 2, 2, 2, 275, 273, 3, 2, 2, 2, 275, 274,
	3, 2, 2, 2, 276, 5, 3, 2, 2, 2, 277, 280, 5, 8, 5, 2, 278, 280, 5, 10,
	6, 2, 279, 277, 3, 2, 2, 2, 279, 278, 3, 2, 2, 2, 280, 7, 3, 2, 2, 2, 281,
	285, 7, 98, 2, 2, 282, 285, 5, 224, 113, 2, 283, 285, 5, 232, 117, 2, 284,
	281, 3, 2, 2, 2, 284, 282, 3, 2, 2, 2, 284, 283, 3, 2, 2, 2, 285, 9, 3,
	2, 2, 2, 286, 287, 5, 12, 7, 2, 287, 288, 5, 8, 5, 2, 288, 11, 3, 2, 2,
	2, 289, 290, 8, 7, 1, 2, 290, 291, 5, 112, 57, 2, 291, 292, 7, 96, 2, 2,
	292, 297, 3, 2, 2, 2, 293, 294, 5, 130, 66, 2, 294, 295, 7, 96, 2, 2, 295,
	297, 3, 2, 2, 2, 296, 289, 3, 2, 2, 2, 296, 293, 3, 2, 2, 2, 297, 307,
	3, 2, 2, 2, 298, 299, 12, 4, 2, 2, 299, 300, 7, 98, 2, 2, 300, 306, 7,
	96, 2, 2, 301, 302, 12, 3, 2, 2, 302, 303, 5, 232, 117, 2, 303, 304, 7,
	96, 2, 2, 304, 306, 3, 2, 2, 2, 305, 298, 3, 2, 2, 2, 305, 301, 3, 2, 2,
	2, 306, 309, 3, 2, 2, 2, 307, 305, 3, 2, 2, 2, 307, 308, 3, 2, 2, 2, 308,
	13, 3, 2, 2, 2, 309, 307, 3, 2, 2, 2, 310, 312, 5, 16, 9, 2, 311, 310,
	3, 2, 2, 2, 311, 312, 3, 2, 2, 2, 312, 313, 3, 2, 2, 2, 313, 314, 5, 68,
	35, 2, 314, 15, 3, 2, 2, 2, 315, 316, 7, 53, 2, 2, 316, 317, 5, 170, 86,
	2, 317, 319, 7, 54, 2, 2, 318, 320, 5, 160, 81, 2, 319, 318, 3, 2, 2, 2,
	319, 320, 3, 2, 2, 2, 320, 17, 3, 2, 2, 2, 321, 322, 8, 10, 1, 2, 322,
	352, 5, 4, 3, 2, 323, 324, 5, 110, 56, 2, 324, 326, 7, 53, 2, 2, 325, 327,
	5, 20, 11, 2, 326, 325, 3, 2, 2, 2, 326, 327, 3, 2, 2, 2, 327, 328, 3,
	2, 2, 2, 328, 329, 7, 54, 2, 2, 329, 352, 3, 2, 2, 2, 330, 331, 5, 240,
	121, 2, 331, 333, 7, 53, 2, 2, 332, 334, 5, 20, 11, 2, 333, 332, 3, 2,
	2, 2, 333, 334, 3, 2, 2, 2, 334, 335, 3, 2, 2, 2, 335, 336, 7, 54, 2, 2,
	336, 352, 3, 2, 2, 2, 337, 338, 5, 110, 56, 2, 338, 339, 5, 188, 95, 2,
	339, 352, 3, 2, 2, 2, 340, 341, 5, 240, 121, 2, 341, 342, 5, 188, 95, 2,
	342, 352, 3, 2, 2, 2, 343, 344, 7, 8, 2, 2, 344, 345, 7, 70, 2, 2, 345,
	346, 5, 168, 85, 2, 346, 347, 7, 71, 2, 2, 347, 348, 7, 53, 2, 2, 348,
	349, 5, 58, 30, 2, 349, 350, 7, 54, 2, 2, 350, 352, 3, 2, 2, 2, 351, 321,
	3, 2, 2, 2, 351, 323, 3, 2, 2, 2, 351, 330, 3, 2, 2, 2, 351, 337, 3, 2,
	2, 2, 351, 340, 3, 2, 2, 2, 351, 343, 3, 2, 2, 2, 352, 378, 3, 2, 2, 2,
	353, 354, 12, 13, 2, 2, 354, 355, 7, 55, 2, 2, 355, 356, 5, 58, 30, 2,
	356, 357, 7, 56, 2, 2, 357, 377, 3, 2, 2, 2, 358, 359, 12, 12, 2, 2, 359,
	360, 7, 55, 2, 2, 360, 361, 5, 188, 95, 2, 361, 362, 7, 56, 2, 2, 362,
	377, 3, 2, 2, 2, 363, 364, 12, 11, 2, 2, 364, 366, 7, 53, 2, 2, 365, 367,
	5, 20, 11, 2, 366, 365, 3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 368, 3,
	2, 2, 2, 368, 377, 7, 54, 2, 2, 369, 370, 12, 6, 2, 2, 370, 371, 7, 96,
	2, 2, 371, 377, 5, 6, 4, 2, 372, 373, 12, 5, 2, 2, 373, 377, 7, 89, 2,
	2, 374, 375, 12, 4, 2, 2, 375, 377, 7, 90, 2, 2, 376, 353, 3, 2, 2, 2,
	376, 358, 3, 2, 2, 2, 376, 363, 3, 2, 2, 2, 376, 369, 3, 2, 2, 2, 376,
	372, 3, 2, 2, 2, 376, 374, 3, 2, 2, 2, 377, 380, 3, 2, 2, 2, 378, 376,
	3, 2, 2, 2, 378, 379, 3, 2, 2, 2, 379, 19, 3, 2, 2, 2, 380, 378, 3, 2,
	2, 2, 381, 382, 5, 186, 94, 2, 382, 21, 3, 2, 2, 2, 383, 393, 5, 18, 10,
	2, 384, 385, 7, 89, 2, 2, 385, 393, 5, 22, 12, 2, 386, 387, 7, 90, 2, 2,
	387, 393, 5, 22, 12, 2, 388, 389, 5, 24, 13, 2, 389, 390, 5, 22, 12, 2,
	390, 393, 3, 2, 2, 2, 391, 393, 5, 26, 14, 2, 392, 383, 3, 2, 2, 2, 392,
	384, 3, 2, 2, 2, 392, 386, 3, 2, 2, 2, 392, 388, 3, 2, 2, 2, 392, 391,
	3, 2, 2, 2, 393, 23, 3, 2, 2, 2, 394, 395, 9, 2, 2, 2, 395, 25, 3, 2, 2,
	2, 396, 397, 7, 30, 2, 2, 397, 398, 5, 106, 54, 2, 398, 399, 5, 28, 15,
	2, 399, 27, 3, 2, 2, 2, 400, 402, 7, 53, 2, 2, 401, 403, 5, 20, 11, 2,
	402, 401, 3, 2, 2, 2, 402, 403, 3, 2, 2, 2, 403, 404, 3, 2, 2, 2, 404,
	407, 7, 54, 2, 2, 405, 407, 5, 188, 95, 2, 406, 400, 3, 2, 2, 2, 406, 405,
	3, 2, 2, 2, 407, 29, 3, 2, 2, 2, 408, 409, 8, 16, 1, 2, 409, 410, 5, 22,
	12, 2, 410, 422, 3, 2, 2, 2, 411, 412, 12, 5, 2, 2, 412, 413, 7, 61, 2,
	2, 413, 421, 5, 22, 12, 2, 414, 415, 12, 4, 2, 2, 415, 416, 7, 62, 2, 2,
	416, 421, 5, 22, 12, 2, 417, 418, 12, 3, 2, 2, 418, 419, 7, 63, 2, 2, 419,
	421, 5, 22, 12, 2, 420, 411, 3, 2, 2, 2, 420, 414, 3, 2, 2, 2, 420, 417,
	3, 2, 2, 2, 421, 424, 3, 2, 2, 2, 422, 420, 3, 2, 2, 2, 422, 423, 3, 2,
	2, 2, 423, 31, 3, 2, 2, 2, 424, 422, 3, 2, 2, 2, 425, 426, 8, 17, 1, 2,
	426, 427, 5, 30, 16, 2, 427, 436, 3, 2, 2, 2, 428, 429, 12, 4, 2, 2, 429,
	430, 7, 59, 2, 2, 430, 435, 5, 30, 16, 2, 431, 432, 12, 3, 2, 2, 432, 433,
	7, 60, 2, 2, 433, 435, 5, 30, 16, 2, 434, 428, 3, 2, 2, 2, 434, 431, 3,
	2, 2, 2, 435, 438, 3, 2, 2, 2, 436, 434, 3, 2, 2, 2, 436, 437, 3, 2, 2,
	2, 437, 33, 3, 2, 2, 2, 438, 436, 3, 2, 2, 2, 439, 440, 8, 18, 1, 2, 440,
	441, 5, 32, 17, 2, 441, 448, 3, 2, 2, 2, 442, 443, 12, 3, 2, 2, 443, 444,
	5, 36, 19, 2, 444, 445, 5, 32, 17, 2, 445, 447, 3, 2, 2, 2, 446, 442, 3,
	2, 2, 2, 447, 450, 3, 2, 2, 2, 448, 446, 3, 2, 2, 2, 448, 449, 3, 2, 2,
	2, 449, 35, 3, 2, 2, 2, 450, 448, 3, 2, 2, 2, 451, 452, 9, 3, 2, 2, 452,
	37, 3, 2, 2, 2, 453, 454, 8, 20, 1, 2, 454, 455, 5, 34, 18, 2, 455, 470,
	3, 2, 2, 2, 456, 457, 12, 6, 2, 2, 457, 458, 7, 70, 2, 2, 458, 469, 5,
	34, 18, 2, 459, 460, 12, 5, 2, 2, 460, 461, 7, 71, 2, 2, 461, 469, 5, 34,
	18, 2, 462, 463, 12, 4, 2, 2, 463, 464, 7, 85, 2, 2, 464, 469, 5, 34, 18,
	2, 465, 466, 12, 3, 2, 2, 466, 467, 7, 86, 2, 2, 467, 469, 5, 34, 18, 2,
	468, 456, 3, 2, 2, 2, 468, 459, 3, 2, 2, 2, 468, 462, 3, 2, 2, 2, 468,
	465, 3, 2, 2, 2, 469, 472, 3, 2, 2, 2, 470, 468, 3, 2, 2, 2, 470, 471,
	3, 2, 2, 2, 471, 39, 3, 2, 2, 2, 472, 470, 3, 2, 2, 2, 473, 474, 8, 21,
	1, 2, 474, 475, 5, 38, 20, 2, 475, 484, 3, 2, 2, 2, 476, 477, 12, 4, 2,
	2, 477, 478, 7, 83, 2, 2, 478, 483, 5, 38, 20, 2, 479, 480, 12, 3, 2, 2,
	480, 481, 7, 84, 2, 2, 481, 483, 5, 38, 20, 2, 482, 476, 3, 2, 2, 2, 482,
	479, 3, 2, 2, 2, 483, 486, 3, 2, 2, 2, 484, 482, 3, 2, 2, 2, 484, 485,
	3, 2, 2, 2, 485, 41, 3, 2, 2, 2, 486, 484, 3, 2, 2, 2, 487, 488, 8, 22,
	1, 2, 488, 489, 5, 40, 21, 2, 489, 495, 3, 2, 2, 2, 490, 491, 12, 3, 2,
	2, 491, 492, 7, 65, 2, 2, 492, 494, 5, 40, 21, 2, 493, 490, 3, 2, 2, 2,
	494, 497, 3, 2, 2, 2, 495, 493, 3, 2, 2, 2, 495, 496, 3, 2, 2, 2, 496,
	43, 3, 2, 2, 2, 497, 495, 3, 2, 2, 2, 498, 499, 8, 23, 1, 2, 499, 500,
	5, 42, 22, 2, 500, 506, 3, 2, 2, 2, 501, 502, 12, 3, 2, 2, 502, 503, 7,
	64, 2, 2, 503, 505, 5, 42, 22, 2, 504, 501, 3, 2, 2, 2, 505, 508, 3, 2,
	2, 2, 506, 504, 3, 2, 2, 2, 506, 507, 3, 2, 2, 2, 507, 45, 3, 2, 2, 2,
	508, 506, 3, 2, 2, 2, 509, 510, 8, 24, 1, 2, 510, 511, 5, 44, 23, 2, 511,
	517, 3, 2, 2, 2, 512, 513, 12, 3, 2, 2, 513, 514, 7, 66, 2, 2, 514, 516,
	5, 44, 23, 2, 515, 512, 3, 2, 2, 2, 516, 519, 3, 2, 2, 2, 517, 515, 3,
	2, 2, 2, 517, 518, 3, 2, 2, 2, 518, 47, 3, 2, 2, 2, 519, 517, 3, 2, 2,
	2, 520, 521, 8, 25, 1, 2, 521, 522, 5, 46, 24, 2, 522, 528, 3, 2, 2, 2,
	523, 524, 12, 3, 2, 2, 524, 525, 7, 87, 2, 2, 525, 527, 5, 46, 24, 2, 526,
	523, 3, 2, 2, 2, 527, 530, 3, 2, 2, 2, 528, 526, 3, 2, 2, 2, 528, 529,
	3, 2, 2, 2, 529, 49, 3, 2, 2, 2, 530, 528, 3, 2, 2, 2, 531, 532, 8, 26,
	1, 2, 532, 533, 5, 48, 25, 2, 533, 539, 3, 2, 2, 2, 534, 535, 12, 3, 2,
	2, 535, 536, 7, 88, 2, 2, 536, 538, 5, 48, 25, 2, 537, 534, 3, 2, 2, 2,
	538, 541, 3, 2, 2, 2, 539, 537, 3, 2, 2, 2, 539, 540, 3, 2, 2, 2, 540,
	51, 3, 2, 2, 2, 541, 539, 3, 2, 2, 2, 542, 550, 5, 50, 26, 2, 543, 544,
	5, 50, 26, 2, 544, 545, 7, 93, 2, 2, 545, 546, 5, 58, 30, 2, 546, 547,
	7, 94, 2, 2, 547, 548, 5, 54, 28, 2, 548, 550, 3, 2, 2, 2, 549, 542, 3,
	2, 2, 2, 549, 543, 3, 2, 2, 2, 550, 53, 3, 2, 2, 2, 551, 558, 5, 52, 27,
	2, 552, 553, 5, 50, 26, 2, 553, 554, 5, 56, 29, 2, 554, 555, 5, 184, 93,
	2, 555, 558, 3, 2, 2, 2, 556, 558, 5, 252, 127, 2, 557, 551, 3, 2, 2, 2,
	557, 552, 3, 2, 2, 2, 557, 556, 3, 2, 2, 2, 558, 55, 3, 2, 2, 2, 559, 560,
	9, 4, 2, 2, 560, 57, 3, 2, 2, 2, 561, 562, 8, 30, 1, 2, 562, 563, 5, 54,
	28, 2, 563, 569, 3, 2, 2, 2, 564, 565, 12, 3, 2, 2, 565, 566, 7, 91, 2,
	2, 566, 568, 5, 54, 28, 2, 567, 564, 3, 2, 2, 2, 568, 571, 3, 2, 2, 2,
	569, 567, 3, 2, 2, 2, 569, 570, 3, 2, 2, 2, 570, 59, 3, 2, 2, 2, 571, 569,
	3, 2, 2, 2, 572, 573, 5, 52, 27, 2, 573, 61, 3, 2, 2, 2, 574, 583, 5, 64,
	33, 2, 575, 583, 5, 66, 34, 2, 576, 583, 5, 68, 35, 2, 577, 583, 5, 72,
	37, 2, 578, 583, 5, 76, 39, 2, 579, 583, 5, 84, 43, 2, 580, 583, 5, 86,
	44, 2, 581, 583, 5, 242, 122, 2, 582, 574, 3, 2, 2, 2, 582, 575, 3, 2,
	2, 2, 582, 576, 3, 2, 2, 2, 582, 577, 3, 2, 2, 2, 582, 578, 3, 2, 2, 2,
	582, 579, 3, 2, 2, 2, 582, 580, 3, 2, 2, 2, 582, 581, 3, 2, 2, 2, 583,
	63, 3, 2, 2, 2, 584, 585, 7, 98, 2, 2, 585, 586, 7, 94, 2, 2, 586, 596,
	5, 62, 32, 2, 587, 588, 7, 7, 2, 2, 588, 589, 5, 60, 31, 2, 589, 590, 7,
	94, 2, 2, 590, 591, 5, 62, 32, 2, 591, 596, 3, 2, 2, 2, 592, 593, 7, 13,
	2, 2, 593, 594, 7, 94, 2, 2, 594, 596, 5, 62, 32, 2, 595, 584, 3, 2, 2,
	2, 595, 587, 3, 2, 2, 2, 595, 592, 3, 2, 2, 2, 596, 65, 3, 2, 2, 2, 597,
	599, 5, 58, 30, 2, 598, 597, 3, 2, 2, 2, 598, 599, 3, 2, 2, 2, 599, 600,
	3, 2, 2, 2, 600, 601, 7, 95, 2, 2, 601, 67, 3, 2, 2, 2, 602, 604, 7, 57,
	2, 2, 603, 605, 5, 70, 36, 2, 604, 603, 3, 2, 2, 2, 604, 605, 3, 2, 2,
	2, 605, 606, 3, 2, 2, 2, 606, 607, 7, 58, 2, 2, 607, 69, 3, 2, 2, 2, 608,
	609, 8, 36, 1, 2, 609, 610, 5, 62, 32, 2, 610, 615, 3, 2, 2, 2, 611, 612,
	12, 3, 2, 2, 612, 614, 5, 62, 32, 2, 613, 611, 3, 2, 2, 2, 614, 617, 3,
	2, 2, 2, 615, 613, 3, 2, 2, 2, 615, 616, 3, 2, 2, 2, 616, 71, 3, 2, 2,
	2, 617, 615, 3, 2, 2, 2, 618, 619, 7, 22, 2, 2, 619, 620, 7, 53, 2, 2,
	620, 621, 5, 74, 38, 2, 621, 622, 7, 54, 2, 2, 622, 623, 5, 62, 32, 2,
	623, 639, 3, 2, 2, 2, 624, 625, 7, 22, 2, 2, 625, 626, 7, 53, 2, 2, 626,
	627, 5, 74, 38, 2, 627, 628, 7, 54, 2, 2, 628, 629, 5, 62, 32, 2, 629,
	630, 7, 15, 2, 2, 630, 631, 5, 62, 32, 2, 631, 639, 3, 2, 2, 2, 632, 633,
	7, 39, 2, 2, 633, 634, 7, 53, 2, 2, 634, 635, 5, 74, 38, 2, 635, 636, 7,
	54, 2, 2, 636, 637, 5, 62, 32, 2, 637, 639, 3, 2, 2, 2, 638, 618, 3, 2,
	2, 2, 638, 624, 3, 2, 2, 2, 638, 632, 3, 2, 2, 2, 639, 73, 3, 2, 2, 2,
	640, 651, 5, 58, 30, 2, 641, 642, 5, 100, 51, 2, 642, 643, 5, 152, 77,
	2, 643, 644, 7, 69, 2, 2, 644, 645, 5, 184, 93, 2, 645, 651, 3, 2, 2, 2,
	646, 647, 5, 100, 51, 2, 647, 648, 5, 152, 77, 2, 648, 649, 5, 188, 95,
	2, 649, 651, 3, 2, 2, 2, 650, 640, 3, 2, 2, 2, 650, 641, 3, 2, 2, 2, 650,
	646, 3, 2, 2, 2, 651, 75, 3, 2, 2, 2, 652, 653, 7, 21, 2, 2, 653, 654,
	7, 53, 2, 2, 654, 656, 5, 78, 40, 2, 655, 657, 5, 74, 38, 2, 656, 655,
	3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657, 658, 3, 2, 2, 2, 658, 660, 7, 95,
	2, 2, 659, 661, 5, 58, 30, 2, 660, 659, 3, 2, 2, 2, 660, 661, 3, 2, 2,
	2, 661, 662, 3, 2, 2, 2, 662, 663, 7, 54, 2, 2, 663, 664, 5, 62, 32, 2,
	664, 674, 3, 2, 2, 2, 665, 666, 7, 21, 2, 2, 666, 667, 7, 53, 2, 2, 667,
	668, 5, 80, 41, 2, 668, 669, 7, 94, 2, 2, 669, 670, 5, 82, 42, 2, 670,
	671, 7, 54, 2, 2, 671, 672, 5, 62, 32, 2, 672, 674, 3, 2, 2, 2, 673, 652,
	3, 2, 2, 2, 673, 665, 3, 2, 2, 2, 674, 77, 3, 2, 2, 2, 675, 678, 5, 66,
	34, 2, 676, 678, 5, 94, 48, 2, 677, 675, 3, 2, 2, 2, 677, 676, 3, 2, 2,
	2, 678, 79, 3, 2, 2, 2, 679, 680, 5, 100, 51, 2, 680, 681, 5, 152, 77,
	2, 681, 81, 3, 2, 2, 2, 682, 685, 5, 58, 30, 2, 683, 685, 5, 188, 95, 2,
	684, 682, 3, 2, 2, 2, 684, 683, 3, 2, 2, 2, 685, 83, 3, 2, 2, 2, 686, 687,
	7, 5, 2, 2, 687, 700, 7, 95, 2, 2, 688, 689, 7, 12, 2, 2, 689, 700, 7,
	95, 2, 2, 690, 692, 7, 36, 2, 2, 691, 693, 5, 58, 30, 2, 692, 691, 3, 2,
	2, 2, 692, 693, 3, 2, 2, 2, 693, 694, 3, 2, 2, 2, 694, 700, 7, 95, 2, 2,
	695, 696, 7, 36, 2, 2, 696, 697, 5, 188, 95, 2, 697, 698, 7, 95, 2, 2,
	698, 700, 3, 2, 2, 2, 699, 686, 3, 2, 2, 2, 699, 688, 3, 2, 2, 2, 699,
	690, 3, 2, 2, 2, 699, 695, 3, 2, 2, 2, 700, 85, 3, 2, 2, 2, 701, 702, 5,
	92, 47, 2, 702, 87, 3, 2, 2, 2, 703, 704, 8, 45, 1, 2, 704, 705, 5, 90,
	46, 2, 705, 710, 3, 2, 2, 2, 706, 707, 12, 3, 2, 2, 707, 709, 5, 90, 46,
	2, 708, 706, 3, 2, 2, 2, 709, 712, 3, 2, 2, 2, 710, 708, 3, 2, 2, 2, 710,
	711, 3, 2, 2, 2, 711, 89, 3, 2, 2, 2, 712, 710, 3, 2, 2, 2, 713, 718, 5,
	92, 47, 2, 714, 718, 5, 176, 89, 2, 715, 718, 5, 132, 67, 2, 716, 718,
	5, 96, 49, 2, 717, 713, 3, 2, 2, 2, 717, 714, 3, 2, 2, 2, 717, 715, 3,
	2, 2, 2, 717, 716, 3, 2, 2, 2, 718, 91, 3, 2, 2, 2, 719, 722, 5, 94, 48,
	2, 720, 722, 5, 146, 74, 2, 721, 719, 3, 2, 2, 2, 721, 720, 3, 2, 2, 2,
	722, 93, 3, 2, 2, 2, 723, 725, 5, 100, 51, 2, 724, 723, 3, 2, 2, 2, 724,
	725, 3, 2, 2, 2, 725, 727, 3, 2, 2, 2, 726, 728, 5, 148, 75, 2, 727, 726,
	3, 2, 2, 2, 727, 728, 3, 2, 2, 2, 728, 729, 3, 2, 2, 2, 729, 730, 7, 95,
	2, 2, 730, 95, 3, 2, 2, 2, 731, 732, 7, 95, 2, 2, 732, 97, 3, 2, 2, 2,
	733, 734, 5, 102, 52, 2, 734, 99, 3, 2, 2, 2, 735, 740, 5, 98, 50, 2, 736,
	737, 5, 98, 50, 2, 737, 738, 5, 100, 51, 2, 738, 740, 3, 2, 2, 2, 739,
	735, 3, 2, 2, 2, 739, 736, 3, 2, 2, 2, 740, 101, 3, 2, 2, 2, 741, 745,
	5, 104, 53, 2, 742, 745, 5, 192, 97, 2, 743, 745, 5, 116, 59, 2, 744, 741,
	3, 2, 2, 2, 744, 742, 3, 2, 2, 2, 744, 743, 3, 2, 2, 2, 745, 103, 3, 2,
	2, 2, 746, 749, 5, 110, 56, 2, 747, 749, 5, 240, 121, 2, 748, 746, 3, 2,
	2, 2, 748, 747, 3, 2, 2, 2, 749, 105, 3, 2, 2, 2, 750, 755, 5, 102, 52,
	2, 751, 752, 5, 102, 52, 2, 752, 753, 5, 106, 54, 2, 753, 755, 3, 2, 2,
	2, 754, 750, 3, 2, 2, 2, 754, 751, 3, 2, 2, 2, 755, 107, 3, 2, 2, 2, 756,
	761, 5, 104, 53, 2, 757, 758, 5, 104, 53, 2, 758, 759, 5, 108, 55, 2, 759,
	761, 3, 2, 2, 2, 760, 756, 3, 2, 2, 2, 760, 757, 3, 2, 2, 2, 761, 109,
	3, 2, 2, 2, 762, 764, 5, 12, 7, 2, 763, 762, 3, 2, 2, 2, 763, 764, 3, 2,
	2, 2, 764, 765, 3, 2, 2, 2, 765, 791, 5, 112, 57, 2, 766, 767, 5, 12, 7,
	2, 767, 768, 5, 232, 117, 2, 768, 791, 3, 2, 2, 2, 769, 791, 7, 4, 2, 2,
	770, 791, 7, 24, 2, 2, 771, 791, 7, 25, 2, 2, 772, 791, 7, 26, 2, 2, 773,
	791, 7, 27, 2, 2, 774, 791, 7, 45, 2, 2, 775, 791, 7, 46, 2, 2, 776, 791,
	7, 47, 2, 2, 777, 791, 7, 48, 2, 2, 778, 791, 7, 23, 2, 2, 779, 791, 7,
	44, 2, 2, 780, 791, 7, 38, 2, 2, 781, 791, 7, 50, 2, 2, 782, 791, 7, 28,
	2, 2, 783, 791, 7, 49, 2, 2, 784, 791, 7, 17, 2, 2, 785, 791, 7, 18, 2,
	2, 786, 791, 7, 20, 2, 2, 787, 791, 7, 14, 2, 2, 788, 791, 7, 52, 2, 2,
	789, 791, 7, 3, 2, 2, 790, 763, 3, 2, 2, 2, 790, 766, 3, 2, 2, 2, 790,
	769, 3, 2, 2, 2, 790, 770, 3, 2, 2, 2, 790, 771, 3, 2, 2, 2, 790, 772,
	3, 2, 2, 2, 790, 773, 3, 2, 2, 2, 790, 774, 3, 2, 2, 2, 790, 775, 3, 2,
	2, 2, 790, 776, 3, 2, 2, 2, 790, 777, 3, 2, 2, 2, 790, 778, 3, 2, 2, 2,
	790, 779, 3, 2, 2, 2, 790, 780, 3, 2, 2, 2, 790, 781, 3, 2, 2, 2, 790,
	782, 3, 2, 2, 2, 790, 783, 3, 2, 2, 2, 790, 784, 3, 2, 2, 2, 790, 785,
	3, 2, 2, 2, 790, 786, 3, 2, 2, 2, 790, 787, 3, 2, 2, 2, 790, 788, 3, 2,
	2, 2, 790, 789, 3, 2, 2, 2, 791, 111, 3, 2, 2, 2, 792, 796, 5, 190, 96,
	2, 793, 796, 5, 114, 58, 2, 794, 796, 5, 232, 117, 2, 795, 792, 3, 2, 2,
	2, 795, 793, 3, 2, 2, 2, 795, 794, 3, 2, 2, 2, 796, 113, 3, 2, 2, 2, 797,
	798, 7, 98, 2, 2, 798, 115, 3, 2, 2, 2, 799, 800, 5, 118, 60, 2, 800, 802,
	7, 57, 2, 2, 801, 803, 5, 124, 63, 2, 802, 801, 3, 2, 2, 2, 802, 803, 3,
	2, 2, 2, 803, 804, 3, 2, 2, 2, 804, 805, 7, 58, 2, 2, 805, 813, 3, 2, 2,
	2, 806, 807, 5, 118, 60, 2, 807, 808, 7, 57, 2, 2, 808, 809, 5, 124, 63,
	2, 809, 810, 7, 91, 2, 2, 810, 811, 7, 58, 2, 2, 811, 813, 3, 2, 2, 2,
	812, 799, 3, 2, 2, 2, 812, 806, 3, 2, 2, 2, 813, 117, 3, 2, 2, 2, 814,
	816, 5, 120, 61, 2, 815, 817, 7, 98, 2, 2, 816, 815, 3, 2, 2, 2, 816, 817,
	3, 2, 2, 2, 817, 819, 3, 2, 2, 2, 818, 820, 5, 122, 62, 2, 819, 818, 3,
	2, 2, 2, 819, 820, 3, 2, 2, 2, 820, 119, 3, 2, 2, 2, 821, 822, 7, 16, 2,
	2, 822, 121, 3, 2, 2, 2, 823, 824, 7, 94, 2, 2, 824, 825, 5, 106, 54, 2,
	825, 123, 3, 2, 2, 2, 826, 827, 8, 63, 1, 2, 827, 828, 5, 126, 64, 2, 828,
	834, 3, 2, 2, 2, 829, 830, 12, 3, 2, 2, 830, 831, 7, 91, 2, 2, 831, 833,
	5, 126, 64, 2, 832, 829, 3, 2, 2, 2, 833, 836, 3, 2, 2, 2, 834, 832, 3,
	2, 2, 2, 834, 835, 3, 2, 2, 2, 835, 125, 3, 2, 2, 2, 836, 834, 3, 2, 2,
	2, 837, 843, 5, 128, 65, 2, 838, 839, 5, 128, 65, 2, 839, 840, 7, 69, 2,
	2, 840, 841, 5, 60, 31, 2, 841, 843, 3, 2, 2, 2, 842, 837, 3, 2, 2, 2,
	842, 838, 3, 2, 2, 2, 843, 127, 3, 2, 2, 2, 844, 845, 7, 98, 2, 2, 845,
	129, 3, 2, 2, 2, 846, 847, 7, 98, 2, 2, 847, 131, 3, 2, 2, 2, 848, 851,
	5, 134, 68, 2, 849, 851, 5, 140, 71, 2, 850, 848, 3, 2, 2, 2, 850, 849,
	3, 2, 2, 2, 851, 133, 3, 2, 2, 2, 852, 855, 5, 136, 69, 2, 853, 855, 5,
	138, 70, 2, 854, 852, 3, 2, 2, 2, 854, 853, 3, 2, 2, 2, 855, 135, 3, 2,
	2, 2, 856, 857, 7, 29, 2, 2, 857, 858, 7, 98, 2, 2, 858, 859, 7, 57, 2,
	2, 859, 860, 5, 142, 72, 2, 860, 861, 7, 58, 2, 2, 861, 137, 3, 2, 2, 2,
	862, 863, 7, 29, 2, 2, 863, 864, 5, 130, 66, 2, 864, 865, 7, 57, 2, 2,
	865, 866, 5, 142, 72, 2, 866, 867, 7, 58, 2, 2, 867, 139, 3, 2, 2, 2, 868,
	869, 7, 29, 2, 2, 869, 870, 7, 57, 2, 2, 870, 871, 5, 142, 72, 2, 871,
	872, 7, 58, 2, 2, 872, 141, 3, 2, 2, 2, 873, 875, 5, 88, 45, 2, 874, 873,
	3, 2, 2, 2, 874, 875, 3, 2, 2, 2, 875, 143, 3, 2, 2, 2, 876, 878, 5, 12,
	7, 2, 877, 876, 3, 2, 2, 2, 877, 878, 3, 2, 2, 2, 878, 879, 3, 2, 2, 2,
	879, 880, 5, 130, 66, 2, 880, 145, 3, 2, 2, 2, 881, 883, 7, 51, 2, 2, 882,
	884, 5, 12, 7, 2, 883, 882, 3, 2, 2, 2, 883, 884, 3, 2, 2, 2, 884, 885,
	3, 2, 2, 2, 885, 886, 5, 130, 66, 2, 886, 887, 7, 95, 2, 2, 887, 147, 3,
	2, 2, 2, 888, 889, 8, 75, 1, 2, 889, 890, 5, 150, 76, 2, 890, 896, 3, 2,
	2, 2, 891, 892, 12, 3, 2, 2, 892, 893, 7, 91, 2, 2, 893, 895, 5, 150, 76,
	2, 894, 891, 3, 2, 2, 2, 895, 898, 3, 2, 2, 2, 896, 894, 3, 2, 2, 2, 896,
	897, 3, 2, 2, 2, 897, 149, 3, 2, 2, 2, 898, 896, 3, 2, 2, 2, 899, 901,
	5, 152, 77, 2, 900, 902, 5, 180, 91, 2, 901, 900, 3, 2, 2, 2, 901, 902,
	3, 2, 2, 2, 902, 151, 3, 2, 2, 2, 903, 909, 5, 154, 78, 2, 904, 905, 5,
	156, 79, 2, 905, 906, 5, 158, 80, 2, 906, 907, 5, 160, 81, 2, 907, 909,
	3, 2, 2, 2, 908, 903, 3, 2, 2, 2, 908, 904, 3, 2, 2, 2, 909, 153, 3, 2,
	2, 2, 910, 915, 5, 156, 79, 2, 911, 912, 5, 162, 82, 2, 912, 913, 5, 154,
	78, 2, 913, 915, 3, 2, 2, 2, 914, 910, 3, 2, 2, 2, 914, 911, 3, 2, 2, 2,
	915, 155, 3, 2, 2, 2, 916, 917, 8, 79, 1, 2, 917, 923, 5, 166, 84, 2, 918,
	919, 7, 53, 2, 2, 919, 920, 5, 154, 78, 2, 920, 921, 7, 54, 2, 2, 921,
	923, 3, 2, 2, 2, 922, 916, 3, 2, 2, 2, 922, 918, 3, 2, 2, 2, 923, 934,
	3, 2, 2, 2, 924, 925, 12, 5, 2, 2, 925, 933, 5, 158, 80, 2, 926, 927, 12,
	4, 2, 2, 927, 929, 7, 55, 2, 2, 928, 930, 5, 60, 31, 2, 929, 928, 3, 2,
	2, 2, 929, 930, 3, 2, 2, 2, 930, 931, 3, 2, 2, 2, 931, 933, 7, 56, 2, 2,
	932, 924, 3, 2, 2, 2, 932, 926, 3, 2, 2, 2, 933, 936, 3, 2, 2, 2, 934,
	932, 3, 2, 2, 2, 934, 935, 3, 2, 2, 2, 935, 157, 3, 2, 2, 2, 936, 934,
	3, 2, 2, 2, 937, 938, 7, 53, 2, 2, 938, 939, 5, 170, 86, 2, 939, 941, 7,
	54, 2, 2, 940, 942, 5, 164, 83, 2, 941, 940, 3, 2, 2, 2, 941, 942, 3, 2,
	2, 2, 942, 944, 3, 2, 2, 2, 943, 945, 5, 254, 128, 2, 944, 943, 3, 2, 2,
	2, 944, 945, 3, 2, 2, 2, 945, 159, 3, 2, 2, 2, 946, 947, 7, 92, 2, 2, 947,
	948, 5, 108, 55, 2, 948, 161, 3, 2, 2, 2, 949, 950, 7, 65, 2, 2, 950, 163,
	3, 2, 2, 2, 951, 952, 9, 5, 2, 2, 952, 165, 3, 2, 2, 2, 953, 955, 7, 97,
	2, 2, 954, 953, 3, 2, 2, 2, 954, 955, 3, 2, 2, 2, 955, 956, 3, 2, 2, 2,
	956, 957, 5, 6, 4, 2, 957, 167, 3, 2, 2, 2, 958, 959, 5, 106, 54, 2, 959,
	169, 3, 2, 2, 2, 960, 962, 5, 172, 87, 2, 961, 960, 3, 2, 2, 2, 961, 962,
	3, 2, 2, 2, 962, 964, 3, 2, 2, 2, 963, 965, 7, 97, 2, 2, 964, 963, 3, 2,
	2, 2, 964, 965, 3, 2, 2, 2, 965, 971, 3, 2, 2, 2, 966, 967, 5, 172, 87,
	2, 967, 968, 7, 91, 2, 2, 968, 969, 7, 97, 2, 2, 969, 971, 3, 2, 2, 2,
	970, 961, 3, 2, 2, 2, 970, 966, 3, 2, 2, 2, 971, 171, 3, 2, 2, 2, 972,
	973, 8, 87, 1, 2, 973, 974, 5, 174, 88, 2, 974, 980, 3, 2, 2, 2, 975, 976,
	12, 3, 2, 2, 976, 977, 7, 91, 2, 2, 977, 979, 5, 174, 88, 2, 978, 975,
	3, 2, 2, 2, 979, 982, 3, 2, 2, 2, 980, 978, 3, 2, 2, 2, 980, 981, 3, 2,
	2, 2, 981, 173, 3, 2, 2, 2, 982, 980, 3, 2, 2, 2, 983, 984, 5, 100, 51,
	2, 984, 985, 5, 152, 77, 2, 985, 997, 3, 2, 2, 2, 986, 987, 5, 100, 51,
	2, 987, 988, 5, 152, 77, 2, 988, 989, 7, 69, 2, 2, 989, 990, 5, 184, 93,
	2, 990, 997, 3, 2, 2, 2, 991, 997, 5, 100, 51, 2, 992, 993, 5, 100, 51,
	2, 993, 994, 7, 69, 2, 2, 994, 995, 5, 184, 93, 2, 995, 997, 3, 2, 2, 2,
	996, 983, 3, 2, 2, 2, 996, 986, 3, 2, 2, 2, 996, 991, 3, 2, 2, 2, 996,
	992, 3, 2, 2, 2, 997, 175, 3, 2, 2, 2, 998, 1000, 5, 100, 51, 2, 999, 998,
	3, 2, 2, 2, 999, 1000, 3, 2, 2, 2, 1000, 1001, 3, 2, 2, 2, 1001, 1002,
	5, 152, 77, 2, 1002, 1003, 5, 178, 90, 2, 1003, 177, 3, 2, 2, 2, 1004,
	1010, 5, 68, 35, 2, 1005, 1010, 5, 244, 123, 2, 1006, 1007, 7, 69, 2, 2,
	1007, 1008, 7, 13, 2, 2, 1008, 1010, 7, 95, 2, 2, 1009, 1004, 3, 2, 2,
	2, 1009, 1005, 3, 2, 2, 2, 1009, 1006, 3, 2, 2, 2, 1010, 179, 3, 2, 2,
	2, 1011, 1017, 5, 182, 92, 2, 1012, 1013, 7, 53, 2, 2, 1013, 1014, 5, 20,
	11, 2, 1014, 1015, 7, 54, 2, 2, 1015, 1017, 3, 2, 2, 2, 1016, 1011, 3,
	2, 2, 2, 1016, 1012, 3, 2, 2, 2, 1017, 181, 3, 2, 2, 2, 1018, 1019, 7,
	69, 2, 2, 1019, 1022, 5, 184, 93, 2, 1020, 1022, 5, 188, 95, 2, 1021, 1018,
	3, 2, 2, 2, 1021, 1020, 3, 2, 2, 2, 1022, 183, 3, 2, 2, 2, 1023, 1026,
	5, 54, 28, 2, 1024, 1026, 5, 188, 95, 2, 1025, 1023, 3, 2, 2, 2, 1025,
	1024, 3, 2, 2, 2, 1026, 185, 3, 2, 2, 2, 1027, 1028, 8, 94, 1, 2, 1028,
	1030, 5, 184, 93, 2, 1029, 1031, 7, 97, 2, 2, 1030, 1029, 3, 2, 2, 2, 1030,
	1031, 3, 2, 2, 2, 1031, 1040, 3, 2, 2, 2, 1032, 1033, 12, 3, 2, 2, 1033,
	1034, 7, 91, 2, 2, 1034, 1036, 5, 184, 93, 2, 1035, 1037, 7, 97, 2, 2,
	1036, 1035, 3, 2, 2, 2, 1036, 1037, 3, 2, 2, 2, 1037, 1039, 3, 2, 2, 2,
	1038, 1032, 3, 2, 2, 2, 1039, 1042, 3, 2, 2, 2, 1040, 1038, 3, 2, 2, 2,
	1040, 1041, 3, 2, 2, 2, 1041, 187, 3, 2, 2, 2, 1042, 1040, 3, 2, 2, 2,
	1043, 1044, 7, 57, 2, 2, 1044, 1046, 5, 186, 94, 2, 1045, 1047, 7, 91,
	2, 2, 1046, 1045, 3, 2, 2, 2, 1046, 1047, 3, 2, 2, 2, 1047, 1048, 3, 2,
	2, 2, 1048, 1049, 7, 58, 2, 2, 1049, 1053, 3, 2, 2, 2, 1050, 1051, 7, 57,
	2, 2, 1051, 1053, 7, 58, 2, 2, 1052, 1043, 3, 2, 2, 2, 1052, 1050, 3, 2,
	2, 2, 1053, 189, 3, 2, 2, 2, 1054, 1057, 7, 98, 2, 2, 1055, 1057, 5, 232,
	117, 2, 1056, 1054, 3, 2, 2, 2, 1056, 1055, 3, 2, 2, 2, 1057, 191, 3, 2,
	2, 2, 1058, 1059, 5, 194, 98, 2, 1059, 1061, 7, 57, 2, 2, 1060, 1062, 5,
	198, 100, 2, 1061, 1060, 3, 2, 2, 2, 1061, 1062, 3, 2, 2, 2, 1062, 1063,
	3, 2, 2, 2, 1063, 1064, 7, 58, 2, 2, 1064, 193, 3, 2, 2, 2, 1065, 1066,
	7, 10, 2, 2, 1066, 1068, 5, 196, 99, 2, 1067, 1069, 5, 206, 104, 2, 1068,
	1067, 3, 2, 2, 2, 1068, 1069, 3, 2, 2, 2, 1069, 1075, 3, 2, 2, 2, 1070,
	1072, 7, 10, 2, 2, 1071, 1073, 5, 206, 104, 2, 1072, 1071, 3, 2, 2, 2,
	1072, 1073, 3, 2, 2, 2, 1073, 1075, 3, 2, 2, 2, 1074, 1065, 3, 2, 2, 2,
	1074, 1070, 3, 2, 2, 2, 1075, 195, 3, 2, 2, 2, 1076, 1078, 5, 12, 7, 2,
	1077, 1076, 3, 2, 2, 2, 1077, 1078, 3, 2, 2, 2, 1078, 1079, 3, 2, 2, 2,
	1079, 1080, 5, 190, 96, 2, 1080, 197, 3, 2, 2, 2, 1081, 1083, 5, 200, 101,
	2, 1082, 1084, 5, 198, 100, 2, 1083, 1082, 3, 2, 2, 2, 1083, 1084, 3, 2,
	2, 2, 1084, 1091, 3, 2, 2, 2, 1085, 1086, 5, 216, 109, 2, 1086, 1088, 7,
	94, 2, 2, 1087, 1089, 5, 198, 100, 2, 1088, 1087, 3, 2, 2, 2, 1088, 1089,
	3, 2, 2, 2, 1089, 1091, 3, 2, 2, 2, 1090, 1081, 3, 2, 2, 2, 1090, 1085,
	3, 2, 2, 2, 1091, 199, 3, 2, 2, 2, 1092, 1094, 5, 100, 51, 2, 1093, 1092,
	3, 2, 2, 2, 1093, 1094, 3, 2, 2, 2, 1094, 1096, 3, 2, 2, 2, 1095, 1097,
	5, 202, 102, 2, 1096, 1095, 3, 2, 2, 2, 1096, 1097, 3, 2, 2, 2, 1097, 1098,
	3, 2, 2, 2, 1098, 1102, 7, 95, 2, 2, 1099, 1102, 5, 176, 89, 2, 1100, 1102,
	5, 96, 49, 2, 1101, 1093, 3, 2, 2, 2, 1101, 1099, 3, 2, 2, 2, 1101, 1100,
	3, 2, 2, 2, 1102, 201, 3, 2, 2, 2, 1103, 1104, 8, 102, 1, 2, 1104, 1105,
	5, 204, 103, 2, 1105, 1111, 3, 2, 2, 2, 1106, 1107, 12, 3, 2, 2, 1107,
	1108, 7, 91, 2, 2, 1108, 1110, 5, 204, 103, 2, 1109, 1106, 3, 2, 2, 2,
	1110, 1113, 3, 2, 2, 2, 1111, 1109, 3, 2, 2, 2, 1111, 1112, 3, 2, 2, 2,
	1112, 203, 3, 2, 2, 2, 1113, 1111, 3, 2, 2, 2, 1114, 1125, 5, 152, 77,
	2, 1115, 1117, 5, 152, 77, 2, 1116, 1118, 5, 182, 92, 2, 1117, 1116, 3,
	2, 2, 2, 1117, 1118, 3, 2, 2, 2, 1118, 1125, 3, 2, 2, 2, 1119, 1121, 7,
	98, 2, 2, 1120, 1119, 3, 2, 2, 2, 1120, 1121, 3, 2, 2, 2, 1121, 1122, 3,
	2, 2, 2, 1122, 1123, 7, 94, 2, 2, 1123, 1125, 5, 60, 31, 2, 1124, 1114,
	3, 2, 2, 2, 1124, 1115, 3, 2, 2, 2, 1124, 1120, 3, 2, 2, 2, 1125, 205,
	3, 2, 2, 2, 1126, 1127, 7, 94, 2, 2, 1127, 1128, 5, 208, 105, 2, 1128,
	207, 3, 2, 2, 2, 1129, 1130, 8, 105, 1, 2, 1130, 1131, 5, 210, 106, 2,
	1131, 1137, 3, 2, 2, 2, 1132, 1133, 12, 3, 2, 2, 1133, 1134, 7, 91, 2,
	2, 1134, 1136, 5, 210, 106, 2, 1135, 1132, 3, 2, 2, 2, 1136, 1139, 3, 2,
	2, 2, 1137, 1135, 3, 2, 2, 2, 1137, 1138, 3, 2, 2, 2, 1138, 209, 3, 2,
	2, 2, 1139, 1137, 3, 2, 2, 2, 1140, 1145, 5, 214, 108, 2, 1141, 1142, 5,
	216, 109, 2, 1142, 1143, 5, 214, 108, 2, 1143, 1145, 3, 2, 2, 2, 1144,
	1140, 3, 2, 2, 2, 1144, 1141, 3, 2, 2, 2, 1145, 211, 3, 2, 2, 2, 1146,
	1148, 5, 12, 7, 2, 1147, 1146, 3, 2, 2, 2, 1147, 1148, 3, 2, 2, 2, 1148,
	1149, 3, 2, 2, 2, 1149, 1150, 5, 190, 96, 2, 1150, 213, 3, 2, 2, 2, 1151,
	1152, 5, 212, 107, 2, 1152, 215, 3, 2, 2, 2, 1153, 1154, 9, 6, 2, 2, 1154,
	217, 3, 2, 2, 2, 1155, 1157, 5, 220, 111, 2, 1156, 1158, 7, 97, 2, 2, 1157,
	1156, 3, 2, 2, 2, 1157, 1158, 3, 2, 2, 2, 1158, 1167, 3, 2, 2, 2, 1159,
	1161, 5, 220, 111, 2, 1160, 1162, 7, 97, 2, 2, 1161, 1160, 3, 2, 2, 2,
	1161, 1162, 3, 2, 2, 2, 1162, 1163, 3, 2, 2, 2, 1163, 1164, 7, 91, 2, 2,
	1164, 1165, 5, 218, 110, 2, 1165, 1167, 3, 2, 2, 2, 1166, 1155, 3, 2, 2,
	2, 1166, 1159, 3, 2, 2, 2, 1167, 219, 3, 2, 2, 2, 1168, 1169, 5, 222, 112,
	2, 1169, 1171, 7, 53, 2, 2, 1170, 1172, 5, 20, 11, 2, 1171, 1170, 3, 2,
	2, 2, 1171, 1172, 3, 2, 2, 2, 1172, 1173, 3, 2, 2, 2, 1173, 1174, 7, 54,
	2, 2, 1174, 1179, 3, 2, 2, 2, 1175, 1176, 5, 222, 112, 2, 1176, 1177, 5,
	188, 95, 2, 1177, 1179, 3, 2, 2, 2, 1178, 1168, 3, 2, 2, 2, 1178, 1175,
	3, 2, 2, 2, 1179, 221, 3, 2, 2, 2, 1180, 1183, 5, 212, 107, 2, 1181, 1183,
	7, 98, 2, 2, 1182, 1180, 3, 2, 2, 2, 1182, 1181, 3, 2, 2, 2, 1183, 223,
	3, 2, 2, 2, 1184, 1185, 7, 32, 2, 2, 1185, 1186, 5, 258, 130, 2, 1186,
	225, 3, 2, 2, 2, 1187, 1188, 8, 114, 1, 2, 1188, 1189, 5, 228, 115, 2,
	1189, 1195, 3, 2, 2, 2, 1190, 1191, 12, 3, 2, 2, 1191, 1192, 7, 91, 2,
	2, 1192, 1194, 5, 228, 115, 2, 1193, 1190, 3, 2, 2, 2, 1194, 1197, 3, 2,
	2, 2, 1195, 1193, 3, 2, 2, 2, 1195, 1196, 3, 2, 2, 2, 1196, 227, 3, 2,
	2, 2, 1197, 1195, 3, 2, 2, 2, 1198, 1201, 5, 230, 116, 2, 1199, 1201, 5,
	174, 88, 2, 1200, 1198, 3, 2, 2, 2, 1200, 1199, 3, 2, 2, 2, 1201, 229,
	3, 2, 2, 2, 1202, 1204, 7, 10, 2, 2, 1203, 1205, 7, 97, 2, 2, 1204, 1203,
	3, 2, 2, 2, 1204, 1205, 3, 2, 2, 2, 1205, 1207, 3, 2, 2, 2, 1206, 1208,
	7, 98, 2, 2, 1207, 1206, 3, 2, 2, 2, 1207, 1208, 3, 2, 2, 2, 1208, 1247,
	3, 2, 2, 2, 1209, 1211, 7, 10, 2, 2, 1210, 1212, 7, 98, 2, 2, 1211, 1210,
	3, 2, 2, 2, 1211, 1212, 3, 2, 2, 2, 1212, 1213, 3, 2, 2, 2, 1213, 1214,
	7, 69, 2, 2, 1214, 1247, 5, 168, 85, 2, 1215, 1217, 7, 97, 2, 2, 1216,
	1215, 3, 2, 2, 2, 1216, 1217, 3, 2, 2, 2, 1217, 1219, 3, 2, 2, 2, 1218,
	1220, 7, 98, 2, 2, 1219, 1218, 3, 2, 2, 2, 1219, 1220, 3, 2, 2, 2, 1220,
	1247, 3, 2, 2, 2, 1221, 1223, 7, 98, 2, 2, 1222, 1221, 3, 2, 2, 2, 1222,
	1223, 3, 2, 2, 2, 1223, 1224, 3, 2, 2, 2, 1224, 1225, 7, 69, 2, 2, 1225,
	1247, 5, 168, 85, 2, 1226, 1227, 7, 70, 2, 2, 1227, 1228, 5, 226, 114,
	2, 1228, 1229, 7, 71, 2, 2, 1229, 1231, 7, 10, 2, 2, 1230, 1232, 7, 97,
	2, 2, 1231, 1230, 3, 2, 2, 2, 1231, 1232, 3, 2, 2, 2, 1232, 1234, 3, 2,
	2, 2, 1233, 1235, 7, 98, 2, 2, 1234, 1233, 3, 2, 2, 2, 1234, 1235, 3, 2,
	2, 2, 1235, 1247, 3, 2, 2, 2, 1236, 1237, 7, 70, 2, 2, 1237, 1238, 5, 226,
	114, 2, 1238, 1239, 7, 71, 2, 2, 1239, 1241, 7, 10, 2, 2, 1240, 1242, 7,
	98, 2, 2, 1241, 1240, 3, 2, 2, 2, 1241, 1242, 3, 2, 2, 2, 1242, 1243, 3,
	2, 2, 2, 1243, 1244, 7, 69, 2, 2, 1244, 1245, 5, 6, 4, 2, 1245, 1247, 3,
	2, 2, 2, 1246, 1202, 3, 2, 2, 2, 1246, 1209, 3, 2, 2, 2, 1246, 1216, 3,
	2, 2, 2, 1246, 1222, 3, 2, 2, 2, 1246, 1226, 3, 2, 2, 2, 1246, 1236, 3,
	2, 2, 2, 1247, 231, 3, 2, 2, 2, 1248, 1249, 5, 234, 118, 2, 1249, 1251,
	7, 70, 2, 2, 1250, 1252, 5, 236, 119, 2, 1251, 1250, 3, 2, 2, 2, 1251,
	1252, 3, 2, 2, 2, 1252, 1253, 3, 2, 2, 2, 1253, 1254, 7, 71, 2, 2, 1254,
	233, 3, 2, 2, 2, 1255, 1256, 7, 98, 2, 2, 1256, 235, 3, 2, 2, 2, 1257,
	1258, 8, 119, 1, 2, 1258, 1259, 5, 238, 120, 2, 1259, 1265, 3, 2, 2, 2,
	1260, 1261, 12, 3, 2, 2, 1261, 1262, 7, 91, 2, 2, 1262, 1264, 5, 238, 120,
	2, 1263, 1260, 3, 2, 2, 2, 1264, 1267, 3, 2, 2, 2, 1265, 1263, 3, 2, 2,
	2, 1265, 1266, 3, 2, 2, 2, 1266, 237, 3, 2, 2, 2, 1267, 1265, 3, 2, 2,
	2, 1268, 1272, 5, 168, 85, 2, 1269, 1272, 5, 60, 31, 2, 1270, 1272, 5,
	6, 4, 2, 1271, 1268, 3, 2, 2, 2, 1271, 1269, 3, 2, 2, 2, 1271, 1270, 3,
	2, 2, 2, 1272, 239, 3, 2, 2, 2, 1273, 1274, 5, 12, 7, 2, 1274, 1275, 7,
	98, 2, 2, 1275, 1280, 3, 2, 2, 2, 1276, 1277, 5, 12, 7, 2, 1277, 1278,
	5, 232, 117, 2, 1278, 1280, 3, 2, 2, 2, 1279, 1273, 3, 2, 2, 2, 1279, 1276,
	3, 2, 2, 2, 1280, 241, 3, 2, 2, 2, 1281, 1282, 7, 43, 2, 2, 1282, 1283,
	5, 68, 35, 2, 1283, 1284, 5, 246, 124, 2, 1284, 243, 3, 2, 2, 2, 1285,
	1286, 7, 43, 2, 2, 1286, 1287, 5, 68, 35, 2, 1287, 1288, 5, 246, 124, 2,
	1288, 245, 3, 2, 2, 2, 1289, 1291, 5, 248, 125, 2, 1290, 1292, 5, 246,
	124, 2, 1291, 1290, 3, 2, 2, 2, 1291, 1292, 3, 2, 2, 2, 1292, 247, 3, 2,
	2, 2, 1293, 1294, 7, 9, 2, 2, 1294, 1295, 7, 53, 2, 2, 1295, 1296, 5, 250,
	126, 2, 1296, 1297, 7, 54, 2, 2, 1297, 1298, 5, 68, 35, 2, 1298, 249, 3,
	2, 2, 2, 1299, 1300, 5, 106, 54, 2, 1300, 1301, 5, 152, 77, 2, 1301, 1305,
	3, 2, 2, 2, 1302, 1305, 5, 106, 54, 2, 1303, 1305, 7, 97, 2, 2, 1304, 1299,
	3, 2, 2, 2, 1304, 1302, 3, 2, 2, 2, 1304, 1303, 3, 2, 2, 2, 1305, 251,
	3, 2, 2, 2, 1306, 1308, 7, 41, 2, 2, 1307, 1309, 5, 54, 28, 2, 1308, 1307,
	3, 2, 2, 2, 1308, 1309, 3, 2, 2, 2, 1309, 253, 3, 2, 2, 2, 1310, 1311,
	7, 41, 2, 2, 1311, 1313, 7, 53, 2, 2, 1312, 1314, 5, 256, 129, 2, 1313,
	1312, 3, 2, 2, 2, 1313, 1314, 3, 2, 2, 2, 1314, 1315, 3, 2, 2, 2, 1315,
	1316, 7, 54, 2, 2, 1316, 255, 3, 2, 2, 2, 1317, 1318, 8, 129, 1, 2, 1318,
	1320, 5, 168, 85, 2, 1319, 1321, 7, 97, 2, 2, 1320, 1319, 3, 2, 2, 2, 1320,
	1321, 3, 2, 2, 2, 1321, 1330, 3, 2, 2, 2, 1322, 1323, 12, 3, 2, 2, 1323,
	1324, 7, 91, 2, 2, 1324, 1326, 5, 168, 85, 2, 1325, 1327, 7, 97, 2, 2,
	1326, 1325, 3, 2, 2, 2, 1326, 1327, 3, 2, 2, 2, 1327, 1329, 3, 2, 2, 2,
	1328, 1322, 3, 2, 2, 2, 1329, 1332, 3, 2, 2, 2, 1330, 1328, 3, 2, 2, 2,
	1330, 1331, 3, 2, 2, 2, 1331, 257, 3, 2, 2, 2, 1332, 1330, 3, 2, 2, 2,
	1333, 1373, 7, 30, 2, 2, 1334, 1373, 7, 59, 2, 2, 1335, 1373, 7, 60, 2,
	2, 1336, 1373, 7, 61, 2, 2, 1337, 1373, 7, 62, 2, 2, 1338, 1373, 7, 63,
	2, 2, 1339, 1373, 7, 64, 2, 2, 1340, 1373, 7, 65, 2, 2, 1341, 1373, 7,
	66, 2, 2, 1342, 1373, 7, 67, 2, 2, 1343, 1373, 7, 68, 2, 2, 1344, 1373,
	7, 69, 2, 2, 1345, 1373, 7, 70, 2, 2, 1346, 1373, 7, 71, 2, 2, 1347, 1373,
	7, 72, 2, 2, 1348, 1373, 7, 73, 2, 2, 1349, 1373, 7, 74, 2, 2, 1350, 1373,
	7, 75, 2, 2, 1351, 1373, 7, 76, 2, 2, 1352, 1373, 7, 77, 2, 2, 1353, 1373,
	7, 78, 2, 2, 1354, 1373, 7, 79, 2, 2, 1355, 1373, 7, 80, 2, 2, 1356, 1373,
	7, 82, 2, 2, 1357, 1373, 7, 81, 2, 2, 1358, 1373, 7, 83, 2, 2, 1359, 1373,
	7, 84, 2, 2, 1360, 1373, 7, 85, 2, 2, 1361, 1373, 7, 86, 2, 2, 1362, 1373,
	7, 87, 2, 2, 1363, 1373, 7, 88, 2, 2, 1364, 1373, 7, 89, 2, 2, 1365, 1373,
	7, 90, 2, 2, 1366, 1373, 7, 91, 2, 2, 1367, 1373, 7, 92, 2, 2, 1368, 1369,
	7, 53, 2, 2, 1369, 1373, 7, 54, 2, 2, 1370, 1371, 7, 55, 2, 2, 1371, 1373,
	7, 56, 2, 2, 1372, 1333, 3, 2, 2, 2, 1372, 1334, 3, 2, 2, 2, 1372, 1335,
	3, 2, 2, 2, 1372, 1336, 3, 2, 2, 2, 1372, 1337, 3, 2, 2, 2, 1372, 1338,
	3, 2, 2, 2, 1372, 1339, 3, 2, 2, 2, 1372, 1340, 3, 2, 2, 2, 1372, 1341,
	3, 2, 2, 2, 1372, 1342, 3, 2, 2, 2, 1372, 1343, 3, 2, 2, 2, 1372, 1344,
	3, 2, 2, 2, 1372, 1345, 3, 2, 2, 2, 1372, 1346, 3, 2, 2, 2, 1372, 1347,
	3, 2, 2, 2, 1372, 1348, 3, 2, 2, 2, 1372, 1349, 3, 2, 2, 2, 1372, 1350,
	3, 2, 2, 2, 1372, 1351, 3, 2, 2, 2, 1372, 1352, 3, 2, 2, 2, 1372, 1353,
	3, 2, 2, 2, 1372, 1354, 3, 2, 2, 2, 1372, 1355, 3, 2, 2, 2, 1372, 1356,
	3, 2, 2, 2, 1372, 1357, 3, 2, 2, 2, 1372, 1358, 3, 2, 2, 2, 1372, 1359,
	3, 2, 2, 2, 1372, 1360, 3, 2, 2, 2, 1372, 1361, 3, 2, 2, 2, 1372, 1362,
	3, 2, 2, 2, 1372, 1363, 3, 2, 2, 2, 1372, 1364, 3, 2, 2, 2, 1372, 1365,
	3, 2, 2, 2, 1372, 1366, 3, 2, 2, 2, 1372, 1367, 3, 2, 2, 2, 1372, 1368,
	3, 2, 2, 2, 1372, 1370, 3, 2, 2, 2, 1373, 259, 3, 2, 2, 2, 1374, 1375,
	9, 7, 2, 2, 1375, 261, 3, 2, 2, 2, 150, 263, 275, 279, 284, 296, 305, 307,
	311, 319, 326, 333, 351, 366, 376, 378, 392, 402, 406, 420, 422, 434, 436,
	448, 468, 470, 482, 484, 495, 506, 517, 528, 539, 549, 557, 569, 582, 595,
	598, 604, 615, 638, 650, 656, 660, 673, 677, 684, 692, 699, 710, 717, 721,
	724, 727, 739, 744, 748, 754, 760, 763, 790, 795, 802, 812, 816, 819, 834,
	842, 850, 854, 874, 877, 883, 896, 901, 908, 914, 922, 929, 932, 934, 941,
	944, 954, 961, 964, 970, 980, 996, 999, 1009, 1016, 1021, 1025, 1030, 1036,
	1040, 1046, 1052, 1056, 1061, 1068, 1072, 1074, 1077, 1083, 1088, 1090,
	1093, 1096, 1101, 1111, 1117, 1120, 1124, 1137, 1144, 1147, 1157, 1161,
	1166, 1171, 1178, 1182, 1195, 1200, 1204, 1207, 1211, 1216, 1219, 1222,
	1231, 1234, 1241, 1246, 1251, 1265, 1271, 1279, 1291, 1304, 1308, 1313,
	1320, 1326, 1330, 1372,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'auto'", "'bool'", "'break'", "'byte'", "'case'", "'cast'", "'catch'",
	"'class'", "'const'", "'continue'", "'default'", "'double'", "'else'",
	"'enum'", "'f32'", "'f64'", "'false'", "'float'", "'for'", "'if'", "'int'",
	"'i8'", "'i16'", "'i32'", "'i64'", "'long'", "'namespace'", "'new'", "'null'",
	"'operator'", "'private'", "'protected'", "'public'", "'return'", "'static'",
	"'short'", "'switch'", "'this'", "'throw'", "'true'", "'try'", "'uint'",
	"'u8'", "'u16'", "'u32'", "'u64'", "'ulong'", "'ushort'", "'using'", "'void'",
	"'('", "')'", "'['", "']'", "'{'", "'}'", "'+'", "'-'", "'*'", "'/'", "'%'",
	"'^'", "'&'", "'|'", "'~'", "'!'", "'='", "'<'", "'>'", "'+='", "'-='",
	"'/='", "'%='", "'^='", "'&='", "'|='", "'<<'", "'>>'", "'<<='", "'>>='",
	"'=='", "'!='", "'<='", "'>='", "'&&'", "'||'", "'++'", "'--'", "','",
	"'->'", "'?'", "':'", "';'", "'.'", "'...'",
}
var symbolicNames = []string{
	"", "Auto", "Bool", "Break", "Byte", "Case", "Cast", "Catch", "Class",
	"Const", "Continue", "Default", "Double", "Else", "Enum", "Float32", "Float64",
	"False", "Float", "For", "If", "Int", "Int8", "Int16", "Int32", "Int64",
	"Long", "Namespace", "New", "Null", "Operator", "Private", "Protected",
	"Public", "Return", "Static", "Short", "Switch", "This", "Throw", "True",
	"Try", "Uint", "Uint8", "Uint16", "Uint32", "Uint64", "Ulong", "Ushort",
	"Using", "Void", "LeftParen", "RightParen", "LeftBracket", "RightBracket",
	"LeftBrace", "RightBrace", "Plus", "Minus", "Star", "Div", "Mod", "Caret",
	"And", "Or", "Tilde", "Not", "Assign", "Less", "Greater", "PlusAssign",
	"MinusAssign", "DivAssign", "ModAssign", "XorAssign", "AndAssign", "OrAssign",
	"LeftShift", "RightShift", "LeftShiftAssign", "RightShiftAssign", "Equal",
	"NotEqual", "LessEqual", "GreaterEqual", "AndAnd", "OrOr", "PlusPlus",
	"MinusMinus", "Comma", "Arrow", "Question", "Colon", "Semi", "Dot", "Ellipsis",
	"Identifier", "IntegerLiteral", "DecimalLiteral", "OctalLiteral", "HexadecimalLiteral",
	"BinaryLiteral", "FloatLiteral", "StringLiteral", "BooleanLiteral", "PointerLiteral",
	"Whitespace", "Newline", "BlockComment", "LineComment",
}

var ruleNames = []string{
	"translation_unit", "primary_expression", "id_expression", "unqualified_id",
	"qualified_id", "nested_name_specifier", "lambda_expression", "lambda_declarator",
	"post_fix_expression", "expression_list", "unary_expression", "unary_operator",
	"new_expression", "new_initializer", "multiplicative_expression", "additive_expression",
	"shift_expression", "shiftoperator", "relational_expression", "equality_expression",
	"and_expression", "exclusiveor_expression", "inclusiveor_expression", "logical_and_expression",
	"logical_or_expression", "conditional_expression", "assignment_expression",
	"assignment_operator", "expression", "constant_expression", "statement",
	"labeled_statement", "expression_statement", "compound_statement", "statement_sequence",
	"selection_statement", "condition", "iteration_statement", "for_init_statement",
	"for_range_declaration", "for_range_initializer", "jump_statement", "declaration_statement",
	"declaration_sequence", "declaration", "block_declaration", "simple_declaration",
	"empty_declaration", "decl_specifier", "decl_specifier_sequence", "type_specifier",
	"trailing_type_specifier", "type_specifier_sequence", "trailing_type_specifier_sequence",
	"simple_type_specifier", "type_name", "enum_name", "enum_specifier", "enum_head",
	"enum_key", "enum_base", "enumerator_list", "enumerator_definition", "enumerator",
	"namespace_name", "namespace_definition", "named_namespace_definition",
	"original_namespace_definition", "extension_namespace_definition", "unnamed_namespace_definition",
	"namespace_body", "qualified_namespace_specifier", "using_namespace", "init_declarator_list",
	"init_declarator", "declarator", "ptr_declarator", "noptr_declarator",
	"parameters_and_qualifiers", "trailing_return_type", "ref_operator", "ref_qualifier",
	"declarator_id", "type_id", "parameter_declaration_clause", "parameter_declaration_list",
	"parameter_declaration", "function_definition", "function_body", "initializer",
	"brace_or_equal_initializer", "initializer_clause", "initializer_list",
	"braced_init_list", "class_name", "class_specifier", "class_head", "class_head_name",
	"member_specification", "member_declaration", "member_declarator_list",
	"memberdeclarator", "base_clause", "base_specifier_list", "base_specifier",
	"class_or_decltype", "base_type_specifier", "access_specifier", "mem_initializer_list",
	"mem_initializer", "mem_initializer_id", "operator_function_id", "template_parameter_list",
	"template_parameter", "type_parameter", "template_id", "template_name",
	"template_argument_list", "template_argument", "type_name_specifier", "try_block",
	"function_try_block", "handler_sequence", "handler", "exception_declaration",
	"throw_expression", "exception_specification", "type_id_list", "operators",
	"literal",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type PandaParser struct {
	*antlr.BaseParser
}

func NewPandaParser(input antlr.TokenStream) *PandaParser {
	this := new(PandaParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "PandaParser.g4"

	return this
}

// PandaParser tokens.
const (
	PandaParserEOF                = antlr.TokenEOF
	PandaParserAuto               = 1
	PandaParserBool               = 2
	PandaParserBreak              = 3
	PandaParserByte               = 4
	PandaParserCase               = 5
	PandaParserCast               = 6
	PandaParserCatch              = 7
	PandaParserClass              = 8
	PandaParserConst              = 9
	PandaParserContinue           = 10
	PandaParserDefault            = 11
	PandaParserDouble             = 12
	PandaParserElse               = 13
	PandaParserEnum               = 14
	PandaParserFloat32            = 15
	PandaParserFloat64            = 16
	PandaParserFalse              = 17
	PandaParserFloat              = 18
	PandaParserFor                = 19
	PandaParserIf                 = 20
	PandaParserInt                = 21
	PandaParserInt8               = 22
	PandaParserInt16              = 23
	PandaParserInt32              = 24
	PandaParserInt64              = 25
	PandaParserLong               = 26
	PandaParserNamespace          = 27
	PandaParserNew                = 28
	PandaParserNull               = 29
	PandaParserOperator           = 30
	PandaParserPrivate            = 31
	PandaParserProtected          = 32
	PandaParserPublic             = 33
	PandaParserReturn             = 34
	PandaParserStatic             = 35
	PandaParserShort              = 36
	PandaParserSwitch             = 37
	PandaParserThis               = 38
	PandaParserThrow              = 39
	PandaParserTrue               = 40
	PandaParserTry                = 41
	PandaParserUint               = 42
	PandaParserUint8              = 43
	PandaParserUint16             = 44
	PandaParserUint32             = 45
	PandaParserUint64             = 46
	PandaParserUlong              = 47
	PandaParserUshort             = 48
	PandaParserUsing              = 49
	PandaParserVoid               = 50
	PandaParserLeftParen          = 51
	PandaParserRightParen         = 52
	PandaParserLeftBracket        = 53
	PandaParserRightBracket       = 54
	PandaParserLeftBrace          = 55
	PandaParserRightBrace         = 56
	PandaParserPlus               = 57
	PandaParserMinus              = 58
	PandaParserStar               = 59
	PandaParserDiv                = 60
	PandaParserMod                = 61
	PandaParserCaret              = 62
	PandaParserAnd                = 63
	PandaParserOr                 = 64
	PandaParserTilde              = 65
	PandaParserNot                = 66
	PandaParserAssign             = 67
	PandaParserLess               = 68
	PandaParserGreater            = 69
	PandaParserPlusAssign         = 70
	PandaParserMinusAssign        = 71
	PandaParserDivAssign          = 72
	PandaParserModAssign          = 73
	PandaParserXorAssign          = 74
	PandaParserAndAssign          = 75
	PandaParserOrAssign           = 76
	PandaParserLeftShift          = 77
	PandaParserRightShift         = 78
	PandaParserLeftShiftAssign    = 79
	PandaParserRightShiftAssign   = 80
	PandaParserEqual              = 81
	PandaParserNotEqual           = 82
	PandaParserLessEqual          = 83
	PandaParserGreaterEqual       = 84
	PandaParserAndAnd             = 85
	PandaParserOrOr               = 86
	PandaParserPlusPlus           = 87
	PandaParserMinusMinus         = 88
	PandaParserComma              = 89
	PandaParserArrow              = 90
	PandaParserQuestion           = 91
	PandaParserColon              = 92
	PandaParserSemi               = 93
	PandaParserDot                = 94
	PandaParserEllipsis           = 95
	PandaParserIdentifier         = 96
	PandaParserIntegerLiteral     = 97
	PandaParserDecimalLiteral     = 98
	PandaParserOctalLiteral       = 99
	PandaParserHexadecimalLiteral = 100
	PandaParserBinaryLiteral      = 101
	PandaParserFloatLiteral       = 102
	PandaParserStringLiteral      = 103
	PandaParserBooleanLiteral     = 104
	PandaParserPointerLiteral     = 105
	PandaParserWhitespace         = 106
	PandaParserNewline            = 107
	PandaParserBlockComment       = 108
	PandaParserLineComment        = 109
)

// PandaParser rules.
const (
	PandaParserRULE_translation_unit                 = 0
	PandaParserRULE_primary_expression               = 1
	PandaParserRULE_id_expression                    = 2
	PandaParserRULE_unqualified_id                   = 3
	PandaParserRULE_qualified_id                     = 4
	PandaParserRULE_nested_name_specifier            = 5
	PandaParserRULE_lambda_expression                = 6
	PandaParserRULE_lambda_declarator                = 7
	PandaParserRULE_post_fix_expression              = 8
	PandaParserRULE_expression_list                  = 9
	PandaParserRULE_unary_expression                 = 10
	PandaParserRULE_unary_operator                   = 11
	PandaParserRULE_new_expression                   = 12
	PandaParserRULE_new_initializer                  = 13
	PandaParserRULE_multiplicative_expression        = 14
	PandaParserRULE_additive_expression              = 15
	PandaParserRULE_shift_expression                 = 16
	PandaParserRULE_shiftoperator                    = 17
	PandaParserRULE_relational_expression            = 18
	PandaParserRULE_equality_expression              = 19
	PandaParserRULE_and_expression                   = 20
	PandaParserRULE_exclusiveor_expression           = 21
	PandaParserRULE_inclusiveor_expression           = 22
	PandaParserRULE_logical_and_expression           = 23
	PandaParserRULE_logical_or_expression            = 24
	PandaParserRULE_conditional_expression           = 25
	PandaParserRULE_assignment_expression            = 26
	PandaParserRULE_assignment_operator              = 27
	PandaParserRULE_expression                       = 28
	PandaParserRULE_constant_expression              = 29
	PandaParserRULE_statement                        = 30
	PandaParserRULE_labeled_statement                = 31
	PandaParserRULE_expression_statement             = 32
	PandaParserRULE_compound_statement               = 33
	PandaParserRULE_statement_sequence               = 34
	PandaParserRULE_selection_statement              = 35
	PandaParserRULE_condition                        = 36
	PandaParserRULE_iteration_statement              = 37
	PandaParserRULE_for_init_statement               = 38
	PandaParserRULE_for_range_declaration            = 39
	PandaParserRULE_for_range_initializer            = 40
	PandaParserRULE_jump_statement                   = 41
	PandaParserRULE_declaration_statement            = 42
	PandaParserRULE_declaration_sequence             = 43
	PandaParserRULE_declaration                      = 44
	PandaParserRULE_block_declaration                = 45
	PandaParserRULE_simple_declaration               = 46
	PandaParserRULE_empty_declaration                = 47
	PandaParserRULE_decl_specifier                   = 48
	PandaParserRULE_decl_specifier_sequence          = 49
	PandaParserRULE_type_specifier                   = 50
	PandaParserRULE_trailing_type_specifier          = 51
	PandaParserRULE_type_specifier_sequence          = 52
	PandaParserRULE_trailing_type_specifier_sequence = 53
	PandaParserRULE_simple_type_specifier            = 54
	PandaParserRULE_type_name                        = 55
	PandaParserRULE_enum_name                        = 56
	PandaParserRULE_enum_specifier                   = 57
	PandaParserRULE_enum_head                        = 58
	PandaParserRULE_enum_key                         = 59
	PandaParserRULE_enum_base                        = 60
	PandaParserRULE_enumerator_list                  = 61
	PandaParserRULE_enumerator_definition            = 62
	PandaParserRULE_enumerator                       = 63
	PandaParserRULE_namespace_name                   = 64
	PandaParserRULE_namespace_definition             = 65
	PandaParserRULE_named_namespace_definition       = 66
	PandaParserRULE_original_namespace_definition    = 67
	PandaParserRULE_extension_namespace_definition   = 68
	PandaParserRULE_unnamed_namespace_definition     = 69
	PandaParserRULE_namespace_body                   = 70
	PandaParserRULE_qualified_namespace_specifier    = 71
	PandaParserRULE_using_namespace                  = 72
	PandaParserRULE_init_declarator_list             = 73
	PandaParserRULE_init_declarator                  = 74
	PandaParserRULE_declarator                       = 75
	PandaParserRULE_ptr_declarator                   = 76
	PandaParserRULE_noptr_declarator                 = 77
	PandaParserRULE_parameters_and_qualifiers        = 78
	PandaParserRULE_trailing_return_type             = 79
	PandaParserRULE_ref_operator                     = 80
	PandaParserRULE_ref_qualifier                    = 81
	PandaParserRULE_declarator_id                    = 82
	PandaParserRULE_type_id                          = 83
	PandaParserRULE_parameter_declaration_clause     = 84
	PandaParserRULE_parameter_declaration_list       = 85
	PandaParserRULE_parameter_declaration            = 86
	PandaParserRULE_function_definition              = 87
	PandaParserRULE_function_body                    = 88
	PandaParserRULE_initializer                      = 89
	PandaParserRULE_brace_or_equal_initializer       = 90
	PandaParserRULE_initializer_clause               = 91
	PandaParserRULE_initializer_list                 = 92
	PandaParserRULE_braced_init_list                 = 93
	PandaParserRULE_class_name                       = 94
	PandaParserRULE_class_specifier                  = 95
	PandaParserRULE_class_head                       = 96
	PandaParserRULE_class_head_name                  = 97
	PandaParserRULE_member_specification             = 98
	PandaParserRULE_member_declaration               = 99
	PandaParserRULE_member_declarator_list           = 100
	PandaParserRULE_memberdeclarator                 = 101
	PandaParserRULE_base_clause                      = 102
	PandaParserRULE_base_specifier_list              = 103
	PandaParserRULE_base_specifier                   = 104
	PandaParserRULE_class_or_decltype                = 105
	PandaParserRULE_base_type_specifier              = 106
	PandaParserRULE_access_specifier                 = 107
	PandaParserRULE_mem_initializer_list             = 108
	PandaParserRULE_mem_initializer                  = 109
	PandaParserRULE_mem_initializer_id               = 110
	PandaParserRULE_operator_function_id             = 111
	PandaParserRULE_template_parameter_list          = 112
	PandaParserRULE_template_parameter               = 113
	PandaParserRULE_type_parameter                   = 114
	PandaParserRULE_template_id                      = 115
	PandaParserRULE_template_name                    = 116
	PandaParserRULE_template_argument_list           = 117
	PandaParserRULE_template_argument                = 118
	PandaParserRULE_type_name_specifier              = 119
	PandaParserRULE_try_block                        = 120
	PandaParserRULE_function_try_block               = 121
	PandaParserRULE_handler_sequence                 = 122
	PandaParserRULE_handler                          = 123
	PandaParserRULE_exception_declaration            = 124
	PandaParserRULE_throw_expression                 = 125
	PandaParserRULE_exception_specification          = 126
	PandaParserRULE_type_id_list                     = 127
	PandaParserRULE_operators                        = 128
	PandaParserRULE_literal                          = 129
)

// ITranslation_unitContext is an interface to support dynamic dispatch.
type ITranslation_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTranslation_unitContext differentiates from other interfaces.
	IsTranslation_unitContext()
}

type Translation_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslation_unitContext() *Translation_unitContext {
	var p = new(Translation_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_translation_unit
	return p
}

func (*Translation_unitContext) IsTranslation_unitContext() {}

func NewTranslation_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Translation_unitContext {
	var p = new(Translation_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_translation_unit

	return p
}

func (s *Translation_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Translation_unitContext) EOF() antlr.TerminalNode {
	return s.GetToken(PandaParserEOF, 0)
}

func (s *Translation_unitContext) Declaration_sequence() IDeclaration_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_sequenceContext)
}

func (s *Translation_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Translation_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Translation_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTranslation_unit(s)
	}
}

func (s *Translation_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTranslation_unit(s)
	}
}

func (p *PandaParser) Translation_unit() (localctx ITranslation_unitContext) {
	localctx = NewTranslation_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PandaParserRULE_translation_unit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(261)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserClass)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNamespace)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserUsing-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserAnd-36)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(PandaParserSemi-93))|(1<<(PandaParserEllipsis-93))|(1<<(PandaParserIdentifier-93)))) != 0) {
		{
			p.SetState(260)
			p.declaration_sequence(0)
		}

	}
	{
		p.SetState(263)
		p.Match(PandaParserEOF)
	}

	return localctx
}

// IPrimary_expressionContext is an interface to support dynamic dispatch.
type IPrimary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_expressionContext differentiates from other interfaces.
	IsPrimary_expressionContext()
}

type Primary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_expressionContext() *Primary_expressionContext {
	var p = new(Primary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_primary_expression
	return p
}

func (*Primary_expressionContext) IsPrimary_expressionContext() {}

func NewPrimary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_expressionContext {
	var p = new(Primary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_primary_expression

	return p
}

func (s *Primary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_expressionContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Primary_expressionContext) This() antlr.TerminalNode {
	return s.GetToken(PandaParserThis, 0)
}

func (s *Primary_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Primary_expressionContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Primary_expressionContext) Lambda_expression() ILambda_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambda_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambda_expressionContext)
}

func (s *Primary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterPrimary_expression(s)
	}
}

func (s *Primary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitPrimary_expression(s)
	}
}

func (p *PandaParser) Primary_expression() (localctx IPrimary_expressionContext) {
	localctx = NewPrimary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PandaParserRULE_primary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(265)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(266)
			p.Match(PandaParserThis)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(267)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(268)
			p.expression(0)
		}
		{
			p.SetState(269)
			p.Match(PandaParserRightParen)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(271)
			p.Id_expression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(272)
			p.Lambda_expression()
		}

	}

	return localctx
}

// IId_expressionContext is an interface to support dynamic dispatch.
type IId_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsId_expressionContext differentiates from other interfaces.
	IsId_expressionContext()
}

type Id_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_expressionContext() *Id_expressionContext {
	var p = new(Id_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_id_expression
	return p
}

func (*Id_expressionContext) IsId_expressionContext() {}

func NewId_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_expressionContext {
	var p = new(Id_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_id_expression

	return p
}

func (s *Id_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_expressionContext) Unqualified_id() IUnqualified_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnqualified_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnqualified_idContext)
}

func (s *Id_expressionContext) Qualified_id() IQualified_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualified_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualified_idContext)
}

func (s *Id_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterId_expression(s)
	}
}

func (s *Id_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitId_expression(s)
	}
}

func (p *PandaParser) Id_expression() (localctx IId_expressionContext) {
	localctx = NewId_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PandaParserRULE_id_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(275)
			p.Unqualified_id()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(276)
			p.Qualified_id()
		}

	}

	return localctx
}

// IUnqualified_idContext is an interface to support dynamic dispatch.
type IUnqualified_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnqualified_idContext differentiates from other interfaces.
	IsUnqualified_idContext()
}

type Unqualified_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnqualified_idContext() *Unqualified_idContext {
	var p = new(Unqualified_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_unqualified_id
	return p
}

func (*Unqualified_idContext) IsUnqualified_idContext() {}

func NewUnqualified_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unqualified_idContext {
	var p = new(Unqualified_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_unqualified_id

	return p
}

func (s *Unqualified_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Unqualified_idContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Unqualified_idContext) Operator_function_id() IOperator_function_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_function_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperator_function_idContext)
}

func (s *Unqualified_idContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Unqualified_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unqualified_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unqualified_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterUnqualified_id(s)
	}
}

func (s *Unqualified_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitUnqualified_id(s)
	}
}

func (p *PandaParser) Unqualified_id() (localctx IUnqualified_idContext) {
	localctx = NewUnqualified_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PandaParserRULE_unqualified_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(282)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(279)
			p.Match(PandaParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(280)
			p.Operator_function_id()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(281)
			p.Template_id()
		}

	}

	return localctx
}

// IQualified_idContext is an interface to support dynamic dispatch.
type IQualified_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualified_idContext differentiates from other interfaces.
	IsQualified_idContext()
}

type Qualified_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualified_idContext() *Qualified_idContext {
	var p = new(Qualified_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_qualified_id
	return p
}

func (*Qualified_idContext) IsQualified_idContext() {}

func NewQualified_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualified_idContext {
	var p = new(Qualified_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_qualified_id

	return p
}

func (s *Qualified_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualified_idContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Qualified_idContext) Unqualified_id() IUnqualified_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnqualified_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnqualified_idContext)
}

func (s *Qualified_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualified_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qualified_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterQualified_id(s)
	}
}

func (s *Qualified_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitQualified_id(s)
	}
}

func (p *PandaParser) Qualified_id() (localctx IQualified_idContext) {
	localctx = NewQualified_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PandaParserRULE_qualified_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(284)
		p.nested_name_specifier(0)
	}
	{
		p.SetState(285)
		p.Unqualified_id()
	}

	return localctx
}

// INested_name_specifierContext is an interface to support dynamic dispatch.
type INested_name_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNested_name_specifierContext differentiates from other interfaces.
	IsNested_name_specifierContext()
}

type Nested_name_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNested_name_specifierContext() *Nested_name_specifierContext {
	var p = new(Nested_name_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_nested_name_specifier
	return p
}

func (*Nested_name_specifierContext) IsNested_name_specifierContext() {}

func NewNested_name_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nested_name_specifierContext {
	var p = new(Nested_name_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_nested_name_specifier

	return p
}

func (s *Nested_name_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Nested_name_specifierContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Nested_name_specifierContext) Namespace_name() INamespace_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Nested_name_specifierContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Nested_name_specifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Nested_name_specifierContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Nested_name_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nested_name_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nested_name_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNested_name_specifier(s)
	}
}

func (s *Nested_name_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNested_name_specifier(s)
	}
}

func (p *PandaParser) Nested_name_specifier() (localctx INested_name_specifierContext) {
	return p.nested_name_specifier(0)
}

func (p *PandaParser) nested_name_specifier(_p int) (localctx INested_name_specifierContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewNested_name_specifierContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INested_name_specifierContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 10
	p.EnterRecursionRule(localctx, 10, PandaParserRULE_nested_name_specifier, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(294)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(288)
			p.Type_name()
		}
		{
			p.SetState(289)
			p.Match(PandaParserDot)
		}

	case 2:
		{
			p.SetState(291)
			p.Namespace_name()
		}
		{
			p.SetState(292)
			p.Match(PandaParserDot)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(305)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(303)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
			case 1:
				localctx = NewNested_name_specifierContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_nested_name_specifier)
				p.SetState(296)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(297)
					p.Match(PandaParserIdentifier)
				}
				{
					p.SetState(298)
					p.Match(PandaParserDot)
				}

			case 2:
				localctx = NewNested_name_specifierContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_nested_name_specifier)
				p.SetState(299)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(300)
					p.Template_id()
				}
				{
					p.SetState(301)
					p.Match(PandaParserDot)
				}

			}

		}
		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}

	return localctx
}

// ILambda_expressionContext is an interface to support dynamic dispatch.
type ILambda_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambda_expressionContext differentiates from other interfaces.
	IsLambda_expressionContext()
}

type Lambda_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambda_expressionContext() *Lambda_expressionContext {
	var p = new(Lambda_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_lambda_expression
	return p
}

func (*Lambda_expressionContext) IsLambda_expressionContext() {}

func NewLambda_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambda_expressionContext {
	var p = new(Lambda_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_lambda_expression

	return p
}

func (s *Lambda_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambda_expressionContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Lambda_expressionContext) Lambda_declarator() ILambda_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambda_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambda_declaratorContext)
}

func (s *Lambda_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambda_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lambda_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLambda_expression(s)
	}
}

func (s *Lambda_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLambda_expression(s)
	}
}

func (p *PandaParser) Lambda_expression() (localctx ILambda_expressionContext) {
	localctx = NewLambda_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PandaParserRULE_lambda_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserLeftParen {
		{
			p.SetState(308)
			p.Lambda_declarator()
		}

	}
	{
		p.SetState(311)
		p.Compound_statement()
	}

	return localctx
}

// ILambda_declaratorContext is an interface to support dynamic dispatch.
type ILambda_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambda_declaratorContext differentiates from other interfaces.
	IsLambda_declaratorContext()
}

type Lambda_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambda_declaratorContext() *Lambda_declaratorContext {
	var p = new(Lambda_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_lambda_declarator
	return p
}

func (*Lambda_declaratorContext) IsLambda_declaratorContext() {}

func NewLambda_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lambda_declaratorContext {
	var p = new(Lambda_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_lambda_declarator

	return p
}

func (s *Lambda_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Lambda_declaratorContext) Parameter_declaration_clause() IParameter_declaration_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_clauseContext)
}

func (s *Lambda_declaratorContext) Trailing_return_type() ITrailing_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailing_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrailing_return_typeContext)
}

func (s *Lambda_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lambda_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lambda_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLambda_declarator(s)
	}
}

func (s *Lambda_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLambda_declarator(s)
	}
}

func (p *PandaParser) Lambda_declarator() (localctx ILambda_declaratorContext) {
	localctx = NewLambda_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PandaParserRULE_lambda_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(313)
		p.Match(PandaParserLeftParen)
	}
	{
		p.SetState(314)
		p.Parameter_declaration_clause()
	}
	{
		p.SetState(315)
		p.Match(PandaParserRightParen)
	}
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserArrow {
		{
			p.SetState(316)
			p.Trailing_return_type()
		}

	}

	return localctx
}

// IPost_fix_expressionContext is an interface to support dynamic dispatch.
type IPost_fix_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPost_fix_expressionContext differentiates from other interfaces.
	IsPost_fix_expressionContext()
}

type Post_fix_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPost_fix_expressionContext() *Post_fix_expressionContext {
	var p = new(Post_fix_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_post_fix_expression
	return p
}

func (*Post_fix_expressionContext) IsPost_fix_expressionContext() {}

func NewPost_fix_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Post_fix_expressionContext {
	var p = new(Post_fix_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_post_fix_expression

	return p
}

func (s *Post_fix_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Post_fix_expressionContext) Primary_expression() IPrimary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_expressionContext)
}

func (s *Post_fix_expressionContext) Simple_type_specifier() ISimple_type_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_type_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_type_specifierContext)
}

func (s *Post_fix_expressionContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Post_fix_expressionContext) Type_name_specifier() IType_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_name_specifierContext)
}

func (s *Post_fix_expressionContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *Post_fix_expressionContext) Cast() antlr.TerminalNode {
	return s.GetToken(PandaParserCast, 0)
}

func (s *Post_fix_expressionContext) Type_id() IType_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Post_fix_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Post_fix_expressionContext) Post_fix_expression() IPost_fix_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPost_fix_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPost_fix_expressionContext)
}

func (s *Post_fix_expressionContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Post_fix_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Post_fix_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Post_fix_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterPost_fix_expression(s)
	}
}

func (s *Post_fix_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitPost_fix_expression(s)
	}
}

func (p *PandaParser) Post_fix_expression() (localctx IPost_fix_expressionContext) {
	return p.post_fix_expression(0)
}

func (p *PandaParser) post_fix_expression(_p int) (localctx IPost_fix_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPost_fix_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPost_fix_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 16
	p.EnterRecursionRule(localctx, 16, PandaParserRULE_post_fix_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(320)
			p.Primary_expression()
		}

	case 2:
		{
			p.SetState(321)
			p.Simple_type_specifier()
		}
		{
			p.SetState(322)
			p.Match(PandaParserLeftParen)
		}
		p.SetState(324)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserThrow-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
			{
				p.SetState(323)
				p.Expression_list()
			}

		}
		{
			p.SetState(326)
			p.Match(PandaParserRightParen)
		}

	case 3:
		{
			p.SetState(328)
			p.Type_name_specifier()
		}
		{
			p.SetState(329)
			p.Match(PandaParserLeftParen)
		}
		p.SetState(331)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserThrow-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
			{
				p.SetState(330)
				p.Expression_list()
			}

		}
		{
			p.SetState(333)
			p.Match(PandaParserRightParen)
		}

	case 4:
		{
			p.SetState(335)
			p.Simple_type_specifier()
		}
		{
			p.SetState(336)
			p.Braced_init_list()
		}

	case 5:
		{
			p.SetState(338)
			p.Type_name_specifier()
		}
		{
			p.SetState(339)
			p.Braced_init_list()
		}

	case 6:
		{
			p.SetState(341)
			p.Match(PandaParserCast)
		}
		{
			p.SetState(342)
			p.Match(PandaParserLess)
		}
		{
			p.SetState(343)
			p.Type_id()
		}
		{
			p.SetState(344)
			p.Match(PandaParserGreater)
		}
		{
			p.SetState(345)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(346)
			p.expression(0)
		}
		{
			p.SetState(347)
			p.Match(PandaParserRightParen)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(374)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(351)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(352)
					p.Match(PandaParserLeftBracket)
				}
				{
					p.SetState(353)
					p.expression(0)
				}
				{
					p.SetState(354)
					p.Match(PandaParserRightBracket)
				}

			case 2:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(356)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(357)
					p.Match(PandaParserLeftBracket)
				}
				{
					p.SetState(358)
					p.Braced_init_list()
				}
				{
					p.SetState(359)
					p.Match(PandaParserRightBracket)
				}

			case 3:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(361)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(362)
					p.Match(PandaParserLeftParen)
				}
				p.SetState(364)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserThrow-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
					{
						p.SetState(363)
						p.Expression_list()
					}

				}
				{
					p.SetState(366)
					p.Match(PandaParserRightParen)
				}

			case 4:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(367)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(368)
					p.Match(PandaParserDot)
				}
				{
					p.SetState(369)
					p.Id_expression()
				}

			case 5:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(370)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(371)
					p.Match(PandaParserPlusPlus)
				}

			case 6:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(372)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(373)
					p.Match(PandaParserMinusMinus)
				}

			}

		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())
	}

	return localctx
}

// IExpression_listContext is an interface to support dynamic dispatch.
type IExpression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_listContext differentiates from other interfaces.
	IsExpression_listContext()
}

type Expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_listContext() *Expression_listContext {
	var p = new(Expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_expression_list
	return p
}

func (*Expression_listContext) IsExpression_listContext() {}

func NewExpression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_listContext {
	var p = new(Expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_expression_list

	return p
}

func (s *Expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_listContext) Initializer_list() IInitializer_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_listContext)
}

func (s *Expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterExpression_list(s)
	}
}

func (s *Expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitExpression_list(s)
	}
}

func (p *PandaParser) Expression_list() (localctx IExpression_listContext) {
	localctx = NewExpression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PandaParserRULE_expression_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		p.initializer_list(0)
	}

	return localctx
}

// IUnary_expressionContext is an interface to support dynamic dispatch.
type IUnary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_expressionContext differentiates from other interfaces.
	IsUnary_expressionContext()
}

type Unary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_expressionContext() *Unary_expressionContext {
	var p = new(Unary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_unary_expression
	return p
}

func (*Unary_expressionContext) IsUnary_expressionContext() {}

func NewUnary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_expressionContext {
	var p = new(Unary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_unary_expression

	return p
}

func (s *Unary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_expressionContext) Post_fix_expression() IPost_fix_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPost_fix_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPost_fix_expressionContext)
}

func (s *Unary_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Unary_expressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Unary_expressionContext) New_expression() INew_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INew_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INew_expressionContext)
}

func (s *Unary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterUnary_expression(s)
	}
}

func (s *Unary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitUnary_expression(s)
	}
}

func (p *PandaParser) Unary_expression() (localctx IUnary_expressionContext) {
	localctx = NewUnary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PandaParserRULE_unary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(390)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserAuto, PandaParserBool, PandaParserCast, PandaParserDouble, PandaParserFloat32, PandaParserFloat64, PandaParserFloat, PandaParserInt, PandaParserInt8, PandaParserInt16, PandaParserInt32, PandaParserInt64, PandaParserLong, PandaParserOperator, PandaParserShort, PandaParserThis, PandaParserUint, PandaParserUint8, PandaParserUint16, PandaParserUint32, PandaParserUint64, PandaParserUlong, PandaParserUshort, PandaParserVoid, PandaParserLeftParen, PandaParserLeftBrace, PandaParserIdentifier, PandaParserIntegerLiteral, PandaParserFloatLiteral, PandaParserStringLiteral, PandaParserBooleanLiteral, PandaParserPointerLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(381)
			p.post_fix_expression(0)
		}

	case PandaParserPlusPlus:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(382)
			p.Match(PandaParserPlusPlus)
		}
		{
			p.SetState(383)
			p.Unary_expression()
		}

	case PandaParserMinusMinus:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(384)
			p.Match(PandaParserMinusMinus)
		}
		{
			p.SetState(385)
			p.Unary_expression()
		}

	case PandaParserPlus, PandaParserMinus, PandaParserOr, PandaParserTilde, PandaParserNot:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(386)
			p.Unary_operator()
		}
		{
			p.SetState(387)
			p.Unary_expression()
		}

	case PandaParserNew:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(389)
			p.New_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (p *PandaParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PandaParserRULE_unary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-57)&-(0x1f+1)) == 0 && ((1<<uint((_la-57)))&((1<<(PandaParserPlus-57))|(1<<(PandaParserMinus-57))|(1<<(PandaParserOr-57))|(1<<(PandaParserTilde-57))|(1<<(PandaParserNot-57)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INew_expressionContext is an interface to support dynamic dispatch.
type INew_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNew_expressionContext differentiates from other interfaces.
	IsNew_expressionContext()
}

type New_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_expressionContext() *New_expressionContext {
	var p = new(New_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_new_expression
	return p
}

func (*New_expressionContext) IsNew_expressionContext() {}

func NewNew_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_expressionContext {
	var p = new(New_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_new_expression

	return p
}

func (s *New_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *New_expressionContext) New() antlr.TerminalNode {
	return s.GetToken(PandaParserNew, 0)
}

func (s *New_expressionContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *New_expressionContext) New_initializer() INew_initializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INew_initializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INew_initializerContext)
}

func (s *New_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNew_expression(s)
	}
}

func (s *New_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNew_expression(s)
	}
}

func (p *PandaParser) New_expression() (localctx INew_expressionContext) {
	localctx = NewNew_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PandaParserRULE_new_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		p.Match(PandaParserNew)
	}
	{
		p.SetState(395)
		p.Type_specifier_sequence()
	}
	{
		p.SetState(396)
		p.New_initializer()
	}

	return localctx
}

// INew_initializerContext is an interface to support dynamic dispatch.
type INew_initializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNew_initializerContext differentiates from other interfaces.
	IsNew_initializerContext()
}

type New_initializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_initializerContext() *New_initializerContext {
	var p = new(New_initializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_new_initializer
	return p
}

func (*New_initializerContext) IsNew_initializerContext() {}

func NewNew_initializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_initializerContext {
	var p = new(New_initializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_new_initializer

	return p
}

func (s *New_initializerContext) GetParser() antlr.Parser { return s.parser }

func (s *New_initializerContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *New_initializerContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *New_initializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_initializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_initializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNew_initializer(s)
	}
}

func (s *New_initializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNew_initializer(s)
	}
}

func (p *PandaParser) New_initializer() (localctx INew_initializerContext) {
	localctx = NewNew_initializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PandaParserRULE_new_initializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(404)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserLeftParen:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(398)
			p.Match(PandaParserLeftParen)
		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserThrow-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
			{
				p.SetState(399)
				p.Expression_list()
			}

		}
		{
			p.SetState(402)
			p.Match(PandaParserRightParen)
		}

	case PandaParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(403)
			p.Braced_init_list()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMultiplicative_expressionContext is an interface to support dynamic dispatch.
type IMultiplicative_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicative_expressionContext differentiates from other interfaces.
	IsMultiplicative_expressionContext()
}

type Multiplicative_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicative_expressionContext() *Multiplicative_expressionContext {
	var p = new(Multiplicative_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_multiplicative_expression
	return p
}

func (*Multiplicative_expressionContext) IsMultiplicative_expressionContext() {}

func NewMultiplicative_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiplicative_expressionContext {
	var p = new(Multiplicative_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_multiplicative_expression

	return p
}

func (s *Multiplicative_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiplicative_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Multiplicative_expressionContext) Multiplicative_expression() IMultiplicative_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicative_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplicative_expressionContext)
}

func (s *Multiplicative_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiplicative_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiplicative_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMultiplicative_expression(s)
	}
}

func (s *Multiplicative_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMultiplicative_expression(s)
	}
}

func (p *PandaParser) Multiplicative_expression() (localctx IMultiplicative_expressionContext) {
	return p.multiplicative_expression(0)
}

func (p *PandaParser) multiplicative_expression(_p int) (localctx IMultiplicative_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewMultiplicative_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicative_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 28
	p.EnterRecursionRule(localctx, 28, PandaParserRULE_multiplicative_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.Unary_expression()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(420)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(418)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
			case 1:
				localctx = NewMultiplicative_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_multiplicative_expression)
				p.SetState(409)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(410)
					p.Match(PandaParserStar)
				}
				{
					p.SetState(411)
					p.Unary_expression()
				}

			case 2:
				localctx = NewMultiplicative_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_multiplicative_expression)
				p.SetState(412)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(413)
					p.Match(PandaParserDiv)
				}
				{
					p.SetState(414)
					p.Unary_expression()
				}

			case 3:
				localctx = NewMultiplicative_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_multiplicative_expression)
				p.SetState(415)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(416)
					p.Match(PandaParserMod)
				}
				{
					p.SetState(417)
					p.Unary_expression()
				}

			}

		}
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}

	return localctx
}

// IAdditive_expressionContext is an interface to support dynamic dispatch.
type IAdditive_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditive_expressionContext differentiates from other interfaces.
	IsAdditive_expressionContext()
}

type Additive_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditive_expressionContext() *Additive_expressionContext {
	var p = new(Additive_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_additive_expression
	return p
}

func (*Additive_expressionContext) IsAdditive_expressionContext() {}

func NewAdditive_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Additive_expressionContext {
	var p = new(Additive_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_additive_expression

	return p
}

func (s *Additive_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Additive_expressionContext) Multiplicative_expression() IMultiplicative_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicative_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplicative_expressionContext)
}

func (s *Additive_expressionContext) Additive_expression() IAdditive_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditive_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditive_expressionContext)
}

func (s *Additive_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Additive_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Additive_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAdditive_expression(s)
	}
}

func (s *Additive_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAdditive_expression(s)
	}
}

func (p *PandaParser) Additive_expression() (localctx IAdditive_expressionContext) {
	return p.additive_expression(0)
}

func (p *PandaParser) additive_expression(_p int) (localctx IAdditive_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewAdditive_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditive_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 30
	p.EnterRecursionRule(localctx, 30, PandaParserRULE_additive_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.multiplicative_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(432)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
			case 1:
				localctx = NewAdditive_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_additive_expression)
				p.SetState(426)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(427)
					p.Match(PandaParserPlus)
				}
				{
					p.SetState(428)
					p.multiplicative_expression(0)
				}

			case 2:
				localctx = NewAdditive_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_additive_expression)
				p.SetState(429)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(430)
					p.Match(PandaParserMinus)
				}
				{
					p.SetState(431)
					p.multiplicative_expression(0)
				}

			}

		}
		p.SetState(436)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// IShift_expressionContext is an interface to support dynamic dispatch.
type IShift_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_expressionContext differentiates from other interfaces.
	IsShift_expressionContext()
}

type Shift_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_expressionContext() *Shift_expressionContext {
	var p = new(Shift_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_shift_expression
	return p
}

func (*Shift_expressionContext) IsShift_expressionContext() {}

func NewShift_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_expressionContext {
	var p = new(Shift_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_shift_expression

	return p
}

func (s *Shift_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_expressionContext) Additive_expression() IAdditive_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditive_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditive_expressionContext)
}

func (s *Shift_expressionContext) Shift_expression() IShift_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_expressionContext)
}

func (s *Shift_expressionContext) Shiftoperator() IShiftoperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShiftoperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShiftoperatorContext)
}

func (s *Shift_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterShift_expression(s)
	}
}

func (s *Shift_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitShift_expression(s)
	}
}

func (p *PandaParser) Shift_expression() (localctx IShift_expressionContext) {
	return p.shift_expression(0)
}

func (p *PandaParser) shift_expression(_p int) (localctx IShift_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewShift_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IShift_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 32
	p.EnterRecursionRule(localctx, 32, PandaParserRULE_shift_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(438)
		p.additive_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewShift_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_shift_expression)
			p.SetState(440)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(441)
				p.Shiftoperator()
			}
			{
				p.SetState(442)
				p.additive_expression(0)
			}

		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}

	return localctx
}

// IShiftoperatorContext is an interface to support dynamic dispatch.
type IShiftoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShiftoperatorContext differentiates from other interfaces.
	IsShiftoperatorContext()
}

type ShiftoperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftoperatorContext() *ShiftoperatorContext {
	var p = new(ShiftoperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_shiftoperator
	return p
}

func (*ShiftoperatorContext) IsShiftoperatorContext() {}

func NewShiftoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftoperatorContext {
	var p = new(ShiftoperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_shiftoperator

	return p
}

func (s *ShiftoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftoperatorContext) RightShift() antlr.TerminalNode {
	return s.GetToken(PandaParserRightShift, 0)
}

func (s *ShiftoperatorContext) LeftShift() antlr.TerminalNode {
	return s.GetToken(PandaParserLeftShift, 0)
}

func (s *ShiftoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterShiftoperator(s)
	}
}

func (s *ShiftoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitShiftoperator(s)
	}
}

func (p *PandaParser) Shiftoperator() (localctx IShiftoperatorContext) {
	localctx = NewShiftoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PandaParserRULE_shiftoperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PandaParserLeftShift || _la == PandaParserRightShift) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRelational_expressionContext is an interface to support dynamic dispatch.
type IRelational_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelational_expressionContext differentiates from other interfaces.
	IsRelational_expressionContext()
}

type Relational_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelational_expressionContext() *Relational_expressionContext {
	var p = new(Relational_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_relational_expression
	return p
}

func (*Relational_expressionContext) IsRelational_expressionContext() {}

func NewRelational_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relational_expressionContext {
	var p = new(Relational_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_relational_expression

	return p
}

func (s *Relational_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Relational_expressionContext) Shift_expression() IShift_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_expressionContext)
}

func (s *Relational_expressionContext) Relational_expression() IRelational_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelational_expressionContext)
}

func (s *Relational_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relational_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relational_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterRelational_expression(s)
	}
}

func (s *Relational_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitRelational_expression(s)
	}
}

func (p *PandaParser) Relational_expression() (localctx IRelational_expressionContext) {
	return p.relational_expression(0)
}

func (p *PandaParser) relational_expression(_p int) (localctx IRelational_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRelational_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelational_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 36
	p.EnterRecursionRule(localctx, 36, PandaParserRULE_relational_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(452)
		p.shift_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(466)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
			case 1:
				localctx = NewRelational_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_relational_expression)
				p.SetState(454)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(455)
					p.Match(PandaParserLess)
				}
				{
					p.SetState(456)
					p.shift_expression(0)
				}

			case 2:
				localctx = NewRelational_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_relational_expression)
				p.SetState(457)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(458)
					p.Match(PandaParserGreater)
				}
				{
					p.SetState(459)
					p.shift_expression(0)
				}

			case 3:
				localctx = NewRelational_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_relational_expression)
				p.SetState(460)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(461)
					p.Match(PandaParserLessEqual)
				}
				{
					p.SetState(462)
					p.shift_expression(0)
				}

			case 4:
				localctx = NewRelational_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_relational_expression)
				p.SetState(463)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(464)
					p.Match(PandaParserGreaterEqual)
				}
				{
					p.SetState(465)
					p.shift_expression(0)
				}

			}

		}
		p.SetState(470)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
	}

	return localctx
}

// IEquality_expressionContext is an interface to support dynamic dispatch.
type IEquality_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEquality_expressionContext differentiates from other interfaces.
	IsEquality_expressionContext()
}

type Equality_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEquality_expressionContext() *Equality_expressionContext {
	var p = new(Equality_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_equality_expression
	return p
}

func (*Equality_expressionContext) IsEquality_expressionContext() {}

func NewEquality_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Equality_expressionContext {
	var p = new(Equality_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_equality_expression

	return p
}

func (s *Equality_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Equality_expressionContext) Relational_expression() IRelational_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelational_expressionContext)
}

func (s *Equality_expressionContext) Equality_expression() IEquality_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquality_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEquality_expressionContext)
}

func (s *Equality_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Equality_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Equality_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEquality_expression(s)
	}
}

func (s *Equality_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEquality_expression(s)
	}
}

func (p *PandaParser) Equality_expression() (localctx IEquality_expressionContext) {
	return p.equality_expression(0)
}

func (p *PandaParser) equality_expression(_p int) (localctx IEquality_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewEquality_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEquality_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 38
	p.EnterRecursionRule(localctx, 38, PandaParserRULE_equality_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(472)
		p.relational_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(480)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
			case 1:
				localctx = NewEquality_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_equality_expression)
				p.SetState(474)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(475)
					p.Match(PandaParserEqual)
				}
				{
					p.SetState(476)
					p.relational_expression(0)
				}

			case 2:
				localctx = NewEquality_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_equality_expression)
				p.SetState(477)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(478)
					p.Match(PandaParserNotEqual)
				}
				{
					p.SetState(479)
					p.relational_expression(0)
				}

			}

		}
		p.SetState(484)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())
	}

	return localctx
}

// IAnd_expressionContext is an interface to support dynamic dispatch.
type IAnd_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_expressionContext differentiates from other interfaces.
	IsAnd_expressionContext()
}

type And_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_expressionContext() *And_expressionContext {
	var p = new(And_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_and_expression
	return p
}

func (*And_expressionContext) IsAnd_expressionContext() {}

func NewAnd_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_expressionContext {
	var p = new(And_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_and_expression

	return p
}

func (s *And_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *And_expressionContext) Equality_expression() IEquality_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquality_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEquality_expressionContext)
}

func (s *And_expressionContext) And_expression() IAnd_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *And_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAnd_expression(s)
	}
}

func (s *And_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAnd_expression(s)
	}
}

func (p *PandaParser) And_expression() (localctx IAnd_expressionContext) {
	return p.and_expression(0)
}

func (p *PandaParser) and_expression(_p int) (localctx IAnd_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewAnd_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAnd_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 40
	p.EnterRecursionRule(localctx, 40, PandaParserRULE_and_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(486)
		p.equality_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAnd_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_and_expression)
			p.SetState(488)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(489)
				p.Match(PandaParserAnd)
			}
			{
				p.SetState(490)
				p.equality_expression(0)
			}

		}
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
	}

	return localctx
}

// IExclusiveor_expressionContext is an interface to support dynamic dispatch.
type IExclusiveor_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusiveor_expressionContext differentiates from other interfaces.
	IsExclusiveor_expressionContext()
}

type Exclusiveor_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusiveor_expressionContext() *Exclusiveor_expressionContext {
	var p = new(Exclusiveor_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_exclusiveor_expression
	return p
}

func (*Exclusiveor_expressionContext) IsExclusiveor_expressionContext() {}

func NewExclusiveor_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exclusiveor_expressionContext {
	var p = new(Exclusiveor_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_exclusiveor_expression

	return p
}

func (s *Exclusiveor_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Exclusiveor_expressionContext) And_expression() IAnd_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *Exclusiveor_expressionContext) Exclusiveor_expression() IExclusiveor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusiveor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusiveor_expressionContext)
}

func (s *Exclusiveor_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exclusiveor_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exclusiveor_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterExclusiveor_expression(s)
	}
}

func (s *Exclusiveor_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitExclusiveor_expression(s)
	}
}

func (p *PandaParser) Exclusiveor_expression() (localctx IExclusiveor_expressionContext) {
	return p.exclusiveor_expression(0)
}

func (p *PandaParser) exclusiveor_expression(_p int) (localctx IExclusiveor_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExclusiveor_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExclusiveor_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 42
	p.EnterRecursionRule(localctx, 42, PandaParserRULE_exclusiveor_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.and_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExclusiveor_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_exclusiveor_expression)
			p.SetState(499)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(500)
				p.Match(PandaParserCaret)
			}
			{
				p.SetState(501)
				p.and_expression(0)
			}

		}
		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}

	return localctx
}

// IInclusiveor_expressionContext is an interface to support dynamic dispatch.
type IInclusiveor_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInclusiveor_expressionContext differentiates from other interfaces.
	IsInclusiveor_expressionContext()
}

type Inclusiveor_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclusiveor_expressionContext() *Inclusiveor_expressionContext {
	var p = new(Inclusiveor_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_inclusiveor_expression
	return p
}

func (*Inclusiveor_expressionContext) IsInclusiveor_expressionContext() {}

func NewInclusiveor_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inclusiveor_expressionContext {
	var p = new(Inclusiveor_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_inclusiveor_expression

	return p
}

func (s *Inclusiveor_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Inclusiveor_expressionContext) Exclusiveor_expression() IExclusiveor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusiveor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusiveor_expressionContext)
}

func (s *Inclusiveor_expressionContext) Inclusiveor_expression() IInclusiveor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclusiveor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclusiveor_expressionContext)
}

func (s *Inclusiveor_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inclusiveor_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inclusiveor_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInclusiveor_expression(s)
	}
}

func (s *Inclusiveor_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInclusiveor_expression(s)
	}
}

func (p *PandaParser) Inclusiveor_expression() (localctx IInclusiveor_expressionContext) {
	return p.inclusiveor_expression(0)
}

func (p *PandaParser) inclusiveor_expression(_p int) (localctx IInclusiveor_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInclusiveor_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInclusiveor_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 44
	p.EnterRecursionRule(localctx, 44, PandaParserRULE_inclusiveor_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(508)
		p.exclusiveor_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInclusiveor_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_inclusiveor_expression)
			p.SetState(510)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(511)
				p.Match(PandaParserOr)
			}
			{
				p.SetState(512)
				p.exclusiveor_expression(0)
			}

		}
		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
	}

	return localctx
}

// ILogical_and_expressionContext is an interface to support dynamic dispatch.
type ILogical_and_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_and_expressionContext differentiates from other interfaces.
	IsLogical_and_expressionContext()
}

type Logical_and_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_and_expressionContext() *Logical_and_expressionContext {
	var p = new(Logical_and_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_logical_and_expression
	return p
}

func (*Logical_and_expressionContext) IsLogical_and_expressionContext() {}

func NewLogical_and_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_and_expressionContext {
	var p = new(Logical_and_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_logical_and_expression

	return p
}

func (s *Logical_and_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_and_expressionContext) Inclusiveor_expression() IInclusiveor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclusiveor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclusiveor_expressionContext)
}

func (s *Logical_and_expressionContext) Logical_and_expression() ILogical_and_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_and_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_and_expressionContext)
}

func (s *Logical_and_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_and_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_and_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLogical_and_expression(s)
	}
}

func (s *Logical_and_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLogical_and_expression(s)
	}
}

func (p *PandaParser) Logical_and_expression() (localctx ILogical_and_expressionContext) {
	return p.logical_and_expression(0)
}

func (p *PandaParser) logical_and_expression(_p int) (localctx ILogical_and_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewLogical_and_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogical_and_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 46
	p.EnterRecursionRule(localctx, 46, PandaParserRULE_logical_and_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)
		p.inclusiveor_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogical_and_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_logical_and_expression)
			p.SetState(521)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(522)
				p.Match(PandaParserAndAnd)
			}
			{
				p.SetState(523)
				p.inclusiveor_expression(0)
			}

		}
		p.SetState(528)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}

	return localctx
}

// ILogical_or_expressionContext is an interface to support dynamic dispatch.
type ILogical_or_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_or_expressionContext differentiates from other interfaces.
	IsLogical_or_expressionContext()
}

type Logical_or_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_or_expressionContext() *Logical_or_expressionContext {
	var p = new(Logical_or_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_logical_or_expression
	return p
}

func (*Logical_or_expressionContext) IsLogical_or_expressionContext() {}

func NewLogical_or_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_or_expressionContext {
	var p = new(Logical_or_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_logical_or_expression

	return p
}

func (s *Logical_or_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_or_expressionContext) Logical_and_expression() ILogical_and_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_and_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_and_expressionContext)
}

func (s *Logical_or_expressionContext) Logical_or_expression() ILogical_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_or_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_or_expressionContext)
}

func (s *Logical_or_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_or_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_or_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLogical_or_expression(s)
	}
}

func (s *Logical_or_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLogical_or_expression(s)
	}
}

func (p *PandaParser) Logical_or_expression() (localctx ILogical_or_expressionContext) {
	return p.logical_or_expression(0)
}

func (p *PandaParser) logical_or_expression(_p int) (localctx ILogical_or_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewLogical_or_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogical_or_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 48
	p.EnterRecursionRule(localctx, 48, PandaParserRULE_logical_or_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.logical_and_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogical_or_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_logical_or_expression)
			p.SetState(532)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(533)
				p.Match(PandaParserOrOr)
			}
			{
				p.SetState(534)
				p.logical_and_expression(0)
			}

		}
		p.SetState(539)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}

	return localctx
}

// IConditional_expressionContext is an interface to support dynamic dispatch.
type IConditional_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_expressionContext differentiates from other interfaces.
	IsConditional_expressionContext()
}

type Conditional_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_expressionContext() *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_conditional_expression
	return p
}

func (*Conditional_expressionContext) IsConditional_expressionContext() {}

func NewConditional_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_conditional_expression

	return p
}

func (s *Conditional_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_expressionContext) Logical_or_expression() ILogical_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_or_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_or_expressionContext)
}

func (s *Conditional_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Conditional_expressionContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Conditional_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterConditional_expression(s)
	}
}

func (s *Conditional_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitConditional_expression(s)
	}
}

func (p *PandaParser) Conditional_expression() (localctx IConditional_expressionContext) {
	localctx = NewConditional_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PandaParserRULE_conditional_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(540)
			p.logical_or_expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(541)
			p.logical_or_expression(0)
		}
		{
			p.SetState(542)
			p.Match(PandaParserQuestion)
		}
		{
			p.SetState(543)
			p.expression(0)
		}
		{
			p.SetState(544)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(545)
			p.Assignment_expression()
		}

	}

	return localctx
}

// IAssignment_expressionContext is an interface to support dynamic dispatch.
type IAssignment_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_expressionContext differentiates from other interfaces.
	IsAssignment_expressionContext()
}

type Assignment_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_expressionContext() *Assignment_expressionContext {
	var p = new(Assignment_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_assignment_expression
	return p
}

func (*Assignment_expressionContext) IsAssignment_expressionContext() {}

func NewAssignment_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_expressionContext {
	var p = new(Assignment_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_assignment_expression

	return p
}

func (s *Assignment_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_expressionContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Assignment_expressionContext) Logical_or_expression() ILogical_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_or_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_or_expressionContext)
}

func (s *Assignment_expressionContext) Assignment_operator() IAssignment_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_operatorContext)
}

func (s *Assignment_expressionContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *Assignment_expressionContext) Throw_expression() IThrow_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrow_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrow_expressionContext)
}

func (s *Assignment_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAssignment_expression(s)
	}
}

func (s *Assignment_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAssignment_expression(s)
	}
}

func (p *PandaParser) Assignment_expression() (localctx IAssignment_expressionContext) {
	localctx = NewAssignment_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PandaParserRULE_assignment_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(549)
			p.Conditional_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(550)
			p.logical_or_expression(0)
		}
		{
			p.SetState(551)
			p.Assignment_operator()
		}
		{
			p.SetState(552)
			p.Initializer_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(554)
			p.Throw_expression()
		}

	}

	return localctx
}

// IAssignment_operatorContext is an interface to support dynamic dispatch.
type IAssignment_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_operatorContext differentiates from other interfaces.
	IsAssignment_operatorContext()
}

type Assignment_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_operatorContext() *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_assignment_operator
	return p
}

func (*Assignment_operatorContext) IsAssignment_operatorContext() {}

func NewAssignment_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_assignment_operator

	return p
}

func (s *Assignment_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_operatorContext) RightShiftAssign() antlr.TerminalNode {
	return s.GetToken(PandaParserRightShiftAssign, 0)
}

func (s *Assignment_operatorContext) LeftShiftAssign() antlr.TerminalNode {
	return s.GetToken(PandaParserLeftShiftAssign, 0)
}

func (s *Assignment_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAssignment_operator(s)
	}
}

func (s *Assignment_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAssignment_operator(s)
	}
}

func (p *PandaParser) Assignment_operator() (localctx IAssignment_operatorContext) {
	localctx = NewAssignment_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PandaParserRULE_assignment_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(557)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-67)&-(0x1f+1)) == 0 && ((1<<uint((_la-67)))&((1<<(PandaParserAssign-67))|(1<<(PandaParserPlusAssign-67))|(1<<(PandaParserMinusAssign-67))|(1<<(PandaParserDivAssign-67))|(1<<(PandaParserModAssign-67))|(1<<(PandaParserXorAssign-67))|(1<<(PandaParserAndAssign-67))|(1<<(PandaParserOrAssign-67))|(1<<(PandaParserLeftShiftAssign-67))|(1<<(PandaParserRightShiftAssign-67)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *ExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *PandaParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *PandaParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 56
	p.EnterRecursionRule(localctx, 56, PandaParserRULE_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.Assignment_expression()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_expression)
			p.SetState(562)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(563)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(564)
				p.Assignment_expression()
			}

		}
		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())
	}

	return localctx
}

// IConstant_expressionContext is an interface to support dynamic dispatch.
type IConstant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_expressionContext differentiates from other interfaces.
	IsConstant_expressionContext()
}

type Constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_expressionContext() *Constant_expressionContext {
	var p = new(Constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_constant_expression
	return p
}

func (*Constant_expressionContext) IsConstant_expressionContext() {}

func NewConstant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_expressionContext {
	var p = new(Constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_constant_expression

	return p
}

func (s *Constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_expressionContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterConstant_expression(s)
	}
}

func (s *Constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitConstant_expression(s)
	}
}

func (p *PandaParser) Constant_expression() (localctx IConstant_expressionContext) {
	localctx = NewConstant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PandaParserRULE_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(570)
		p.Conditional_expression()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Labeled_statement() ILabeled_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabeled_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabeled_statementContext)
}

func (s *StatementContext) Expression_statement() IExpression_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_statementContext)
}

func (s *StatementContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *StatementContext) Selection_statement() ISelection_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelection_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelection_statementContext)
}

func (s *StatementContext) Iteration_statement() IIteration_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteration_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteration_statementContext)
}

func (s *StatementContext) Jump_statement() IJump_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_statementContext)
}

func (s *StatementContext) Declaration_statement() IDeclaration_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_statementContext)
}

func (s *StatementContext) Try_block() ITry_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITry_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITry_blockContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *PandaParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PandaParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(572)
			p.Labeled_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(573)
			p.Expression_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(574)
			p.Compound_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(575)
			p.Selection_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(576)
			p.Iteration_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(577)
			p.Jump_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(578)
			p.Declaration_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(579)
			p.Try_block()
		}

	}

	return localctx
}

// ILabeled_statementContext is an interface to support dynamic dispatch.
type ILabeled_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabeled_statementContext differentiates from other interfaces.
	IsLabeled_statementContext()
}

type Labeled_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeled_statementContext() *Labeled_statementContext {
	var p = new(Labeled_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_labeled_statement
	return p
}

func (*Labeled_statementContext) IsLabeled_statementContext() {}

func NewLabeled_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Labeled_statementContext {
	var p = new(Labeled_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_labeled_statement

	return p
}

func (s *Labeled_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Labeled_statementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Labeled_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Labeled_statementContext) Case() antlr.TerminalNode {
	return s.GetToken(PandaParserCase, 0)
}

func (s *Labeled_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Labeled_statementContext) Default() antlr.TerminalNode {
	return s.GetToken(PandaParserDefault, 0)
}

func (s *Labeled_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Labeled_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Labeled_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLabeled_statement(s)
	}
}

func (s *Labeled_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLabeled_statement(s)
	}
}

func (p *PandaParser) Labeled_statement() (localctx ILabeled_statementContext) {
	localctx = NewLabeled_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PandaParserRULE_labeled_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(593)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(582)
			p.Match(PandaParserIdentifier)
		}
		{
			p.SetState(583)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(584)
			p.Statement()
		}

	case PandaParserCase:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(585)
			p.Match(PandaParserCase)
		}
		{
			p.SetState(586)
			p.Constant_expression()
		}
		{
			p.SetState(587)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(588)
			p.Statement()
		}

	case PandaParserDefault:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(590)
			p.Match(PandaParserDefault)
		}
		{
			p.SetState(591)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(592)
			p.Statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpression_statementContext is an interface to support dynamic dispatch.
type IExpression_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_statementContext differentiates from other interfaces.
	IsExpression_statementContext()
}

type Expression_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_statementContext() *Expression_statementContext {
	var p = new(Expression_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_expression_statement
	return p
}

func (*Expression_statementContext) IsExpression_statementContext() {}

func NewExpression_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_statementContext {
	var p = new(Expression_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_expression_statement

	return p
}

func (s *Expression_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterExpression_statement(s)
	}
}

func (s *Expression_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitExpression_statement(s)
	}
}

func (p *PandaParser) Expression_statement() (localctx IExpression_statementContext) {
	localctx = NewExpression_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PandaParserRULE_expression_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserThrow-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
		{
			p.SetState(595)
			p.expression(0)
		}

	}
	{
		p.SetState(598)
		p.Match(PandaParserSemi)
	}

	return localctx
}

// ICompound_statementContext is an interface to support dynamic dispatch.
type ICompound_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_statementContext differentiates from other interfaces.
	IsCompound_statementContext()
}

type Compound_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_statementContext() *Compound_statementContext {
	var p = new(Compound_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_compound_statement
	return p
}

func (*Compound_statementContext) IsCompound_statementContext() {}

func NewCompound_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_statementContext {
	var p = new(Compound_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_compound_statement

	return p
}

func (s *Compound_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_statementContext) Statement_sequence() IStatement_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_sequenceContext)
}

func (s *Compound_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterCompound_statement(s)
	}
}

func (s *Compound_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitCompound_statement(s)
	}
}

func (p *PandaParser) Compound_statement() (localctx ICompound_statementContext) {
	localctx = NewCompound_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PandaParserRULE_compound_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.Match(PandaParserLeftBrace)
	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserBreak)|(1<<PandaParserCase)|(1<<PandaParserCast)|(1<<PandaParserClass)|(1<<PandaParserContinue)|(1<<PandaParserDefault)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserFor)|(1<<PandaParserIf)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(PandaParserReturn-34))|(1<<(PandaParserShort-34))|(1<<(PandaParserSwitch-34))|(1<<(PandaParserThis-34))|(1<<(PandaParserThrow-34))|(1<<(PandaParserTry-34))|(1<<(PandaParserUint-34))|(1<<(PandaParserUint8-34))|(1<<(PandaParserUint16-34))|(1<<(PandaParserUint32-34))|(1<<(PandaParserUint64-34))|(1<<(PandaParserUlong-34))|(1<<(PandaParserUshort-34))|(1<<(PandaParserUsing-34))|(1<<(PandaParserVoid-34))|(1<<(PandaParserLeftParen-34))|(1<<(PandaParserLeftBrace-34))|(1<<(PandaParserPlus-34))|(1<<(PandaParserMinus-34))|(1<<(PandaParserAnd-34))|(1<<(PandaParserOr-34))|(1<<(PandaParserTilde-34)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(PandaParserNot-66))|(1<<(PandaParserPlusPlus-66))|(1<<(PandaParserMinusMinus-66))|(1<<(PandaParserSemi-66))|(1<<(PandaParserEllipsis-66))|(1<<(PandaParserIdentifier-66))|(1<<(PandaParserIntegerLiteral-66)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(PandaParserFloatLiteral-102))|(1<<(PandaParserStringLiteral-102))|(1<<(PandaParserBooleanLiteral-102))|(1<<(PandaParserPointerLiteral-102)))) != 0) {
		{
			p.SetState(601)
			p.statement_sequence(0)
		}

	}
	{
		p.SetState(604)
		p.Match(PandaParserRightBrace)
	}

	return localctx
}

// IStatement_sequenceContext is an interface to support dynamic dispatch.
type IStatement_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_sequenceContext differentiates from other interfaces.
	IsStatement_sequenceContext()
}

type Statement_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_sequenceContext() *Statement_sequenceContext {
	var p = new(Statement_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_statement_sequence
	return p
}

func (*Statement_sequenceContext) IsStatement_sequenceContext() {}

func NewStatement_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_sequenceContext {
	var p = new(Statement_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_statement_sequence

	return p
}

func (s *Statement_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_sequenceContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Statement_sequenceContext) Statement_sequence() IStatement_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_sequenceContext)
}

func (s *Statement_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterStatement_sequence(s)
	}
}

func (s *Statement_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitStatement_sequence(s)
	}
}

func (p *PandaParser) Statement_sequence() (localctx IStatement_sequenceContext) {
	return p.statement_sequence(0)
}

func (p *PandaParser) statement_sequence(_p int) (localctx IStatement_sequenceContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewStatement_sequenceContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IStatement_sequenceContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 68
	p.EnterRecursionRule(localctx, 68, PandaParserRULE_statement_sequence, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Statement()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewStatement_sequenceContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_statement_sequence)
			p.SetState(609)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(610)
				p.Statement()
			}

		}
		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
	}

	return localctx
}

// ISelection_statementContext is an interface to support dynamic dispatch.
type ISelection_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelection_statementContext differentiates from other interfaces.
	IsSelection_statementContext()
}

type Selection_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelection_statementContext() *Selection_statementContext {
	var p = new(Selection_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_selection_statement
	return p
}

func (*Selection_statementContext) IsSelection_statementContext() {}

func NewSelection_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selection_statementContext {
	var p = new(Selection_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_selection_statement

	return p
}

func (s *Selection_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Selection_statementContext) If() antlr.TerminalNode {
	return s.GetToken(PandaParserIf, 0)
}

func (s *Selection_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Selection_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Selection_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Selection_statementContext) Else() antlr.TerminalNode {
	return s.GetToken(PandaParserElse, 0)
}

func (s *Selection_statementContext) Switch() antlr.TerminalNode {
	return s.GetToken(PandaParserSwitch, 0)
}

func (s *Selection_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selection_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selection_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterSelection_statement(s)
	}
}

func (s *Selection_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitSelection_statement(s)
	}
}

func (p *PandaParser) Selection_statement() (localctx ISelection_statementContext) {
	localctx = NewSelection_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PandaParserRULE_selection_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(616)
			p.Match(PandaParserIf)
		}
		{
			p.SetState(617)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(618)
			p.Condition()
		}
		{
			p.SetState(619)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(620)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(622)
			p.Match(PandaParserIf)
		}
		{
			p.SetState(623)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(624)
			p.Condition()
		}
		{
			p.SetState(625)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(626)
			p.Statement()
		}
		{
			p.SetState(627)
			p.Match(PandaParserElse)
		}
		{
			p.SetState(628)
			p.Statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(630)
			p.Match(PandaParserSwitch)
		}
		{
			p.SetState(631)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(632)
			p.Condition()
		}
		{
			p.SetState(633)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(634)
			p.Statement()
		}

	}

	return localctx
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_condition
	return p
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *ConditionContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *ConditionContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *ConditionContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (p *PandaParser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PandaParserRULE_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(638)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(639)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(640)
			p.Declarator()
		}
		{
			p.SetState(641)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(642)
			p.Initializer_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(644)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(645)
			p.Declarator()
		}
		{
			p.SetState(646)
			p.Braced_init_list()
		}

	}

	return localctx
}

// IIteration_statementContext is an interface to support dynamic dispatch.
type IIteration_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteration_statementContext differentiates from other interfaces.
	IsIteration_statementContext()
}

type Iteration_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteration_statementContext() *Iteration_statementContext {
	var p = new(Iteration_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_iteration_statement
	return p
}

func (*Iteration_statementContext) IsIteration_statementContext() {}

func NewIteration_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Iteration_statementContext {
	var p = new(Iteration_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_iteration_statement

	return p
}

func (s *Iteration_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Iteration_statementContext) For() antlr.TerminalNode {
	return s.GetToken(PandaParserFor, 0)
}

func (s *Iteration_statementContext) For_init_statement() IFor_init_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_init_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_init_statementContext)
}

func (s *Iteration_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Iteration_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Iteration_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Iteration_statementContext) For_range_declaration() IFor_range_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_range_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_range_declarationContext)
}

func (s *Iteration_statementContext) For_range_initializer() IFor_range_initializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_range_initializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_range_initializerContext)
}

func (s *Iteration_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Iteration_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Iteration_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterIteration_statement(s)
	}
}

func (s *Iteration_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitIteration_statement(s)
	}
}

func (p *PandaParser) Iteration_statement() (localctx IIteration_statementContext) {
	localctx = NewIteration_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PandaParserRULE_iteration_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(650)
			p.Match(PandaParserFor)
		}
		{
			p.SetState(651)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(652)
			p.For_init_statement()
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserClass)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserThrow-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
			{
				p.SetState(653)
				p.Condition()
			}

		}
		{
			p.SetState(656)
			p.Match(PandaParserSemi)
		}
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserThrow-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
			{
				p.SetState(657)
				p.expression(0)
			}

		}
		{
			p.SetState(660)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(661)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(663)
			p.Match(PandaParserFor)
		}
		{
			p.SetState(664)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(665)
			p.For_range_declaration()
		}
		{
			p.SetState(666)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(667)
			p.For_range_initializer()
		}
		{
			p.SetState(668)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(669)
			p.Statement()
		}

	}

	return localctx
}

// IFor_init_statementContext is an interface to support dynamic dispatch.
type IFor_init_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_init_statementContext differentiates from other interfaces.
	IsFor_init_statementContext()
}

type For_init_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_init_statementContext() *For_init_statementContext {
	var p = new(For_init_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_for_init_statement
	return p
}

func (*For_init_statementContext) IsFor_init_statementContext() {}

func NewFor_init_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_init_statementContext {
	var p = new(For_init_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_for_init_statement

	return p
}

func (s *For_init_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *For_init_statementContext) Expression_statement() IExpression_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_statementContext)
}

func (s *For_init_statementContext) Simple_declaration() ISimple_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declarationContext)
}

func (s *For_init_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_init_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_init_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFor_init_statement(s)
	}
}

func (s *For_init_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFor_init_statement(s)
	}
}

func (p *PandaParser) For_init_statement() (localctx IFor_init_statementContext) {
	localctx = NewFor_init_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PandaParserRULE_for_init_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(673)
			p.Expression_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(674)
			p.Simple_declaration()
		}

	}

	return localctx
}

// IFor_range_declarationContext is an interface to support dynamic dispatch.
type IFor_range_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_range_declarationContext differentiates from other interfaces.
	IsFor_range_declarationContext()
}

type For_range_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_range_declarationContext() *For_range_declarationContext {
	var p = new(For_range_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_for_range_declaration
	return p
}

func (*For_range_declarationContext) IsFor_range_declarationContext() {}

func NewFor_range_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_range_declarationContext {
	var p = new(For_range_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_for_range_declaration

	return p
}

func (s *For_range_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *For_range_declarationContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *For_range_declarationContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *For_range_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_range_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_range_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFor_range_declaration(s)
	}
}

func (s *For_range_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFor_range_declaration(s)
	}
}

func (p *PandaParser) For_range_declaration() (localctx IFor_range_declarationContext) {
	localctx = NewFor_range_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, PandaParserRULE_for_range_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		p.Decl_specifier_sequence()
	}
	{
		p.SetState(678)
		p.Declarator()
	}

	return localctx
}

// IFor_range_initializerContext is an interface to support dynamic dispatch.
type IFor_range_initializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_range_initializerContext differentiates from other interfaces.
	IsFor_range_initializerContext()
}

type For_range_initializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_range_initializerContext() *For_range_initializerContext {
	var p = new(For_range_initializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_for_range_initializer
	return p
}

func (*For_range_initializerContext) IsFor_range_initializerContext() {}

func NewFor_range_initializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_range_initializerContext {
	var p = new(For_range_initializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_for_range_initializer

	return p
}

func (s *For_range_initializerContext) GetParser() antlr.Parser { return s.parser }

func (s *For_range_initializerContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *For_range_initializerContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *For_range_initializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_range_initializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_range_initializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFor_range_initializer(s)
	}
}

func (s *For_range_initializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFor_range_initializer(s)
	}
}

func (p *PandaParser) For_range_initializer() (localctx IFor_range_initializerContext) {
	localctx = NewFor_range_initializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, PandaParserRULE_for_range_initializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(680)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(681)
			p.Braced_init_list()
		}

	}

	return localctx
}

// IJump_statementContext is an interface to support dynamic dispatch.
type IJump_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_statementContext differentiates from other interfaces.
	IsJump_statementContext()
}

type Jump_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_statementContext() *Jump_statementContext {
	var p = new(Jump_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_jump_statement
	return p
}

func (*Jump_statementContext) IsJump_statementContext() {}

func NewJump_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_statementContext {
	var p = new(Jump_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_jump_statement

	return p
}

func (s *Jump_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_statementContext) Break() antlr.TerminalNode {
	return s.GetToken(PandaParserBreak, 0)
}

func (s *Jump_statementContext) Continue() antlr.TerminalNode {
	return s.GetToken(PandaParserContinue, 0)
}

func (s *Jump_statementContext) Return() antlr.TerminalNode {
	return s.GetToken(PandaParserReturn, 0)
}

func (s *Jump_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Jump_statementContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *Jump_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterJump_statement(s)
	}
}

func (s *Jump_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitJump_statement(s)
	}
}

func (p *PandaParser) Jump_statement() (localctx IJump_statementContext) {
	localctx = NewJump_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, PandaParserRULE_jump_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(684)
			p.Match(PandaParserBreak)
		}
		{
			p.SetState(685)
			p.Match(PandaParserSemi)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(686)
			p.Match(PandaParserContinue)
		}
		{
			p.SetState(687)
			p.Match(PandaParserSemi)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(688)
			p.Match(PandaParserReturn)
		}
		p.SetState(690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserThrow-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
			{
				p.SetState(689)
				p.expression(0)
			}

		}
		{
			p.SetState(692)
			p.Match(PandaParserSemi)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(693)
			p.Match(PandaParserReturn)
		}
		{
			p.SetState(694)
			p.Braced_init_list()
		}
		{
			p.SetState(695)
			p.Match(PandaParserSemi)
		}

	}

	return localctx
}

// IDeclaration_statementContext is an interface to support dynamic dispatch.
type IDeclaration_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_statementContext differentiates from other interfaces.
	IsDeclaration_statementContext()
}

type Declaration_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_statementContext() *Declaration_statementContext {
	var p = new(Declaration_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declaration_statement
	return p
}

func (*Declaration_statementContext) IsDeclaration_statementContext() {}

func NewDeclaration_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_statementContext {
	var p = new(Declaration_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declaration_statement

	return p
}

func (s *Declaration_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_statementContext) Block_declaration() IBlock_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarationContext)
}

func (s *Declaration_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclaration_statement(s)
	}
}

func (s *Declaration_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclaration_statement(s)
	}
}

func (p *PandaParser) Declaration_statement() (localctx IDeclaration_statementContext) {
	localctx = NewDeclaration_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, PandaParserRULE_declaration_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(699)
		p.Block_declaration()
	}

	return localctx
}

// IDeclaration_sequenceContext is an interface to support dynamic dispatch.
type IDeclaration_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_sequenceContext differentiates from other interfaces.
	IsDeclaration_sequenceContext()
}

type Declaration_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_sequenceContext() *Declaration_sequenceContext {
	var p = new(Declaration_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declaration_sequence
	return p
}

func (*Declaration_sequenceContext) IsDeclaration_sequenceContext() {}

func NewDeclaration_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_sequenceContext {
	var p = new(Declaration_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declaration_sequence

	return p
}

func (s *Declaration_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_sequenceContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *Declaration_sequenceContext) Declaration_sequence() IDeclaration_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_sequenceContext)
}

func (s *Declaration_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclaration_sequence(s)
	}
}

func (s *Declaration_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclaration_sequence(s)
	}
}

func (p *PandaParser) Declaration_sequence() (localctx IDeclaration_sequenceContext) {
	return p.declaration_sequence(0)
}

func (p *PandaParser) declaration_sequence(_p int) (localctx IDeclaration_sequenceContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDeclaration_sequenceContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDeclaration_sequenceContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, PandaParserRULE_declaration_sequence, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Declaration()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDeclaration_sequenceContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_declaration_sequence)
			p.SetState(704)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(705)
				p.Declaration()
			}

		}
		p.SetState(710)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) Block_declaration() IBlock_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarationContext)
}

func (s *DeclarationContext) Function_definition() IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *DeclarationContext) Namespace_definition() INamespace_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_definitionContext)
}

func (s *DeclarationContext) Empty_declaration() IEmpty_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_declarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (p *PandaParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, PandaParserRULE_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(711)
			p.Block_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(712)
			p.Function_definition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(713)
			p.Namespace_definition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(714)
			p.Empty_declaration()
		}

	}

	return localctx
}

// IBlock_declarationContext is an interface to support dynamic dispatch.
type IBlock_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_declarationContext differentiates from other interfaces.
	IsBlock_declarationContext()
}

type Block_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_declarationContext() *Block_declarationContext {
	var p = new(Block_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_block_declaration
	return p
}

func (*Block_declarationContext) IsBlock_declarationContext() {}

func NewBlock_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_declarationContext {
	var p = new(Block_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_block_declaration

	return p
}

func (s *Block_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_declarationContext) Simple_declaration() ISimple_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declarationContext)
}

func (s *Block_declarationContext) Using_namespace() IUsing_namespaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUsing_namespaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUsing_namespaceContext)
}

func (s *Block_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBlock_declaration(s)
	}
}

func (s *Block_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBlock_declaration(s)
	}
}

func (p *PandaParser) Block_declaration() (localctx IBlock_declarationContext) {
	localctx = NewBlock_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, PandaParserRULE_block_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(719)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserAuto, PandaParserBool, PandaParserClass, PandaParserDouble, PandaParserEnum, PandaParserFloat32, PandaParserFloat64, PandaParserFloat, PandaParserInt, PandaParserInt8, PandaParserInt16, PandaParserInt32, PandaParserInt64, PandaParserLong, PandaParserOperator, PandaParserShort, PandaParserUint, PandaParserUint8, PandaParserUint16, PandaParserUint32, PandaParserUint64, PandaParserUlong, PandaParserUshort, PandaParserVoid, PandaParserLeftParen, PandaParserAnd, PandaParserSemi, PandaParserEllipsis, PandaParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(717)
			p.Simple_declaration()
		}

	case PandaParserUsing:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(718)
			p.Using_namespace()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimple_declarationContext is an interface to support dynamic dispatch.
type ISimple_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_declarationContext differentiates from other interfaces.
	IsSimple_declarationContext()
}

type Simple_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_declarationContext() *Simple_declarationContext {
	var p = new(Simple_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_simple_declaration
	return p
}

func (*Simple_declarationContext) IsSimple_declarationContext() {}

func NewSimple_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_declarationContext {
	var p = new(Simple_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_simple_declaration

	return p
}

func (s *Simple_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_declarationContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Simple_declarationContext) Init_declarator_list() IInit_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declarator_listContext)
}

func (s *Simple_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterSimple_declaration(s)
	}
}

func (s *Simple_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitSimple_declaration(s)
	}
}

func (p *PandaParser) Simple_declaration() (localctx ISimple_declarationContext) {
	localctx = NewSimple_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, PandaParserRULE_simple_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(722)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(721)
			p.Decl_specifier_sequence()
		}

	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserOperator || _la == PandaParserLeftParen || _la == PandaParserAnd || _la == PandaParserEllipsis || _la == PandaParserIdentifier {
		{
			p.SetState(724)
			p.init_declarator_list(0)
		}

	}
	{
		p.SetState(727)
		p.Match(PandaParserSemi)
	}

	return localctx
}

// IEmpty_declarationContext is an interface to support dynamic dispatch.
type IEmpty_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_declarationContext differentiates from other interfaces.
	IsEmpty_declarationContext()
}

type Empty_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_declarationContext() *Empty_declarationContext {
	var p = new(Empty_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_empty_declaration
	return p
}

func (*Empty_declarationContext) IsEmpty_declarationContext() {}

func NewEmpty_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_declarationContext {
	var p = new(Empty_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_empty_declaration

	return p
}

func (s *Empty_declarationContext) GetParser() antlr.Parser { return s.parser }
func (s *Empty_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEmpty_declaration(s)
	}
}

func (s *Empty_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEmpty_declaration(s)
	}
}

func (p *PandaParser) Empty_declaration() (localctx IEmpty_declarationContext) {
	localctx = NewEmpty_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, PandaParserRULE_empty_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.Match(PandaParserSemi)
	}

	return localctx
}

// IDecl_specifierContext is an interface to support dynamic dispatch.
type IDecl_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecl_specifierContext differentiates from other interfaces.
	IsDecl_specifierContext()
}

type Decl_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecl_specifierContext() *Decl_specifierContext {
	var p = new(Decl_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_decl_specifier
	return p
}

func (*Decl_specifierContext) IsDecl_specifierContext() {}

func NewDecl_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Decl_specifierContext {
	var p = new(Decl_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_decl_specifier

	return p
}

func (s *Decl_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Decl_specifierContext) Type_specifier() IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Decl_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Decl_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Decl_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDecl_specifier(s)
	}
}

func (s *Decl_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDecl_specifier(s)
	}
}

func (p *PandaParser) Decl_specifier() (localctx IDecl_specifierContext) {
	localctx = NewDecl_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, PandaParserRULE_decl_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.Type_specifier()
	}

	return localctx
}

// IDecl_specifier_sequenceContext is an interface to support dynamic dispatch.
type IDecl_specifier_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecl_specifier_sequenceContext differentiates from other interfaces.
	IsDecl_specifier_sequenceContext()
}

type Decl_specifier_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecl_specifier_sequenceContext() *Decl_specifier_sequenceContext {
	var p = new(Decl_specifier_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_decl_specifier_sequence
	return p
}

func (*Decl_specifier_sequenceContext) IsDecl_specifier_sequenceContext() {}

func NewDecl_specifier_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Decl_specifier_sequenceContext {
	var p = new(Decl_specifier_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_decl_specifier_sequence

	return p
}

func (s *Decl_specifier_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Decl_specifier_sequenceContext) Decl_specifier() IDecl_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifierContext)
}

func (s *Decl_specifier_sequenceContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Decl_specifier_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Decl_specifier_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Decl_specifier_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDecl_specifier_sequence(s)
	}
}

func (s *Decl_specifier_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDecl_specifier_sequence(s)
	}
}

func (p *PandaParser) Decl_specifier_sequence() (localctx IDecl_specifier_sequenceContext) {
	localctx = NewDecl_specifier_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, PandaParserRULE_decl_specifier_sequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(733)
			p.Decl_specifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(734)
			p.Decl_specifier()
		}
		{
			p.SetState(735)
			p.Decl_specifier_sequence()
		}

	}

	return localctx
}

// IType_specifierContext is an interface to support dynamic dispatch.
type IType_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specifierContext differentiates from other interfaces.
	IsType_specifierContext()
}

type Type_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specifierContext() *Type_specifierContext {
	var p = new(Type_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_specifier
	return p
}

func (*Type_specifierContext) IsType_specifierContext() {}

func NewType_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specifierContext {
	var p = new(Type_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_specifier

	return p
}

func (s *Type_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specifierContext) Trailing_type_specifier() ITrailing_type_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailing_type_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrailing_type_specifierContext)
}

func (s *Type_specifierContext) Class_specifier() IClass_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_specifierContext)
}

func (s *Type_specifierContext) Enum_specifier() IEnum_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_specifierContext)
}

func (s *Type_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_specifier(s)
	}
}

func (s *Type_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_specifier(s)
	}
}

func (p *PandaParser) Type_specifier() (localctx IType_specifierContext) {
	localctx = NewType_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, PandaParserRULE_type_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(742)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserAuto, PandaParserBool, PandaParserDouble, PandaParserFloat32, PandaParserFloat64, PandaParserFloat, PandaParserInt, PandaParserInt8, PandaParserInt16, PandaParserInt32, PandaParserInt64, PandaParserLong, PandaParserShort, PandaParserUint, PandaParserUint8, PandaParserUint16, PandaParserUint32, PandaParserUint64, PandaParserUlong, PandaParserUshort, PandaParserVoid, PandaParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(739)
			p.Trailing_type_specifier()
		}

	case PandaParserClass:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(740)
			p.Class_specifier()
		}

	case PandaParserEnum:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(741)
			p.Enum_specifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITrailing_type_specifierContext is an interface to support dynamic dispatch.
type ITrailing_type_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrailing_type_specifierContext differentiates from other interfaces.
	IsTrailing_type_specifierContext()
}

type Trailing_type_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailing_type_specifierContext() *Trailing_type_specifierContext {
	var p = new(Trailing_type_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_trailing_type_specifier
	return p
}

func (*Trailing_type_specifierContext) IsTrailing_type_specifierContext() {}

func NewTrailing_type_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trailing_type_specifierContext {
	var p = new(Trailing_type_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_trailing_type_specifier

	return p
}

func (s *Trailing_type_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Trailing_type_specifierContext) Simple_type_specifier() ISimple_type_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_type_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_type_specifierContext)
}

func (s *Trailing_type_specifierContext) Type_name_specifier() IType_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_name_specifierContext)
}

func (s *Trailing_type_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trailing_type_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trailing_type_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTrailing_type_specifier(s)
	}
}

func (s *Trailing_type_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTrailing_type_specifier(s)
	}
}

func (p *PandaParser) Trailing_type_specifier() (localctx ITrailing_type_specifierContext) {
	localctx = NewTrailing_type_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, PandaParserRULE_trailing_type_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(744)
			p.Simple_type_specifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(745)
			p.Type_name_specifier()
		}

	}

	return localctx
}

// IType_specifier_sequenceContext is an interface to support dynamic dispatch.
type IType_specifier_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specifier_sequenceContext differentiates from other interfaces.
	IsType_specifier_sequenceContext()
}

type Type_specifier_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specifier_sequenceContext() *Type_specifier_sequenceContext {
	var p = new(Type_specifier_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_specifier_sequence
	return p
}

func (*Type_specifier_sequenceContext) IsType_specifier_sequenceContext() {}

func NewType_specifier_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specifier_sequenceContext {
	var p = new(Type_specifier_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_specifier_sequence

	return p
}

func (s *Type_specifier_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specifier_sequenceContext) Type_specifier() IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Type_specifier_sequenceContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *Type_specifier_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specifier_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_specifier_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_specifier_sequence(s)
	}
}

func (s *Type_specifier_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_specifier_sequence(s)
	}
}

func (p *PandaParser) Type_specifier_sequence() (localctx IType_specifier_sequenceContext) {
	localctx = NewType_specifier_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, PandaParserRULE_type_specifier_sequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(752)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(748)
			p.Type_specifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(749)
			p.Type_specifier()
		}
		{
			p.SetState(750)
			p.Type_specifier_sequence()
		}

	}

	return localctx
}

// ITrailing_type_specifier_sequenceContext is an interface to support dynamic dispatch.
type ITrailing_type_specifier_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrailing_type_specifier_sequenceContext differentiates from other interfaces.
	IsTrailing_type_specifier_sequenceContext()
}

type Trailing_type_specifier_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailing_type_specifier_sequenceContext() *Trailing_type_specifier_sequenceContext {
	var p = new(Trailing_type_specifier_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_trailing_type_specifier_sequence
	return p
}

func (*Trailing_type_specifier_sequenceContext) IsTrailing_type_specifier_sequenceContext() {}

func NewTrailing_type_specifier_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trailing_type_specifier_sequenceContext {
	var p = new(Trailing_type_specifier_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_trailing_type_specifier_sequence

	return p
}

func (s *Trailing_type_specifier_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Trailing_type_specifier_sequenceContext) Trailing_type_specifier() ITrailing_type_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailing_type_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrailing_type_specifierContext)
}

func (s *Trailing_type_specifier_sequenceContext) Trailing_type_specifier_sequence() ITrailing_type_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailing_type_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrailing_type_specifier_sequenceContext)
}

func (s *Trailing_type_specifier_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trailing_type_specifier_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trailing_type_specifier_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTrailing_type_specifier_sequence(s)
	}
}

func (s *Trailing_type_specifier_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTrailing_type_specifier_sequence(s)
	}
}

func (p *PandaParser) Trailing_type_specifier_sequence() (localctx ITrailing_type_specifier_sequenceContext) {
	localctx = NewTrailing_type_specifier_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, PandaParserRULE_trailing_type_specifier_sequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(754)
			p.Trailing_type_specifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(755)
			p.Trailing_type_specifier()
		}
		{
			p.SetState(756)
			p.Trailing_type_specifier_sequence()
		}

	}

	return localctx
}

// ISimple_type_specifierContext is an interface to support dynamic dispatch.
type ISimple_type_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_type_specifierContext differentiates from other interfaces.
	IsSimple_type_specifierContext()
}

type Simple_type_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_type_specifierContext() *Simple_type_specifierContext {
	var p = new(Simple_type_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_simple_type_specifier
	return p
}

func (*Simple_type_specifierContext) IsSimple_type_specifierContext() {}

func NewSimple_type_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_type_specifierContext {
	var p = new(Simple_type_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_simple_type_specifier

	return p
}

func (s *Simple_type_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_type_specifierContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Simple_type_specifierContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Simple_type_specifierContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Simple_type_specifierContext) Bool() antlr.TerminalNode {
	return s.GetToken(PandaParserBool, 0)
}

func (s *Simple_type_specifierContext) Int8() antlr.TerminalNode {
	return s.GetToken(PandaParserInt8, 0)
}

func (s *Simple_type_specifierContext) Int16() antlr.TerminalNode {
	return s.GetToken(PandaParserInt16, 0)
}

func (s *Simple_type_specifierContext) Int32() antlr.TerminalNode {
	return s.GetToken(PandaParserInt32, 0)
}

func (s *Simple_type_specifierContext) Int64() antlr.TerminalNode {
	return s.GetToken(PandaParserInt64, 0)
}

func (s *Simple_type_specifierContext) Uint8() antlr.TerminalNode {
	return s.GetToken(PandaParserUint8, 0)
}

func (s *Simple_type_specifierContext) Uint16() antlr.TerminalNode {
	return s.GetToken(PandaParserUint16, 0)
}

func (s *Simple_type_specifierContext) Uint32() antlr.TerminalNode {
	return s.GetToken(PandaParserUint32, 0)
}

func (s *Simple_type_specifierContext) Uint64() antlr.TerminalNode {
	return s.GetToken(PandaParserUint64, 0)
}

func (s *Simple_type_specifierContext) Int() antlr.TerminalNode {
	return s.GetToken(PandaParserInt, 0)
}

func (s *Simple_type_specifierContext) Uint() antlr.TerminalNode {
	return s.GetToken(PandaParserUint, 0)
}

func (s *Simple_type_specifierContext) Short() antlr.TerminalNode {
	return s.GetToken(PandaParserShort, 0)
}

func (s *Simple_type_specifierContext) Ushort() antlr.TerminalNode {
	return s.GetToken(PandaParserUshort, 0)
}

func (s *Simple_type_specifierContext) Long() antlr.TerminalNode {
	return s.GetToken(PandaParserLong, 0)
}

func (s *Simple_type_specifierContext) Ulong() antlr.TerminalNode {
	return s.GetToken(PandaParserUlong, 0)
}

func (s *Simple_type_specifierContext) Float32() antlr.TerminalNode {
	return s.GetToken(PandaParserFloat32, 0)
}

func (s *Simple_type_specifierContext) Float64() antlr.TerminalNode {
	return s.GetToken(PandaParserFloat64, 0)
}

func (s *Simple_type_specifierContext) Float() antlr.TerminalNode {
	return s.GetToken(PandaParserFloat, 0)
}

func (s *Simple_type_specifierContext) Double() antlr.TerminalNode {
	return s.GetToken(PandaParserDouble, 0)
}

func (s *Simple_type_specifierContext) Void() antlr.TerminalNode {
	return s.GetToken(PandaParserVoid, 0)
}

func (s *Simple_type_specifierContext) Auto() antlr.TerminalNode {
	return s.GetToken(PandaParserAuto, 0)
}

func (s *Simple_type_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_type_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_type_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterSimple_type_specifier(s)
	}
}

func (s *Simple_type_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitSimple_type_specifier(s)
	}
}

func (p *PandaParser) Simple_type_specifier() (localctx ISimple_type_specifierContext) {
	localctx = NewSimple_type_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, PandaParserRULE_simple_type_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(761)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(760)
				p.nested_name_specifier(0)
			}

		}
		{
			p.SetState(763)
			p.Type_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(764)
			p.nested_name_specifier(0)
		}
		{
			p.SetState(765)
			p.Template_id()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(767)
			p.Match(PandaParserBool)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(768)
			p.Match(PandaParserInt8)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(769)
			p.Match(PandaParserInt16)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(770)
			p.Match(PandaParserInt32)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(771)
			p.Match(PandaParserInt64)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(772)
			p.Match(PandaParserUint8)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(773)
			p.Match(PandaParserUint16)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(774)
			p.Match(PandaParserUint32)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(775)
			p.Match(PandaParserUint64)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(776)
			p.Match(PandaParserInt)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(777)
			p.Match(PandaParserUint)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(778)
			p.Match(PandaParserShort)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(779)
			p.Match(PandaParserUshort)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(780)
			p.Match(PandaParserLong)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(781)
			p.Match(PandaParserUlong)
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(782)
			p.Match(PandaParserFloat32)
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(783)
			p.Match(PandaParserFloat64)
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(784)
			p.Match(PandaParserFloat)
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(785)
			p.Match(PandaParserDouble)
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(786)
			p.Match(PandaParserVoid)
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(787)
			p.Match(PandaParserAuto)
		}

	}

	return localctx
}

// IType_nameContext is an interface to support dynamic dispatch.
type IType_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_nameContext differentiates from other interfaces.
	IsType_nameContext()
}

type Type_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_nameContext() *Type_nameContext {
	var p = new(Type_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_name
	return p
}

func (*Type_nameContext) IsType_nameContext() {}

func NewType_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_nameContext {
	var p = new(Type_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_name

	return p
}

func (s *Type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_nameContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Type_nameContext) Enum_name() IEnum_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_nameContext)
}

func (s *Type_nameContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_name(s)
	}
}

func (s *Type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_name(s)
	}
}

func (p *PandaParser) Type_name() (localctx IType_nameContext) {
	localctx = NewType_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, PandaParserRULE_type_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(790)
			p.Class_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(791)
			p.Enum_name()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(792)
			p.Template_id()
		}

	}

	return localctx
}

// IEnum_nameContext is an interface to support dynamic dispatch.
type IEnum_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_nameContext differentiates from other interfaces.
	IsEnum_nameContext()
}

type Enum_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_nameContext() *Enum_nameContext {
	var p = new(Enum_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enum_name
	return p
}

func (*Enum_nameContext) IsEnum_nameContext() {}

func NewEnum_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_nameContext {
	var p = new(Enum_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enum_name

	return p
}

func (s *Enum_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_nameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Enum_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnum_name(s)
	}
}

func (s *Enum_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnum_name(s)
	}
}

func (p *PandaParser) Enum_name() (localctx IEnum_nameContext) {
	localctx = NewEnum_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, PandaParserRULE_enum_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		p.Match(PandaParserIdentifier)
	}

	return localctx
}

// IEnum_specifierContext is an interface to support dynamic dispatch.
type IEnum_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_specifierContext differentiates from other interfaces.
	IsEnum_specifierContext()
}

type Enum_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_specifierContext() *Enum_specifierContext {
	var p = new(Enum_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enum_specifier
	return p
}

func (*Enum_specifierContext) IsEnum_specifierContext() {}

func NewEnum_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_specifierContext {
	var p = new(Enum_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enum_specifier

	return p
}

func (s *Enum_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_specifierContext) Enum_head() IEnum_headContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_headContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_headContext)
}

func (s *Enum_specifierContext) Enumerator_list() IEnumerator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerator_listContext)
}

func (s *Enum_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnum_specifier(s)
	}
}

func (s *Enum_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnum_specifier(s)
	}
}

func (p *PandaParser) Enum_specifier() (localctx IEnum_specifierContext) {
	localctx = NewEnum_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, PandaParserRULE_enum_specifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(797)
			p.Enum_head()
		}
		{
			p.SetState(798)
			p.Match(PandaParserLeftBrace)
		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserIdentifier {
			{
				p.SetState(799)
				p.enumerator_list(0)
			}

		}
		{
			p.SetState(802)
			p.Match(PandaParserRightBrace)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(804)
			p.Enum_head()
		}
		{
			p.SetState(805)
			p.Match(PandaParserLeftBrace)
		}
		{
			p.SetState(806)
			p.enumerator_list(0)
		}
		{
			p.SetState(807)
			p.Match(PandaParserComma)
		}
		{
			p.SetState(808)
			p.Match(PandaParserRightBrace)
		}

	}

	return localctx
}

// IEnum_headContext is an interface to support dynamic dispatch.
type IEnum_headContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_headContext differentiates from other interfaces.
	IsEnum_headContext()
}

type Enum_headContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_headContext() *Enum_headContext {
	var p = new(Enum_headContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enum_head
	return p
}

func (*Enum_headContext) IsEnum_headContext() {}

func NewEnum_headContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_headContext {
	var p = new(Enum_headContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enum_head

	return p
}

func (s *Enum_headContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_headContext) Enum_key() IEnum_keyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_keyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_keyContext)
}

func (s *Enum_headContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Enum_headContext) Enum_base() IEnum_baseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_baseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_baseContext)
}

func (s *Enum_headContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_headContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_headContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnum_head(s)
	}
}

func (s *Enum_headContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnum_head(s)
	}
}

func (p *PandaParser) Enum_head() (localctx IEnum_headContext) {
	localctx = NewEnum_headContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, PandaParserRULE_enum_head)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.Enum_key()
	}
	p.SetState(814)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserIdentifier {
		{
			p.SetState(813)
			p.Match(PandaParserIdentifier)
		}

	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserColon {
		{
			p.SetState(816)
			p.Enum_base()
		}

	}

	return localctx
}

// IEnum_keyContext is an interface to support dynamic dispatch.
type IEnum_keyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_keyContext differentiates from other interfaces.
	IsEnum_keyContext()
}

type Enum_keyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_keyContext() *Enum_keyContext {
	var p = new(Enum_keyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enum_key
	return p
}

func (*Enum_keyContext) IsEnum_keyContext() {}

func NewEnum_keyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_keyContext {
	var p = new(Enum_keyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enum_key

	return p
}

func (s *Enum_keyContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_keyContext) Enum() antlr.TerminalNode {
	return s.GetToken(PandaParserEnum, 0)
}

func (s *Enum_keyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_keyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_keyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnum_key(s)
	}
}

func (s *Enum_keyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnum_key(s)
	}
}

func (p *PandaParser) Enum_key() (localctx IEnum_keyContext) {
	localctx = NewEnum_keyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, PandaParserRULE_enum_key)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.Match(PandaParserEnum)
	}

	return localctx
}

// IEnum_baseContext is an interface to support dynamic dispatch.
type IEnum_baseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_baseContext differentiates from other interfaces.
	IsEnum_baseContext()
}

type Enum_baseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_baseContext() *Enum_baseContext {
	var p = new(Enum_baseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enum_base
	return p
}

func (*Enum_baseContext) IsEnum_baseContext() {}

func NewEnum_baseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_baseContext {
	var p = new(Enum_baseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enum_base

	return p
}

func (s *Enum_baseContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_baseContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *Enum_baseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_baseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_baseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnum_base(s)
	}
}

func (s *Enum_baseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnum_base(s)
	}
}

func (p *PandaParser) Enum_base() (localctx IEnum_baseContext) {
	localctx = NewEnum_baseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, PandaParserRULE_enum_base)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.Match(PandaParserColon)
	}
	{
		p.SetState(822)
		p.Type_specifier_sequence()
	}

	return localctx
}

// IEnumerator_listContext is an interface to support dynamic dispatch.
type IEnumerator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerator_listContext differentiates from other interfaces.
	IsEnumerator_listContext()
}

type Enumerator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerator_listContext() *Enumerator_listContext {
	var p = new(Enumerator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enumerator_list
	return p
}

func (*Enumerator_listContext) IsEnumerator_listContext() {}

func NewEnumerator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumerator_listContext {
	var p = new(Enumerator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enumerator_list

	return p
}

func (s *Enumerator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumerator_listContext) Enumerator_definition() IEnumerator_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerator_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerator_definitionContext)
}

func (s *Enumerator_listContext) Enumerator_list() IEnumerator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerator_listContext)
}

func (s *Enumerator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumerator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enumerator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnumerator_list(s)
	}
}

func (s *Enumerator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnumerator_list(s)
	}
}

func (p *PandaParser) Enumerator_list() (localctx IEnumerator_listContext) {
	return p.enumerator_list(0)
}

func (p *PandaParser) enumerator_list(_p int) (localctx IEnumerator_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewEnumerator_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEnumerator_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, PandaParserRULE_enumerator_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.Enumerator_definition()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewEnumerator_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_enumerator_list)
			p.SetState(827)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(828)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(829)
				p.Enumerator_definition()
			}

		}
		p.SetState(834)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumerator_definitionContext is an interface to support dynamic dispatch.
type IEnumerator_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerator_definitionContext differentiates from other interfaces.
	IsEnumerator_definitionContext()
}

type Enumerator_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerator_definitionContext() *Enumerator_definitionContext {
	var p = new(Enumerator_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enumerator_definition
	return p
}

func (*Enumerator_definitionContext) IsEnumerator_definitionContext() {}

func NewEnumerator_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumerator_definitionContext {
	var p = new(Enumerator_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enumerator_definition

	return p
}

func (s *Enumerator_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumerator_definitionContext) Enumerator() IEnumeratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *Enumerator_definitionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Enumerator_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumerator_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enumerator_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnumerator_definition(s)
	}
}

func (s *Enumerator_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnumerator_definition(s)
	}
}

func (p *PandaParser) Enumerator_definition() (localctx IEnumerator_definitionContext) {
	localctx = NewEnumerator_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, PandaParserRULE_enumerator_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(835)
			p.Enumerator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(836)
			p.Enumerator()
		}
		{
			p.SetState(837)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(838)
			p.Constant_expression()
		}

	}

	return localctx
}

// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enumerator
	return p
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnumerator(s)
	}
}

func (s *EnumeratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnumerator(s)
	}
}

func (p *PandaParser) Enumerator() (localctx IEnumeratorContext) {
	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, PandaParserRULE_enumerator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(842)
		p.Match(PandaParserIdentifier)
	}

	return localctx
}

// INamespace_nameContext is an interface to support dynamic dispatch.
type INamespace_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespace_nameContext differentiates from other interfaces.
	IsNamespace_nameContext()
}

type Namespace_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespace_nameContext() *Namespace_nameContext {
	var p = new(Namespace_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_namespace_name
	return p
}

func (*Namespace_nameContext) IsNamespace_nameContext() {}

func NewNamespace_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Namespace_nameContext {
	var p = new(Namespace_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_namespace_name

	return p
}

func (s *Namespace_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Namespace_nameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Namespace_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Namespace_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Namespace_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNamespace_name(s)
	}
}

func (s *Namespace_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNamespace_name(s)
	}
}

func (p *PandaParser) Namespace_name() (localctx INamespace_nameContext) {
	localctx = NewNamespace_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, PandaParserRULE_namespace_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.Match(PandaParserIdentifier)
	}

	return localctx
}

// INamespace_definitionContext is an interface to support dynamic dispatch.
type INamespace_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespace_definitionContext differentiates from other interfaces.
	IsNamespace_definitionContext()
}

type Namespace_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespace_definitionContext() *Namespace_definitionContext {
	var p = new(Namespace_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_namespace_definition
	return p
}

func (*Namespace_definitionContext) IsNamespace_definitionContext() {}

func NewNamespace_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Namespace_definitionContext {
	var p = new(Namespace_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_namespace_definition

	return p
}

func (s *Namespace_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Namespace_definitionContext) Named_namespace_definition() INamed_namespace_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamed_namespace_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamed_namespace_definitionContext)
}

func (s *Namespace_definitionContext) Unnamed_namespace_definition() IUnnamed_namespace_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnnamed_namespace_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnnamed_namespace_definitionContext)
}

func (s *Namespace_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Namespace_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Namespace_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNamespace_definition(s)
	}
}

func (s *Namespace_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNamespace_definition(s)
	}
}

func (p *PandaParser) Namespace_definition() (localctx INamespace_definitionContext) {
	localctx = NewNamespace_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, PandaParserRULE_namespace_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(846)
			p.Named_namespace_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(847)
			p.Unnamed_namespace_definition()
		}

	}

	return localctx
}

// INamed_namespace_definitionContext is an interface to support dynamic dispatch.
type INamed_namespace_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamed_namespace_definitionContext differentiates from other interfaces.
	IsNamed_namespace_definitionContext()
}

type Named_namespace_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamed_namespace_definitionContext() *Named_namespace_definitionContext {
	var p = new(Named_namespace_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_named_namespace_definition
	return p
}

func (*Named_namespace_definitionContext) IsNamed_namespace_definitionContext() {}

func NewNamed_namespace_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Named_namespace_definitionContext {
	var p = new(Named_namespace_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_named_namespace_definition

	return p
}

func (s *Named_namespace_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Named_namespace_definitionContext) Original_namespace_definition() IOriginal_namespace_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOriginal_namespace_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOriginal_namespace_definitionContext)
}

func (s *Named_namespace_definitionContext) Extension_namespace_definition() IExtension_namespace_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtension_namespace_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtension_namespace_definitionContext)
}

func (s *Named_namespace_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Named_namespace_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Named_namespace_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNamed_namespace_definition(s)
	}
}

func (s *Named_namespace_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNamed_namespace_definition(s)
	}
}

func (p *PandaParser) Named_namespace_definition() (localctx INamed_namespace_definitionContext) {
	localctx = NewNamed_namespace_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, PandaParserRULE_named_namespace_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(850)
			p.Original_namespace_definition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(851)
			p.Extension_namespace_definition()
		}

	}

	return localctx
}

// IOriginal_namespace_definitionContext is an interface to support dynamic dispatch.
type IOriginal_namespace_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOriginal_namespace_definitionContext differentiates from other interfaces.
	IsOriginal_namespace_definitionContext()
}

type Original_namespace_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOriginal_namespace_definitionContext() *Original_namespace_definitionContext {
	var p = new(Original_namespace_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_original_namespace_definition
	return p
}

func (*Original_namespace_definitionContext) IsOriginal_namespace_definitionContext() {}

func NewOriginal_namespace_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Original_namespace_definitionContext {
	var p = new(Original_namespace_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_original_namespace_definition

	return p
}

func (s *Original_namespace_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Original_namespace_definitionContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PandaParserNamespace, 0)
}

func (s *Original_namespace_definitionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Original_namespace_definitionContext) Namespace_body() INamespace_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_bodyContext)
}

func (s *Original_namespace_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Original_namespace_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Original_namespace_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterOriginal_namespace_definition(s)
	}
}

func (s *Original_namespace_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitOriginal_namespace_definition(s)
	}
}

func (p *PandaParser) Original_namespace_definition() (localctx IOriginal_namespace_definitionContext) {
	localctx = NewOriginal_namespace_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, PandaParserRULE_original_namespace_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(854)
		p.Match(PandaParserNamespace)
	}
	{
		p.SetState(855)
		p.Match(PandaParserIdentifier)
	}
	{
		p.SetState(856)
		p.Match(PandaParserLeftBrace)
	}
	{
		p.SetState(857)
		p.Namespace_body()
	}
	{
		p.SetState(858)
		p.Match(PandaParserRightBrace)
	}

	return localctx
}

// IExtension_namespace_definitionContext is an interface to support dynamic dispatch.
type IExtension_namespace_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtension_namespace_definitionContext differentiates from other interfaces.
	IsExtension_namespace_definitionContext()
}

type Extension_namespace_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtension_namespace_definitionContext() *Extension_namespace_definitionContext {
	var p = new(Extension_namespace_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_extension_namespace_definition
	return p
}

func (*Extension_namespace_definitionContext) IsExtension_namespace_definitionContext() {}

func NewExtension_namespace_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extension_namespace_definitionContext {
	var p = new(Extension_namespace_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_extension_namespace_definition

	return p
}

func (s *Extension_namespace_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Extension_namespace_definitionContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PandaParserNamespace, 0)
}

func (s *Extension_namespace_definitionContext) Namespace_name() INamespace_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Extension_namespace_definitionContext) Namespace_body() INamespace_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_bodyContext)
}

func (s *Extension_namespace_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extension_namespace_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Extension_namespace_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterExtension_namespace_definition(s)
	}
}

func (s *Extension_namespace_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitExtension_namespace_definition(s)
	}
}

func (p *PandaParser) Extension_namespace_definition() (localctx IExtension_namespace_definitionContext) {
	localctx = NewExtension_namespace_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, PandaParserRULE_extension_namespace_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.Match(PandaParserNamespace)
	}
	{
		p.SetState(861)
		p.Namespace_name()
	}
	{
		p.SetState(862)
		p.Match(PandaParserLeftBrace)
	}
	{
		p.SetState(863)
		p.Namespace_body()
	}
	{
		p.SetState(864)
		p.Match(PandaParserRightBrace)
	}

	return localctx
}

// IUnnamed_namespace_definitionContext is an interface to support dynamic dispatch.
type IUnnamed_namespace_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnnamed_namespace_definitionContext differentiates from other interfaces.
	IsUnnamed_namespace_definitionContext()
}

type Unnamed_namespace_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnnamed_namespace_definitionContext() *Unnamed_namespace_definitionContext {
	var p = new(Unnamed_namespace_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_unnamed_namespace_definition
	return p
}

func (*Unnamed_namespace_definitionContext) IsUnnamed_namespace_definitionContext() {}

func NewUnnamed_namespace_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unnamed_namespace_definitionContext {
	var p = new(Unnamed_namespace_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_unnamed_namespace_definition

	return p
}

func (s *Unnamed_namespace_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unnamed_namespace_definitionContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PandaParserNamespace, 0)
}

func (s *Unnamed_namespace_definitionContext) Namespace_body() INamespace_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_bodyContext)
}

func (s *Unnamed_namespace_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unnamed_namespace_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unnamed_namespace_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterUnnamed_namespace_definition(s)
	}
}

func (s *Unnamed_namespace_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitUnnamed_namespace_definition(s)
	}
}

func (p *PandaParser) Unnamed_namespace_definition() (localctx IUnnamed_namespace_definitionContext) {
	localctx = NewUnnamed_namespace_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, PandaParserRULE_unnamed_namespace_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.Match(PandaParserNamespace)
	}
	{
		p.SetState(867)
		p.Match(PandaParserLeftBrace)
	}
	{
		p.SetState(868)
		p.Namespace_body()
	}
	{
		p.SetState(869)
		p.Match(PandaParserRightBrace)
	}

	return localctx
}

// INamespace_bodyContext is an interface to support dynamic dispatch.
type INamespace_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespace_bodyContext differentiates from other interfaces.
	IsNamespace_bodyContext()
}

type Namespace_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespace_bodyContext() *Namespace_bodyContext {
	var p = new(Namespace_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_namespace_body
	return p
}

func (*Namespace_bodyContext) IsNamespace_bodyContext() {}

func NewNamespace_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Namespace_bodyContext {
	var p = new(Namespace_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_namespace_body

	return p
}

func (s *Namespace_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Namespace_bodyContext) Declaration_sequence() IDeclaration_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_sequenceContext)
}

func (s *Namespace_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Namespace_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Namespace_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNamespace_body(s)
	}
}

func (s *Namespace_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNamespace_body(s)
	}
}

func (p *PandaParser) Namespace_body() (localctx INamespace_bodyContext) {
	localctx = NewNamespace_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, PandaParserRULE_namespace_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(872)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserClass)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNamespace)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserUsing-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserAnd-36)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(PandaParserSemi-93))|(1<<(PandaParserEllipsis-93))|(1<<(PandaParserIdentifier-93)))) != 0) {
		{
			p.SetState(871)
			p.declaration_sequence(0)
		}

	}

	return localctx
}

// IQualified_namespace_specifierContext is an interface to support dynamic dispatch.
type IQualified_namespace_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualified_namespace_specifierContext differentiates from other interfaces.
	IsQualified_namespace_specifierContext()
}

type Qualified_namespace_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualified_namespace_specifierContext() *Qualified_namespace_specifierContext {
	var p = new(Qualified_namespace_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_qualified_namespace_specifier
	return p
}

func (*Qualified_namespace_specifierContext) IsQualified_namespace_specifierContext() {}

func NewQualified_namespace_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualified_namespace_specifierContext {
	var p = new(Qualified_namespace_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_qualified_namespace_specifier

	return p
}

func (s *Qualified_namespace_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualified_namespace_specifierContext) Namespace_name() INamespace_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Qualified_namespace_specifierContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Qualified_namespace_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualified_namespace_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qualified_namespace_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterQualified_namespace_specifier(s)
	}
}

func (s *Qualified_namespace_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitQualified_namespace_specifier(s)
	}
}

func (p *PandaParser) Qualified_namespace_specifier() (localctx IQualified_namespace_specifierContext) {
	localctx = NewQualified_namespace_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, PandaParserRULE_qualified_namespace_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(875)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(874)
			p.nested_name_specifier(0)
		}

	}
	{
		p.SetState(877)
		p.Namespace_name()
	}

	return localctx
}

// IUsing_namespaceContext is an interface to support dynamic dispatch.
type IUsing_namespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsing_namespaceContext differentiates from other interfaces.
	IsUsing_namespaceContext()
}

type Using_namespaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_namespaceContext() *Using_namespaceContext {
	var p = new(Using_namespaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_using_namespace
	return p
}

func (*Using_namespaceContext) IsUsing_namespaceContext() {}

func NewUsing_namespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_namespaceContext {
	var p = new(Using_namespaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_using_namespace

	return p
}

func (s *Using_namespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_namespaceContext) Using() antlr.TerminalNode {
	return s.GetToken(PandaParserUsing, 0)
}

func (s *Using_namespaceContext) Namespace_name() INamespace_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Using_namespaceContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Using_namespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_namespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Using_namespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterUsing_namespace(s)
	}
}

func (s *Using_namespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitUsing_namespace(s)
	}
}

func (p *PandaParser) Using_namespace() (localctx IUsing_namespaceContext) {
	localctx = NewUsing_namespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, PandaParserRULE_using_namespace)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Match(PandaParserUsing)
	}
	p.SetState(881)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(880)
			p.nested_name_specifier(0)
		}

	}
	{
		p.SetState(883)
		p.Namespace_name()
	}
	{
		p.SetState(884)
		p.Match(PandaParserSemi)
	}

	return localctx
}

// IInit_declarator_listContext is an interface to support dynamic dispatch.
type IInit_declarator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declarator_listContext differentiates from other interfaces.
	IsInit_declarator_listContext()
}

type Init_declarator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declarator_listContext() *Init_declarator_listContext {
	var p = new(Init_declarator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_init_declarator_list
	return p
}

func (*Init_declarator_listContext) IsInit_declarator_listContext() {}

func NewInit_declarator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declarator_listContext {
	var p = new(Init_declarator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_init_declarator_list

	return p
}

func (s *Init_declarator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declarator_listContext) Init_declarator() IInit_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declaratorContext)
}

func (s *Init_declarator_listContext) Init_declarator_list() IInit_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declarator_listContext)
}

func (s *Init_declarator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declarator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_declarator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInit_declarator_list(s)
	}
}

func (s *Init_declarator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInit_declarator_list(s)
	}
}

func (p *PandaParser) Init_declarator_list() (localctx IInit_declarator_listContext) {
	return p.init_declarator_list(0)
}

func (p *PandaParser) init_declarator_list(_p int) (localctx IInit_declarator_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInit_declarator_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInit_declarator_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 146
	p.EnterRecursionRule(localctx, 146, PandaParserRULE_init_declarator_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(887)
		p.Init_declarator()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInit_declarator_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_init_declarator_list)
			p.SetState(889)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(890)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(891)
				p.Init_declarator()
			}

		}
		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())
	}

	return localctx
}

// IInit_declaratorContext is an interface to support dynamic dispatch.
type IInit_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declaratorContext differentiates from other interfaces.
	IsInit_declaratorContext()
}

type Init_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declaratorContext() *Init_declaratorContext {
	var p = new(Init_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_init_declarator
	return p
}

func (*Init_declaratorContext) IsInit_declaratorContext() {}

func NewInit_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declaratorContext {
	var p = new(Init_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_init_declarator

	return p
}

func (s *Init_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Init_declaratorContext) Initializer() IInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *Init_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInit_declarator(s)
	}
}

func (s *Init_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInit_declarator(s)
	}
}

func (p *PandaParser) Init_declarator() (localctx IInit_declaratorContext) {
	localctx = NewInit_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, PandaParserRULE_init_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.Declarator()
	}
	p.SetState(899)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(898)
			p.Initializer()
		}

	}

	return localctx
}

// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declarator
	return p
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) Ptr_declarator() IPtr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPtr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPtr_declaratorContext)
}

func (s *DeclaratorContext) Noptr_declarator() INoptr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INoptr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INoptr_declaratorContext)
}

func (s *DeclaratorContext) Parameters_and_qualifiers() IParameters_and_qualifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameters_and_qualifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameters_and_qualifiersContext)
}

func (s *DeclaratorContext) Trailing_return_type() ITrailing_return_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailing_return_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrailing_return_typeContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclarator(s)
	}
}

func (s *DeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclarator(s)
	}
}

func (p *PandaParser) Declarator() (localctx IDeclaratorContext) {
	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, PandaParserRULE_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(901)
			p.Ptr_declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(902)
			p.noptr_declarator(0)
		}
		{
			p.SetState(903)
			p.Parameters_and_qualifiers()
		}
		{
			p.SetState(904)
			p.Trailing_return_type()
		}

	}

	return localctx
}

// IPtr_declaratorContext is an interface to support dynamic dispatch.
type IPtr_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPtr_declaratorContext differentiates from other interfaces.
	IsPtr_declaratorContext()
}

type Ptr_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPtr_declaratorContext() *Ptr_declaratorContext {
	var p = new(Ptr_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_ptr_declarator
	return p
}

func (*Ptr_declaratorContext) IsPtr_declaratorContext() {}

func NewPtr_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ptr_declaratorContext {
	var p = new(Ptr_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_ptr_declarator

	return p
}

func (s *Ptr_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Ptr_declaratorContext) Noptr_declarator() INoptr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INoptr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INoptr_declaratorContext)
}

func (s *Ptr_declaratorContext) Ref_operator() IRef_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRef_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRef_operatorContext)
}

func (s *Ptr_declaratorContext) Ptr_declarator() IPtr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPtr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPtr_declaratorContext)
}

func (s *Ptr_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ptr_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ptr_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterPtr_declarator(s)
	}
}

func (s *Ptr_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitPtr_declarator(s)
	}
}

func (p *PandaParser) Ptr_declarator() (localctx IPtr_declaratorContext) {
	localctx = NewPtr_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, PandaParserRULE_ptr_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(912)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserOperator, PandaParserLeftParen, PandaParserEllipsis, PandaParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(908)
			p.noptr_declarator(0)
		}

	case PandaParserAnd:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(909)
			p.Ref_operator()
		}
		{
			p.SetState(910)
			p.Ptr_declarator()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INoptr_declaratorContext is an interface to support dynamic dispatch.
type INoptr_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNoptr_declaratorContext differentiates from other interfaces.
	IsNoptr_declaratorContext()
}

type Noptr_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoptr_declaratorContext() *Noptr_declaratorContext {
	var p = new(Noptr_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_noptr_declarator
	return p
}

func (*Noptr_declaratorContext) IsNoptr_declaratorContext() {}

func NewNoptr_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Noptr_declaratorContext {
	var p = new(Noptr_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_noptr_declarator

	return p
}

func (s *Noptr_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Noptr_declaratorContext) Declarator_id() IDeclarator_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarator_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarator_idContext)
}

func (s *Noptr_declaratorContext) Ptr_declarator() IPtr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPtr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPtr_declaratorContext)
}

func (s *Noptr_declaratorContext) Noptr_declarator() INoptr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INoptr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INoptr_declaratorContext)
}

func (s *Noptr_declaratorContext) Parameters_and_qualifiers() IParameters_and_qualifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameters_and_qualifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameters_and_qualifiersContext)
}

func (s *Noptr_declaratorContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Noptr_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Noptr_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Noptr_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNoptr_declarator(s)
	}
}

func (s *Noptr_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNoptr_declarator(s)
	}
}

func (p *PandaParser) Noptr_declarator() (localctx INoptr_declaratorContext) {
	return p.noptr_declarator(0)
}

func (p *PandaParser) noptr_declarator(_p int) (localctx INoptr_declaratorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewNoptr_declaratorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INoptr_declaratorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 154
	p.EnterRecursionRule(localctx, 154, PandaParserRULE_noptr_declarator, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(920)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserOperator, PandaParserEllipsis, PandaParserIdentifier:
		{
			p.SetState(915)
			p.Declarator_id()
		}

	case PandaParserLeftParen:
		{
			p.SetState(916)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(917)
			p.Ptr_declarator()
		}
		{
			p.SetState(918)
			p.Match(PandaParserRightParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(930)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
			case 1:
				localctx = NewNoptr_declaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_noptr_declarator)
				p.SetState(922)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(923)
					p.Parameters_and_qualifiers()
				}

			case 2:
				localctx = NewNoptr_declaratorContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_noptr_declarator)
				p.SetState(924)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(925)
					p.Match(PandaParserLeftBracket)
				}
				p.SetState(927)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
					{
						p.SetState(926)
						p.Constant_expression()
					}

				}
				{
					p.SetState(929)
					p.Match(PandaParserRightBracket)
				}

			}

		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
	}

	return localctx
}

// IParameters_and_qualifiersContext is an interface to support dynamic dispatch.
type IParameters_and_qualifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameters_and_qualifiersContext differentiates from other interfaces.
	IsParameters_and_qualifiersContext()
}

type Parameters_and_qualifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameters_and_qualifiersContext() *Parameters_and_qualifiersContext {
	var p = new(Parameters_and_qualifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_parameters_and_qualifiers
	return p
}

func (*Parameters_and_qualifiersContext) IsParameters_and_qualifiersContext() {}

func NewParameters_and_qualifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameters_and_qualifiersContext {
	var p = new(Parameters_and_qualifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_parameters_and_qualifiers

	return p
}

func (s *Parameters_and_qualifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameters_and_qualifiersContext) Parameter_declaration_clause() IParameter_declaration_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_clauseContext)
}

func (s *Parameters_and_qualifiersContext) Ref_qualifier() IRef_qualifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRef_qualifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRef_qualifierContext)
}

func (s *Parameters_and_qualifiersContext) Exception_specification() IException_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_specificationContext)
}

func (s *Parameters_and_qualifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameters_and_qualifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameters_and_qualifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterParameters_and_qualifiers(s)
	}
}

func (s *Parameters_and_qualifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitParameters_and_qualifiers(s)
	}
}

func (p *PandaParser) Parameters_and_qualifiers() (localctx IParameters_and_qualifiersContext) {
	localctx = NewParameters_and_qualifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, PandaParserRULE_parameters_and_qualifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		p.Match(PandaParserLeftParen)
	}
	{
		p.SetState(936)
		p.Parameter_declaration_clause()
	}
	{
		p.SetState(937)
		p.Match(PandaParserRightParen)
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(938)
			p.Ref_qualifier()
		}

	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(941)
			p.Exception_specification()
		}

	}

	return localctx
}

// ITrailing_return_typeContext is an interface to support dynamic dispatch.
type ITrailing_return_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTrailing_return_typeContext differentiates from other interfaces.
	IsTrailing_return_typeContext()
}

type Trailing_return_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailing_return_typeContext() *Trailing_return_typeContext {
	var p = new(Trailing_return_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_trailing_return_type
	return p
}

func (*Trailing_return_typeContext) IsTrailing_return_typeContext() {}

func NewTrailing_return_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Trailing_return_typeContext {
	var p = new(Trailing_return_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_trailing_return_type

	return p
}

func (s *Trailing_return_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Trailing_return_typeContext) Trailing_type_specifier_sequence() ITrailing_type_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITrailing_type_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITrailing_type_specifier_sequenceContext)
}

func (s *Trailing_return_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Trailing_return_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Trailing_return_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTrailing_return_type(s)
	}
}

func (s *Trailing_return_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTrailing_return_type(s)
	}
}

func (p *PandaParser) Trailing_return_type() (localctx ITrailing_return_typeContext) {
	localctx = NewTrailing_return_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, PandaParserRULE_trailing_return_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Match(PandaParserArrow)
	}
	{
		p.SetState(945)
		p.Trailing_type_specifier_sequence()
	}

	return localctx
}

// IRef_operatorContext is an interface to support dynamic dispatch.
type IRef_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRef_operatorContext differentiates from other interfaces.
	IsRef_operatorContext()
}

type Ref_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRef_operatorContext() *Ref_operatorContext {
	var p = new(Ref_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_ref_operator
	return p
}

func (*Ref_operatorContext) IsRef_operatorContext() {}

func NewRef_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ref_operatorContext {
	var p = new(Ref_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_ref_operator

	return p
}

func (s *Ref_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Ref_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ref_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ref_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterRef_operator(s)
	}
}

func (s *Ref_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitRef_operator(s)
	}
}

func (p *PandaParser) Ref_operator() (localctx IRef_operatorContext) {
	localctx = NewRef_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, PandaParserRULE_ref_operator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(947)
		p.Match(PandaParserAnd)
	}

	return localctx
}

// IRef_qualifierContext is an interface to support dynamic dispatch.
type IRef_qualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRef_qualifierContext differentiates from other interfaces.
	IsRef_qualifierContext()
}

type Ref_qualifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRef_qualifierContext() *Ref_qualifierContext {
	var p = new(Ref_qualifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_ref_qualifier
	return p
}

func (*Ref_qualifierContext) IsRef_qualifierContext() {}

func NewRef_qualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ref_qualifierContext {
	var p = new(Ref_qualifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_ref_qualifier

	return p
}

func (s *Ref_qualifierContext) GetParser() antlr.Parser { return s.parser }
func (s *Ref_qualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ref_qualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ref_qualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterRef_qualifier(s)
	}
}

func (s *Ref_qualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitRef_qualifier(s)
	}
}

func (p *PandaParser) Ref_qualifier() (localctx IRef_qualifierContext) {
	localctx = NewRef_qualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, PandaParserRULE_ref_qualifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(949)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PandaParserAnd || _la == PandaParserAndAnd) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDeclarator_idContext is an interface to support dynamic dispatch.
type IDeclarator_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarator_idContext differentiates from other interfaces.
	IsDeclarator_idContext()
}

type Declarator_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarator_idContext() *Declarator_idContext {
	var p = new(Declarator_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declarator_id
	return p
}

func (*Declarator_idContext) IsDeclarator_idContext() {}

func NewDeclarator_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declarator_idContext {
	var p = new(Declarator_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declarator_id

	return p
}

func (s *Declarator_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Declarator_idContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Declarator_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declarator_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declarator_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclarator_id(s)
	}
}

func (s *Declarator_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclarator_id(s)
	}
}

func (p *PandaParser) Declarator_id() (localctx IDeclarator_idContext) {
	localctx = NewDeclarator_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, PandaParserRULE_declarator_id)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserEllipsis {
		{
			p.SetState(951)
			p.Match(PandaParserEllipsis)
		}

	}
	{
		p.SetState(954)
		p.Id_expression()
	}

	return localctx
}

// IType_idContext is an interface to support dynamic dispatch.
type IType_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_idContext differentiates from other interfaces.
	IsType_idContext()
}

type Type_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_idContext() *Type_idContext {
	var p = new(Type_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_id
	return p
}

func (*Type_idContext) IsType_idContext() {}

func NewType_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_idContext {
	var p = new(Type_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_id

	return p
}

func (s *Type_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_idContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *Type_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_id(s)
	}
}

func (s *Type_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_id(s)
	}
}

func (p *PandaParser) Type_id() (localctx IType_idContext) {
	localctx = NewType_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, PandaParserRULE_type_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.Type_specifier_sequence()
	}

	return localctx
}

// IParameter_declaration_clauseContext is an interface to support dynamic dispatch.
type IParameter_declaration_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declaration_clauseContext differentiates from other interfaces.
	IsParameter_declaration_clauseContext()
}

type Parameter_declaration_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declaration_clauseContext() *Parameter_declaration_clauseContext {
	var p = new(Parameter_declaration_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_parameter_declaration_clause
	return p
}

func (*Parameter_declaration_clauseContext) IsParameter_declaration_clauseContext() {}

func NewParameter_declaration_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declaration_clauseContext {
	var p = new(Parameter_declaration_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_parameter_declaration_clause

	return p
}

func (s *Parameter_declaration_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declaration_clauseContext) Parameter_declaration_list() IParameter_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_listContext)
}

func (s *Parameter_declaration_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declaration_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declaration_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterParameter_declaration_clause(s)
	}
}

func (s *Parameter_declaration_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitParameter_declaration_clause(s)
	}
}

func (p *PandaParser) Parameter_declaration_clause() (localctx IParameter_declaration_clauseContext) {
	localctx = NewParameter_declaration_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, PandaParserRULE_parameter_declaration_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(968)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserClass)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36)))) != 0) || _la == PandaParserIdentifier {
			{
				p.SetState(958)
				p.parameter_declaration_list(0)
			}

		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserEllipsis {
			{
				p.SetState(961)
				p.Match(PandaParserEllipsis)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(964)
			p.parameter_declaration_list(0)
		}
		{
			p.SetState(965)
			p.Match(PandaParserComma)
		}
		{
			p.SetState(966)
			p.Match(PandaParserEllipsis)
		}

	}

	return localctx
}

// IParameter_declaration_listContext is an interface to support dynamic dispatch.
type IParameter_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declaration_listContext differentiates from other interfaces.
	IsParameter_declaration_listContext()
}

type Parameter_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declaration_listContext() *Parameter_declaration_listContext {
	var p = new(Parameter_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_parameter_declaration_list
	return p
}

func (*Parameter_declaration_listContext) IsParameter_declaration_listContext() {}

func NewParameter_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declaration_listContext {
	var p = new(Parameter_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_parameter_declaration_list

	return p
}

func (s *Parameter_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declaration_listContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Parameter_declaration_listContext) Parameter_declaration_list() IParameter_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_listContext)
}

func (s *Parameter_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterParameter_declaration_list(s)
	}
}

func (s *Parameter_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitParameter_declaration_list(s)
	}
}

func (p *PandaParser) Parameter_declaration_list() (localctx IParameter_declaration_listContext) {
	return p.parameter_declaration_list(0)
}

func (p *PandaParser) parameter_declaration_list(_p int) (localctx IParameter_declaration_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewParameter_declaration_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IParameter_declaration_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 170
	p.EnterRecursionRule(localctx, 170, PandaParserRULE_parameter_declaration_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(971)
		p.Parameter_declaration()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(978)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewParameter_declaration_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_parameter_declaration_list)
			p.SetState(973)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(974)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(975)
				p.Parameter_declaration()
			}

		}
		p.SetState(980)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())
	}

	return localctx
}

// IParameter_declarationContext is an interface to support dynamic dispatch.
type IParameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declarationContext differentiates from other interfaces.
	IsParameter_declarationContext()
}

type Parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declarationContext() *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_parameter_declaration
	return p
}

func (*Parameter_declarationContext) IsParameter_declarationContext() {}

func NewParameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_parameter_declaration

	return p
}

func (s *Parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declarationContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Parameter_declarationContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Parameter_declarationContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *Parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitParameter_declaration(s)
	}
}

func (p *PandaParser) Parameter_declaration() (localctx IParameter_declarationContext) {
	localctx = NewParameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, PandaParserRULE_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(981)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(982)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(984)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(985)
			p.Declarator()
		}
		{
			p.SetState(986)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(987)
			p.Initializer_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(989)
			p.Decl_specifier_sequence()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(990)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(991)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(992)
			p.Initializer_clause()
		}

	}

	return localctx
}

// IFunction_definitionContext is an interface to support dynamic dispatch.
type IFunction_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definitionContext differentiates from other interfaces.
	IsFunction_definitionContext()
}

type Function_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definitionContext() *Function_definitionContext {
	var p = new(Function_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_function_definition
	return p
}

func (*Function_definitionContext) IsFunction_definitionContext() {}

func NewFunction_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definitionContext {
	var p = new(Function_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_function_definition

	return p
}

func (s *Function_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definitionContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Function_definitionContext) Function_body() IFunction_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_bodyContext)
}

func (s *Function_definitionContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Function_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFunction_definition(s)
	}
}

func (s *Function_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFunction_definition(s)
	}
}

func (p *PandaParser) Function_definition() (localctx IFunction_definitionContext) {
	localctx = NewFunction_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, PandaParserRULE_function_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(997)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(996)
			p.Decl_specifier_sequence()
		}

	}
	{
		p.SetState(999)
		p.Declarator()
	}
	{
		p.SetState(1000)
		p.Function_body()
	}

	return localctx
}

// IFunction_bodyContext is an interface to support dynamic dispatch.
type IFunction_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_bodyContext differentiates from other interfaces.
	IsFunction_bodyContext()
}

type Function_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_bodyContext() *Function_bodyContext {
	var p = new(Function_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_function_body
	return p
}

func (*Function_bodyContext) IsFunction_bodyContext() {}

func NewFunction_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_bodyContext {
	var p = new(Function_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_function_body

	return p
}

func (s *Function_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_bodyContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Function_bodyContext) Function_try_block() IFunction_try_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_try_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_try_blockContext)
}

func (s *Function_bodyContext) Default() antlr.TerminalNode {
	return s.GetToken(PandaParserDefault, 0)
}

func (s *Function_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFunction_body(s)
	}
}

func (s *Function_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFunction_body(s)
	}
}

func (p *PandaParser) Function_body() (localctx IFunction_bodyContext) {
	localctx = NewFunction_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, PandaParserRULE_function_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1007)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserLeftBrace:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1002)
			p.Compound_statement()
		}

	case PandaParserTry:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1003)
			p.Function_try_block()
		}

	case PandaParserAssign:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1004)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(1005)
			p.Match(PandaParserDefault)
		}
		{
			p.SetState(1006)
			p.Match(PandaParserSemi)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_initializer
	return p
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Brace_or_equal_initializer() IBrace_or_equal_initializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBrace_or_equal_initializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBrace_or_equal_initializerContext)
}

func (s *InitializerContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInitializer(s)
	}
}

func (s *InitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInitializer(s)
	}
}

func (p *PandaParser) Initializer() (localctx IInitializerContext) {
	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, PandaParserRULE_initializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1014)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserLeftBrace, PandaParserAssign:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1009)
			p.Brace_or_equal_initializer()
		}

	case PandaParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1010)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(1011)
			p.Expression_list()
		}
		{
			p.SetState(1012)
			p.Match(PandaParserRightParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBrace_or_equal_initializerContext is an interface to support dynamic dispatch.
type IBrace_or_equal_initializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBrace_or_equal_initializerContext differentiates from other interfaces.
	IsBrace_or_equal_initializerContext()
}

type Brace_or_equal_initializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBrace_or_equal_initializerContext() *Brace_or_equal_initializerContext {
	var p = new(Brace_or_equal_initializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_brace_or_equal_initializer
	return p
}

func (*Brace_or_equal_initializerContext) IsBrace_or_equal_initializerContext() {}

func NewBrace_or_equal_initializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Brace_or_equal_initializerContext {
	var p = new(Brace_or_equal_initializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_brace_or_equal_initializer

	return p
}

func (s *Brace_or_equal_initializerContext) GetParser() antlr.Parser { return s.parser }

func (s *Brace_or_equal_initializerContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *Brace_or_equal_initializerContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *Brace_or_equal_initializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Brace_or_equal_initializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Brace_or_equal_initializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBrace_or_equal_initializer(s)
	}
}

func (s *Brace_or_equal_initializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBrace_or_equal_initializer(s)
	}
}

func (p *PandaParser) Brace_or_equal_initializer() (localctx IBrace_or_equal_initializerContext) {
	localctx = NewBrace_or_equal_initializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, PandaParserRULE_brace_or_equal_initializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserAssign:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1016)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(1017)
			p.Initializer_clause()
		}

	case PandaParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1018)
			p.Braced_init_list()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializer_clauseContext is an interface to support dynamic dispatch.
type IInitializer_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializer_clauseContext differentiates from other interfaces.
	IsInitializer_clauseContext()
}

type Initializer_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializer_clauseContext() *Initializer_clauseContext {
	var p = new(Initializer_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_initializer_clause
	return p
}

func (*Initializer_clauseContext) IsInitializer_clauseContext() {}

func NewInitializer_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initializer_clauseContext {
	var p = new(Initializer_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_initializer_clause

	return p
}

func (s *Initializer_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Initializer_clauseContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Initializer_clauseContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *Initializer_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initializer_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initializer_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInitializer_clause(s)
	}
}

func (s *Initializer_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInitializer_clause(s)
	}
}

func (p *PandaParser) Initializer_clause() (localctx IInitializer_clauseContext) {
	localctx = NewInitializer_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, PandaParserRULE_initializer_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1021)
			p.Assignment_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1022)
			p.Braced_init_list()
		}

	}

	return localctx
}

// IInitializer_listContext is an interface to support dynamic dispatch.
type IInitializer_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializer_listContext differentiates from other interfaces.
	IsInitializer_listContext()
}

type Initializer_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializer_listContext() *Initializer_listContext {
	var p = new(Initializer_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_initializer_list
	return p
}

func (*Initializer_listContext) IsInitializer_listContext() {}

func NewInitializer_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initializer_listContext {
	var p = new(Initializer_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_initializer_list

	return p
}

func (s *Initializer_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Initializer_listContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *Initializer_listContext) Initializer_list() IInitializer_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_listContext)
}

func (s *Initializer_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initializer_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initializer_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInitializer_list(s)
	}
}

func (s *Initializer_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInitializer_list(s)
	}
}

func (p *PandaParser) Initializer_list() (localctx IInitializer_listContext) {
	return p.initializer_list(0)
}

func (p *PandaParser) initializer_list(_p int) (localctx IInitializer_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInitializer_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInitializer_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 184
	p.EnterRecursionRule(localctx, 184, PandaParserRULE_initializer_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Initializer_clause()
	}
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1027)
			p.Match(PandaParserEllipsis)
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1038)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInitializer_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_initializer_list)
			p.SetState(1030)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1031)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(1032)
				p.Initializer_clause()
			}
			p.SetState(1034)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1033)
					p.Match(PandaParserEllipsis)
				}

			}

		}
		p.SetState(1040)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext())
	}

	return localctx
}

// IBraced_init_listContext is an interface to support dynamic dispatch.
type IBraced_init_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBraced_init_listContext differentiates from other interfaces.
	IsBraced_init_listContext()
}

type Braced_init_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_init_listContext() *Braced_init_listContext {
	var p = new(Braced_init_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_braced_init_list
	return p
}

func (*Braced_init_listContext) IsBraced_init_listContext() {}

func NewBraced_init_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_init_listContext {
	var p = new(Braced_init_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_braced_init_list

	return p
}

func (s *Braced_init_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_init_listContext) Initializer_list() IInitializer_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_listContext)
}

func (s *Braced_init_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_init_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Braced_init_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBraced_init_list(s)
	}
}

func (s *Braced_init_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBraced_init_list(s)
	}
}

func (p *PandaParser) Braced_init_list() (localctx IBraced_init_listContext) {
	localctx = NewBraced_init_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, PandaParserRULE_braced_init_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1041)
			p.Match(PandaParserLeftBrace)
		}
		{
			p.SetState(1042)
			p.initializer_list(0)
		}
		p.SetState(1044)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserComma {
			{
				p.SetState(1043)
				p.Match(PandaParserComma)
			}

		}
		{
			p.SetState(1046)
			p.Match(PandaParserRightBrace)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1048)
			p.Match(PandaParserLeftBrace)
		}
		{
			p.SetState(1049)
			p.Match(PandaParserRightBrace)
		}

	}

	return localctx
}

// IClass_nameContext is an interface to support dynamic dispatch.
type IClass_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_nameContext differentiates from other interfaces.
	IsClass_nameContext()
}

type Class_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_nameContext() *Class_nameContext {
	var p = new(Class_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_class_name
	return p
}

func (*Class_nameContext) IsClass_nameContext() {}

func NewClass_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_nameContext {
	var p = new(Class_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_class_name

	return p
}

func (s *Class_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_nameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Class_nameContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Class_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterClass_name(s)
	}
}

func (s *Class_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitClass_name(s)
	}
}

func (p *PandaParser) Class_name() (localctx IClass_nameContext) {
	localctx = NewClass_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, PandaParserRULE_class_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1052)
			p.Match(PandaParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1053)
			p.Template_id()
		}

	}

	return localctx
}

// IClass_specifierContext is an interface to support dynamic dispatch.
type IClass_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_specifierContext differentiates from other interfaces.
	IsClass_specifierContext()
}

type Class_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_specifierContext() *Class_specifierContext {
	var p = new(Class_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_class_specifier
	return p
}

func (*Class_specifierContext) IsClass_specifierContext() {}

func NewClass_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_specifierContext {
	var p = new(Class_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_class_specifier

	return p
}

func (s *Class_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_specifierContext) Class_head() IClass_headContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_headContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_headContext)
}

func (s *Class_specifierContext) Member_specification() IMember_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_specificationContext)
}

func (s *Class_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterClass_specifier(s)
	}
}

func (s *Class_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitClass_specifier(s)
	}
}

func (p *PandaParser) Class_specifier() (localctx IClass_specifierContext) {
	localctx = NewClass_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, PandaParserRULE_class_specifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		p.Class_head()
	}
	{
		p.SetState(1057)
		p.Match(PandaParserLeftBrace)
	}
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserClass)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserOperator)|(1<<PandaParserPrivate))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PandaParserProtected-32))|(1<<(PandaParserPublic-32))|(1<<(PandaParserShort-32))|(1<<(PandaParserUint-32))|(1<<(PandaParserUint8-32))|(1<<(PandaParserUint16-32))|(1<<(PandaParserUint32-32))|(1<<(PandaParserUint64-32))|(1<<(PandaParserUlong-32))|(1<<(PandaParserUshort-32))|(1<<(PandaParserVoid-32))|(1<<(PandaParserLeftParen-32))|(1<<(PandaParserAnd-32)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(PandaParserColon-92))|(1<<(PandaParserSemi-92))|(1<<(PandaParserEllipsis-92))|(1<<(PandaParserIdentifier-92)))) != 0) {
		{
			p.SetState(1058)
			p.Member_specification()
		}

	}
	{
		p.SetState(1061)
		p.Match(PandaParserRightBrace)
	}

	return localctx
}

// IClass_headContext is an interface to support dynamic dispatch.
type IClass_headContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_headContext differentiates from other interfaces.
	IsClass_headContext()
}

type Class_headContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_headContext() *Class_headContext {
	var p = new(Class_headContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_class_head
	return p
}

func (*Class_headContext) IsClass_headContext() {}

func NewClass_headContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_headContext {
	var p = new(Class_headContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_class_head

	return p
}

func (s *Class_headContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_headContext) Class() antlr.TerminalNode {
	return s.GetToken(PandaParserClass, 0)
}

func (s *Class_headContext) Class_head_name() IClass_head_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_head_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_head_nameContext)
}

func (s *Class_headContext) Base_clause() IBase_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_clauseContext)
}

func (s *Class_headContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_headContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_headContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterClass_head(s)
	}
}

func (s *Class_headContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitClass_head(s)
	}
}

func (p *PandaParser) Class_head() (localctx IClass_headContext) {
	localctx = NewClass_headContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, PandaParserRULE_class_head)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1072)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1063)
			p.Match(PandaParserClass)
		}
		{
			p.SetState(1064)
			p.Class_head_name()
		}
		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserColon {
			{
				p.SetState(1065)
				p.Base_clause()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1068)
			p.Match(PandaParserClass)
		}
		p.SetState(1070)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserColon {
			{
				p.SetState(1069)
				p.Base_clause()
			}

		}

	}

	return localctx
}

// IClass_head_nameContext is an interface to support dynamic dispatch.
type IClass_head_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_head_nameContext differentiates from other interfaces.
	IsClass_head_nameContext()
}

type Class_head_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_head_nameContext() *Class_head_nameContext {
	var p = new(Class_head_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_class_head_name
	return p
}

func (*Class_head_nameContext) IsClass_head_nameContext() {}

func NewClass_head_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_head_nameContext {
	var p = new(Class_head_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_class_head_name

	return p
}

func (s *Class_head_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_head_nameContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Class_head_nameContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Class_head_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_head_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_head_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterClass_head_name(s)
	}
}

func (s *Class_head_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitClass_head_name(s)
	}
}

func (p *PandaParser) Class_head_name() (localctx IClass_head_nameContext) {
	localctx = NewClass_head_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, PandaParserRULE_class_head_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1074)
			p.nested_name_specifier(0)
		}

	}
	{
		p.SetState(1077)
		p.Class_name()
	}

	return localctx
}

// IMember_specificationContext is an interface to support dynamic dispatch.
type IMember_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_specificationContext differentiates from other interfaces.
	IsMember_specificationContext()
}

type Member_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_specificationContext() *Member_specificationContext {
	var p = new(Member_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_member_specification
	return p
}

func (*Member_specificationContext) IsMember_specificationContext() {}

func NewMember_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_specificationContext {
	var p = new(Member_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_member_specification

	return p
}

func (s *Member_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_specificationContext) Member_declaration() IMember_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_declarationContext)
}

func (s *Member_specificationContext) Member_specification() IMember_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_specificationContext)
}

func (s *Member_specificationContext) Access_specifier() IAccess_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_specifierContext)
}

func (s *Member_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMember_specification(s)
	}
}

func (s *Member_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMember_specification(s)
	}
}

func (p *PandaParser) Member_specification() (localctx IMember_specificationContext) {
	localctx = NewMember_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, PandaParserRULE_member_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1088)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserAuto, PandaParserBool, PandaParserClass, PandaParserDouble, PandaParserEnum, PandaParserFloat32, PandaParserFloat64, PandaParserFloat, PandaParserInt, PandaParserInt8, PandaParserInt16, PandaParserInt32, PandaParserInt64, PandaParserLong, PandaParserOperator, PandaParserShort, PandaParserUint, PandaParserUint8, PandaParserUint16, PandaParserUint32, PandaParserUint64, PandaParserUlong, PandaParserUshort, PandaParserVoid, PandaParserLeftParen, PandaParserAnd, PandaParserColon, PandaParserSemi, PandaParserEllipsis, PandaParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1079)
			p.Member_declaration()
		}
		p.SetState(1081)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserClass)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserOperator)|(1<<PandaParserPrivate))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PandaParserProtected-32))|(1<<(PandaParserPublic-32))|(1<<(PandaParserShort-32))|(1<<(PandaParserUint-32))|(1<<(PandaParserUint8-32))|(1<<(PandaParserUint16-32))|(1<<(PandaParserUint32-32))|(1<<(PandaParserUint64-32))|(1<<(PandaParserUlong-32))|(1<<(PandaParserUshort-32))|(1<<(PandaParserVoid-32))|(1<<(PandaParserLeftParen-32))|(1<<(PandaParserAnd-32)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(PandaParserColon-92))|(1<<(PandaParserSemi-92))|(1<<(PandaParserEllipsis-92))|(1<<(PandaParserIdentifier-92)))) != 0) {
			{
				p.SetState(1080)
				p.Member_specification()
			}

		}

	case PandaParserPrivate, PandaParserProtected, PandaParserPublic:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1083)
			p.Access_specifier()
		}
		{
			p.SetState(1084)
			p.Match(PandaParserColon)
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserClass)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserOperator)|(1<<PandaParserPrivate))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PandaParserProtected-32))|(1<<(PandaParserPublic-32))|(1<<(PandaParserShort-32))|(1<<(PandaParserUint-32))|(1<<(PandaParserUint8-32))|(1<<(PandaParserUint16-32))|(1<<(PandaParserUint32-32))|(1<<(PandaParserUint64-32))|(1<<(PandaParserUlong-32))|(1<<(PandaParserUshort-32))|(1<<(PandaParserVoid-32))|(1<<(PandaParserLeftParen-32))|(1<<(PandaParserAnd-32)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(PandaParserColon-92))|(1<<(PandaParserSemi-92))|(1<<(PandaParserEllipsis-92))|(1<<(PandaParserIdentifier-92)))) != 0) {
			{
				p.SetState(1085)
				p.Member_specification()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMember_declarationContext is an interface to support dynamic dispatch.
type IMember_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_declarationContext differentiates from other interfaces.
	IsMember_declarationContext()
}

type Member_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_declarationContext() *Member_declarationContext {
	var p = new(Member_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_member_declaration
	return p
}

func (*Member_declarationContext) IsMember_declarationContext() {}

func NewMember_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_declarationContext {
	var p = new(Member_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_member_declaration

	return p
}

func (s *Member_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_declarationContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Member_declarationContext) Member_declarator_list() IMember_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_declarator_listContext)
}

func (s *Member_declarationContext) Function_definition() IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *Member_declarationContext) Empty_declaration() IEmpty_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_declarationContext)
}

func (s *Member_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMember_declaration(s)
	}
}

func (s *Member_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMember_declaration(s)
	}
}

func (p *PandaParser) Member_declaration() (localctx IMember_declarationContext) {
	localctx = NewMember_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, PandaParserRULE_member_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1099)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1091)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1090)
				p.Decl_specifier_sequence()
			}

		}
		p.SetState(1094)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserOperator || _la == PandaParserLeftParen || _la == PandaParserAnd || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(PandaParserColon-92))|(1<<(PandaParserEllipsis-92))|(1<<(PandaParserIdentifier-92)))) != 0) {
			{
				p.SetState(1093)
				p.member_declarator_list(0)
			}

		}
		{
			p.SetState(1096)
			p.Match(PandaParserSemi)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1097)
			p.Function_definition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1098)
			p.Empty_declaration()
		}

	}

	return localctx
}

// IMember_declarator_listContext is an interface to support dynamic dispatch.
type IMember_declarator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_declarator_listContext differentiates from other interfaces.
	IsMember_declarator_listContext()
}

type Member_declarator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_declarator_listContext() *Member_declarator_listContext {
	var p = new(Member_declarator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_member_declarator_list
	return p
}

func (*Member_declarator_listContext) IsMember_declarator_listContext() {}

func NewMember_declarator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_declarator_listContext {
	var p = new(Member_declarator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_member_declarator_list

	return p
}

func (s *Member_declarator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_declarator_listContext) Memberdeclarator() IMemberdeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberdeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberdeclaratorContext)
}

func (s *Member_declarator_listContext) Member_declarator_list() IMember_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_declarator_listContext)
}

func (s *Member_declarator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_declarator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_declarator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMember_declarator_list(s)
	}
}

func (s *Member_declarator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMember_declarator_list(s)
	}
}

func (p *PandaParser) Member_declarator_list() (localctx IMember_declarator_listContext) {
	return p.member_declarator_list(0)
}

func (p *PandaParser) member_declarator_list(_p int) (localctx IMember_declarator_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewMember_declarator_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMember_declarator_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 200
	p.EnterRecursionRule(localctx, 200, PandaParserRULE_member_declarator_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1102)
		p.Memberdeclarator()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMember_declarator_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_member_declarator_list)
			p.SetState(1104)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1105)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(1106)
				p.Memberdeclarator()
			}

		}
		p.SetState(1111)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
	}

	return localctx
}

// IMemberdeclaratorContext is an interface to support dynamic dispatch.
type IMemberdeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberdeclaratorContext differentiates from other interfaces.
	IsMemberdeclaratorContext()
}

type MemberdeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberdeclaratorContext() *MemberdeclaratorContext {
	var p = new(MemberdeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_memberdeclarator
	return p
}

func (*MemberdeclaratorContext) IsMemberdeclaratorContext() {}

func NewMemberdeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberdeclaratorContext {
	var p = new(MemberdeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_memberdeclarator

	return p
}

func (s *MemberdeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberdeclaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *MemberdeclaratorContext) Brace_or_equal_initializer() IBrace_or_equal_initializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBrace_or_equal_initializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBrace_or_equal_initializerContext)
}

func (s *MemberdeclaratorContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *MemberdeclaratorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *MemberdeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberdeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberdeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMemberdeclarator(s)
	}
}

func (s *MemberdeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMemberdeclarator(s)
	}
}

func (p *PandaParser) Memberdeclarator() (localctx IMemberdeclaratorContext) {
	localctx = NewMemberdeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, PandaParserRULE_memberdeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1112)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1113)
			p.Declarator()
		}
		p.SetState(1115)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1114)
				p.Brace_or_equal_initializer()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1118)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserIdentifier {
			{
				p.SetState(1117)
				p.Match(PandaParserIdentifier)
			}

		}
		{
			p.SetState(1120)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(1121)
			p.Constant_expression()
		}

	}

	return localctx
}

// IBase_clauseContext is an interface to support dynamic dispatch.
type IBase_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_clauseContext differentiates from other interfaces.
	IsBase_clauseContext()
}

type Base_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_clauseContext() *Base_clauseContext {
	var p = new(Base_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_base_clause
	return p
}

func (*Base_clauseContext) IsBase_clauseContext() {}

func NewBase_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_clauseContext {
	var p = new(Base_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_base_clause

	return p
}

func (s *Base_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_clauseContext) Base_specifier_list() IBase_specifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_specifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_specifier_listContext)
}

func (s *Base_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBase_clause(s)
	}
}

func (s *Base_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBase_clause(s)
	}
}

func (p *PandaParser) Base_clause() (localctx IBase_clauseContext) {
	localctx = NewBase_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, PandaParserRULE_base_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1124)
		p.Match(PandaParserColon)
	}
	{
		p.SetState(1125)
		p.base_specifier_list(0)
	}

	return localctx
}

// IBase_specifier_listContext is an interface to support dynamic dispatch.
type IBase_specifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_specifier_listContext differentiates from other interfaces.
	IsBase_specifier_listContext()
}

type Base_specifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_specifier_listContext() *Base_specifier_listContext {
	var p = new(Base_specifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_base_specifier_list
	return p
}

func (*Base_specifier_listContext) IsBase_specifier_listContext() {}

func NewBase_specifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_specifier_listContext {
	var p = new(Base_specifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_base_specifier_list

	return p
}

func (s *Base_specifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_specifier_listContext) Base_specifier() IBase_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_specifierContext)
}

func (s *Base_specifier_listContext) Base_specifier_list() IBase_specifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_specifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_specifier_listContext)
}

func (s *Base_specifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_specifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_specifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBase_specifier_list(s)
	}
}

func (s *Base_specifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBase_specifier_list(s)
	}
}

func (p *PandaParser) Base_specifier_list() (localctx IBase_specifier_listContext) {
	return p.base_specifier_list(0)
}

func (p *PandaParser) base_specifier_list(_p int) (localctx IBase_specifier_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBase_specifier_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBase_specifier_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 206
	p.EnterRecursionRule(localctx, 206, PandaParserRULE_base_specifier_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1128)
		p.Base_specifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1135)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBase_specifier_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_base_specifier_list)
			p.SetState(1130)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1131)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(1132)
				p.Base_specifier()
			}

		}
		p.SetState(1137)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())
	}

	return localctx
}

// IBase_specifierContext is an interface to support dynamic dispatch.
type IBase_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_specifierContext differentiates from other interfaces.
	IsBase_specifierContext()
}

type Base_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_specifierContext() *Base_specifierContext {
	var p = new(Base_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_base_specifier
	return p
}

func (*Base_specifierContext) IsBase_specifierContext() {}

func NewBase_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_specifierContext {
	var p = new(Base_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_base_specifier

	return p
}

func (s *Base_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_specifierContext) Base_type_specifier() IBase_type_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_type_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_type_specifierContext)
}

func (s *Base_specifierContext) Access_specifier() IAccess_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_specifierContext)
}

func (s *Base_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBase_specifier(s)
	}
}

func (s *Base_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBase_specifier(s)
	}
}

func (p *PandaParser) Base_specifier() (localctx IBase_specifierContext) {
	localctx = NewBase_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, PandaParserRULE_base_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1142)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1138)
			p.Base_type_specifier()
		}

	case PandaParserPrivate, PandaParserProtected, PandaParserPublic:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1139)
			p.Access_specifier()
		}
		{
			p.SetState(1140)
			p.Base_type_specifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClass_or_decltypeContext is an interface to support dynamic dispatch.
type IClass_or_decltypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_or_decltypeContext differentiates from other interfaces.
	IsClass_or_decltypeContext()
}

type Class_or_decltypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_or_decltypeContext() *Class_or_decltypeContext {
	var p = new(Class_or_decltypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_class_or_decltype
	return p
}

func (*Class_or_decltypeContext) IsClass_or_decltypeContext() {}

func NewClass_or_decltypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_or_decltypeContext {
	var p = new(Class_or_decltypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_class_or_decltype

	return p
}

func (s *Class_or_decltypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_or_decltypeContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Class_or_decltypeContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Class_or_decltypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_or_decltypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_or_decltypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterClass_or_decltype(s)
	}
}

func (s *Class_or_decltypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitClass_or_decltype(s)
	}
}

func (p *PandaParser) Class_or_decltype() (localctx IClass_or_decltypeContext) {
	localctx = NewClass_or_decltypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, PandaParserRULE_class_or_decltype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1145)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1144)
			p.nested_name_specifier(0)
		}

	}
	{
		p.SetState(1147)
		p.Class_name()
	}

	return localctx
}

// IBase_type_specifierContext is an interface to support dynamic dispatch.
type IBase_type_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_type_specifierContext differentiates from other interfaces.
	IsBase_type_specifierContext()
}

type Base_type_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_type_specifierContext() *Base_type_specifierContext {
	var p = new(Base_type_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_base_type_specifier
	return p
}

func (*Base_type_specifierContext) IsBase_type_specifierContext() {}

func NewBase_type_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_type_specifierContext {
	var p = new(Base_type_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_base_type_specifier

	return p
}

func (s *Base_type_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_type_specifierContext) Class_or_decltype() IClass_or_decltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_or_decltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_or_decltypeContext)
}

func (s *Base_type_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_type_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_type_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBase_type_specifier(s)
	}
}

func (s *Base_type_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBase_type_specifier(s)
	}
}

func (p *PandaParser) Base_type_specifier() (localctx IBase_type_specifierContext) {
	localctx = NewBase_type_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, PandaParserRULE_base_type_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		p.Class_or_decltype()
	}

	return localctx
}

// IAccess_specifierContext is an interface to support dynamic dispatch.
type IAccess_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccess_specifierContext differentiates from other interfaces.
	IsAccess_specifierContext()
}

type Access_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccess_specifierContext() *Access_specifierContext {
	var p = new(Access_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_access_specifier
	return p
}

func (*Access_specifierContext) IsAccess_specifierContext() {}

func NewAccess_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_specifierContext {
	var p = new(Access_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_access_specifier

	return p
}

func (s *Access_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_specifierContext) Private() antlr.TerminalNode {
	return s.GetToken(PandaParserPrivate, 0)
}

func (s *Access_specifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(PandaParserProtected, 0)
}

func (s *Access_specifierContext) Public() antlr.TerminalNode {
	return s.GetToken(PandaParserPublic, 0)
}

func (s *Access_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAccess_specifier(s)
	}
}

func (s *Access_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAccess_specifier(s)
	}
}

func (p *PandaParser) Access_specifier() (localctx IAccess_specifierContext) {
	localctx = NewAccess_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, PandaParserRULE_access_specifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1151)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-31)&-(0x1f+1)) == 0 && ((1<<uint((_la-31)))&((1<<(PandaParserPrivate-31))|(1<<(PandaParserProtected-31))|(1<<(PandaParserPublic-31)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMem_initializer_listContext is an interface to support dynamic dispatch.
type IMem_initializer_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_initializer_listContext differentiates from other interfaces.
	IsMem_initializer_listContext()
}

type Mem_initializer_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_initializer_listContext() *Mem_initializer_listContext {
	var p = new(Mem_initializer_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_mem_initializer_list
	return p
}

func (*Mem_initializer_listContext) IsMem_initializer_listContext() {}

func NewMem_initializer_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_initializer_listContext {
	var p = new(Mem_initializer_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_mem_initializer_list

	return p
}

func (s *Mem_initializer_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_initializer_listContext) Mem_initializer() IMem_initializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_initializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_initializerContext)
}

func (s *Mem_initializer_listContext) Mem_initializer_list() IMem_initializer_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_initializer_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_initializer_listContext)
}

func (s *Mem_initializer_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_initializer_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_initializer_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMem_initializer_list(s)
	}
}

func (s *Mem_initializer_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMem_initializer_list(s)
	}
}

func (p *PandaParser) Mem_initializer_list() (localctx IMem_initializer_listContext) {
	localctx = NewMem_initializer_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, PandaParserRULE_mem_initializer_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1153)
			p.Mem_initializer()
		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1154)
				p.Match(PandaParserEllipsis)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1157)
			p.Mem_initializer()
		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserEllipsis {
			{
				p.SetState(1158)
				p.Match(PandaParserEllipsis)
			}

		}
		{
			p.SetState(1161)
			p.Match(PandaParserComma)
		}
		{
			p.SetState(1162)
			p.Mem_initializer_list()
		}

	}

	return localctx
}

// IMem_initializerContext is an interface to support dynamic dispatch.
type IMem_initializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_initializerContext differentiates from other interfaces.
	IsMem_initializerContext()
}

type Mem_initializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_initializerContext() *Mem_initializerContext {
	var p = new(Mem_initializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_mem_initializer
	return p
}

func (*Mem_initializerContext) IsMem_initializerContext() {}

func NewMem_initializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_initializerContext {
	var p = new(Mem_initializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_mem_initializer

	return p
}

func (s *Mem_initializerContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_initializerContext) Mem_initializer_id() IMem_initializer_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMem_initializer_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMem_initializer_idContext)
}

func (s *Mem_initializerContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Mem_initializerContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *Mem_initializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_initializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_initializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMem_initializer(s)
	}
}

func (s *Mem_initializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMem_initializer(s)
	}
}

func (p *PandaParser) Mem_initializer() (localctx IMem_initializerContext) {
	localctx = NewMem_initializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, PandaParserRULE_mem_initializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1166)
			p.Mem_initializer_id()
		}
		{
			p.SetState(1167)
			p.Match(PandaParserLeftParen)
		}
		p.SetState(1169)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserThrow-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
			{
				p.SetState(1168)
				p.Expression_list()
			}

		}
		{
			p.SetState(1171)
			p.Match(PandaParserRightParen)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1173)
			p.Mem_initializer_id()
		}
		{
			p.SetState(1174)
			p.Braced_init_list()
		}

	}

	return localctx
}

// IMem_initializer_idContext is an interface to support dynamic dispatch.
type IMem_initializer_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMem_initializer_idContext differentiates from other interfaces.
	IsMem_initializer_idContext()
}

type Mem_initializer_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMem_initializer_idContext() *Mem_initializer_idContext {
	var p = new(Mem_initializer_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_mem_initializer_id
	return p
}

func (*Mem_initializer_idContext) IsMem_initializer_idContext() {}

func NewMem_initializer_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mem_initializer_idContext {
	var p = new(Mem_initializer_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_mem_initializer_id

	return p
}

func (s *Mem_initializer_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Mem_initializer_idContext) Class_or_decltype() IClass_or_decltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_or_decltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_or_decltypeContext)
}

func (s *Mem_initializer_idContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Mem_initializer_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mem_initializer_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mem_initializer_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMem_initializer_id(s)
	}
}

func (s *Mem_initializer_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMem_initializer_id(s)
	}
}

func (p *PandaParser) Mem_initializer_id() (localctx IMem_initializer_idContext) {
	localctx = NewMem_initializer_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, PandaParserRULE_mem_initializer_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1180)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1178)
			p.Class_or_decltype()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1179)
			p.Match(PandaParserIdentifier)
		}

	}

	return localctx
}

// IOperator_function_idContext is an interface to support dynamic dispatch.
type IOperator_function_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperator_function_idContext differentiates from other interfaces.
	IsOperator_function_idContext()
}

type Operator_function_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperator_function_idContext() *Operator_function_idContext {
	var p = new(Operator_function_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_operator_function_id
	return p
}

func (*Operator_function_idContext) IsOperator_function_idContext() {}

func NewOperator_function_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operator_function_idContext {
	var p = new(Operator_function_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_operator_function_id

	return p
}

func (s *Operator_function_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Operator_function_idContext) Operator() antlr.TerminalNode {
	return s.GetToken(PandaParserOperator, 0)
}

func (s *Operator_function_idContext) Operators() IOperatorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperatorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperatorsContext)
}

func (s *Operator_function_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operator_function_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Operator_function_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterOperator_function_id(s)
	}
}

func (s *Operator_function_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitOperator_function_id(s)
	}
}

func (p *PandaParser) Operator_function_id() (localctx IOperator_function_idContext) {
	localctx = NewOperator_function_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, PandaParserRULE_operator_function_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1182)
		p.Match(PandaParserOperator)
	}
	{
		p.SetState(1183)
		p.Operators()
	}

	return localctx
}

// ITemplate_parameter_listContext is an interface to support dynamic dispatch.
type ITemplate_parameter_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_parameter_listContext differentiates from other interfaces.
	IsTemplate_parameter_listContext()
}

type Template_parameter_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_parameter_listContext() *Template_parameter_listContext {
	var p = new(Template_parameter_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_parameter_list
	return p
}

func (*Template_parameter_listContext) IsTemplate_parameter_listContext() {}

func NewTemplate_parameter_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_parameter_listContext {
	var p = new(Template_parameter_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_parameter_list

	return p
}

func (s *Template_parameter_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_parameter_listContext) Template_parameter() ITemplate_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_parameterContext)
}

func (s *Template_parameter_listContext) Template_parameter_list() ITemplate_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_parameter_listContext)
}

func (s *Template_parameter_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_parameter_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_parameter_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_parameter_list(s)
	}
}

func (s *Template_parameter_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_parameter_list(s)
	}
}

func (p *PandaParser) Template_parameter_list() (localctx ITemplate_parameter_listContext) {
	return p.template_parameter_list(0)
}

func (p *PandaParser) template_parameter_list(_p int) (localctx ITemplate_parameter_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTemplate_parameter_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITemplate_parameter_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 224
	p.EnterRecursionRule(localctx, 224, PandaParserRULE_template_parameter_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1186)
		p.Template_parameter()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTemplate_parameter_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_template_parameter_list)
			p.SetState(1188)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1189)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(1190)
				p.Template_parameter()
			}

		}
		p.SetState(1195)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext())
	}

	return localctx
}

// ITemplate_parameterContext is an interface to support dynamic dispatch.
type ITemplate_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_parameterContext differentiates from other interfaces.
	IsTemplate_parameterContext()
}

type Template_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_parameterContext() *Template_parameterContext {
	var p = new(Template_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_parameter
	return p
}

func (*Template_parameterContext) IsTemplate_parameterContext() {}

func NewTemplate_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_parameterContext {
	var p = new(Template_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_parameter

	return p
}

func (s *Template_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_parameterContext) Type_parameter() IType_parameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_parameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_parameterContext)
}

func (s *Template_parameterContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Template_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_parameter(s)
	}
}

func (s *Template_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_parameter(s)
	}
}

func (p *PandaParser) Template_parameter() (localctx ITemplate_parameterContext) {
	localctx = NewTemplate_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, PandaParserRULE_template_parameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1196)
			p.Type_parameter()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1197)
			p.Parameter_declaration()
		}

	}

	return localctx
}

// IType_parameterContext is an interface to support dynamic dispatch.
type IType_parameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_parameterContext differentiates from other interfaces.
	IsType_parameterContext()
}

type Type_parameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_parameterContext() *Type_parameterContext {
	var p = new(Type_parameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_parameter
	return p
}

func (*Type_parameterContext) IsType_parameterContext() {}

func NewType_parameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_parameterContext {
	var p = new(Type_parameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_parameter

	return p
}

func (s *Type_parameterContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_parameterContext) Class() antlr.TerminalNode {
	return s.GetToken(PandaParserClass, 0)
}

func (s *Type_parameterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Type_parameterContext) Type_id() IType_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Type_parameterContext) Template_parameter_list() ITemplate_parameter_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_parameter_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_parameter_listContext)
}

func (s *Type_parameterContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Type_parameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_parameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_parameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_parameter(s)
	}
}

func (s *Type_parameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_parameter(s)
	}
}

func (p *PandaParser) Type_parameter() (localctx IType_parameterContext) {
	localctx = NewType_parameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, PandaParserRULE_type_parameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1200)
			p.Match(PandaParserClass)
		}
		p.SetState(1202)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1201)
				p.Match(PandaParserEllipsis)
			}

		}
		p.SetState(1205)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1204)
				p.Match(PandaParserIdentifier)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1207)
			p.Match(PandaParserClass)
		}
		p.SetState(1209)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserIdentifier {
			{
				p.SetState(1208)
				p.Match(PandaParserIdentifier)
			}

		}
		{
			p.SetState(1211)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(1212)
			p.Type_id()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1214)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1213)
				p.Match(PandaParserEllipsis)
			}

		}
		p.SetState(1217)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1216)
				p.Match(PandaParserIdentifier)
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1220)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserIdentifier {
			{
				p.SetState(1219)
				p.Match(PandaParserIdentifier)
			}

		}
		{
			p.SetState(1222)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(1223)
			p.Type_id()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1224)
			p.Match(PandaParserLess)
		}
		{
			p.SetState(1225)
			p.template_parameter_list(0)
		}
		{
			p.SetState(1226)
			p.Match(PandaParserGreater)
		}
		{
			p.SetState(1227)
			p.Match(PandaParserClass)
		}
		p.SetState(1229)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1228)
				p.Match(PandaParserEllipsis)
			}

		}
		p.SetState(1232)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1231)
				p.Match(PandaParserIdentifier)
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1234)
			p.Match(PandaParserLess)
		}
		{
			p.SetState(1235)
			p.template_parameter_list(0)
		}
		{
			p.SetState(1236)
			p.Match(PandaParserGreater)
		}
		{
			p.SetState(1237)
			p.Match(PandaParserClass)
		}
		p.SetState(1239)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserIdentifier {
			{
				p.SetState(1238)
				p.Match(PandaParserIdentifier)
			}

		}
		{
			p.SetState(1241)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(1242)
			p.Id_expression()
		}

	}

	return localctx
}

// ITemplate_idContext is an interface to support dynamic dispatch.
type ITemplate_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_idContext differentiates from other interfaces.
	IsTemplate_idContext()
}

type Template_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_idContext() *Template_idContext {
	var p = new(Template_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_id
	return p
}

func (*Template_idContext) IsTemplate_idContext() {}

func NewTemplate_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_idContext {
	var p = new(Template_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_id

	return p
}

func (s *Template_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_idContext) Template_name() ITemplate_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_nameContext)
}

func (s *Template_idContext) Template_argument_list() ITemplate_argument_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_argument_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_argument_listContext)
}

func (s *Template_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_id(s)
	}
}

func (s *Template_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_id(s)
	}
}

func (p *PandaParser) Template_id() (localctx ITemplate_idContext) {
	localctx = NewTemplate_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, PandaParserRULE_template_id)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1246)
		p.Template_name()
	}
	{
		p.SetState(1247)
		p.Match(PandaParserLess)
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserClass)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserThis-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36))|(1<<(PandaParserLeftParen-36))|(1<<(PandaParserLeftBrace-36))|(1<<(PandaParserPlus-36))|(1<<(PandaParserMinus-36))|(1<<(PandaParserOr-36))|(1<<(PandaParserTilde-36))|(1<<(PandaParserNot-36)))) != 0) || (((_la-87)&-(0x1f+1)) == 0 && ((1<<uint((_la-87)))&((1<<(PandaParserPlusPlus-87))|(1<<(PandaParserMinusMinus-87))|(1<<(PandaParserIdentifier-87))|(1<<(PandaParserIntegerLiteral-87))|(1<<(PandaParserFloatLiteral-87))|(1<<(PandaParserStringLiteral-87))|(1<<(PandaParserBooleanLiteral-87))|(1<<(PandaParserPointerLiteral-87)))) != 0) {
		{
			p.SetState(1248)
			p.template_argument_list(0)
		}

	}
	{
		p.SetState(1251)
		p.Match(PandaParserGreater)
	}

	return localctx
}

// ITemplate_nameContext is an interface to support dynamic dispatch.
type ITemplate_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_nameContext differentiates from other interfaces.
	IsTemplate_nameContext()
}

type Template_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_nameContext() *Template_nameContext {
	var p = new(Template_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_name
	return p
}

func (*Template_nameContext) IsTemplate_nameContext() {}

func NewTemplate_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_nameContext {
	var p = new(Template_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_name

	return p
}

func (s *Template_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_nameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Template_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_name(s)
	}
}

func (s *Template_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_name(s)
	}
}

func (p *PandaParser) Template_name() (localctx ITemplate_nameContext) {
	localctx = NewTemplate_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, PandaParserRULE_template_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1253)
		p.Match(PandaParserIdentifier)
	}

	return localctx
}

// ITemplate_argument_listContext is an interface to support dynamic dispatch.
type ITemplate_argument_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_argument_listContext differentiates from other interfaces.
	IsTemplate_argument_listContext()
}

type Template_argument_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_argument_listContext() *Template_argument_listContext {
	var p = new(Template_argument_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_argument_list
	return p
}

func (*Template_argument_listContext) IsTemplate_argument_listContext() {}

func NewTemplate_argument_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_argument_listContext {
	var p = new(Template_argument_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_argument_list

	return p
}

func (s *Template_argument_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_argument_listContext) Template_argument() ITemplate_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_argumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_argumentContext)
}

func (s *Template_argument_listContext) Template_argument_list() ITemplate_argument_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_argument_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_argument_listContext)
}

func (s *Template_argument_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_argument_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_argument_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_argument_list(s)
	}
}

func (s *Template_argument_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_argument_list(s)
	}
}

func (p *PandaParser) Template_argument_list() (localctx ITemplate_argument_listContext) {
	return p.template_argument_list(0)
}

func (p *PandaParser) template_argument_list(_p int) (localctx ITemplate_argument_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTemplate_argument_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITemplate_argument_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 234
	p.EnterRecursionRule(localctx, 234, PandaParserRULE_template_argument_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1256)
		p.Template_argument()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1263)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTemplate_argument_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_template_argument_list)
			p.SetState(1258)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1259)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(1260)
				p.Template_argument()
			}

		}
		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// ITemplate_argumentContext is an interface to support dynamic dispatch.
type ITemplate_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_argumentContext differentiates from other interfaces.
	IsTemplate_argumentContext()
}

type Template_argumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_argumentContext() *Template_argumentContext {
	var p = new(Template_argumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_argument
	return p
}

func (*Template_argumentContext) IsTemplate_argumentContext() {}

func NewTemplate_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_argumentContext {
	var p = new(Template_argumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_argument

	return p
}

func (s *Template_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_argumentContext) Type_id() IType_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Template_argumentContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Template_argumentContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Template_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_argument(s)
	}
}

func (s *Template_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_argument(s)
	}
}

func (p *PandaParser) Template_argument() (localctx ITemplate_argumentContext) {
	localctx = NewTemplate_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, PandaParserRULE_template_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1269)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1266)
			p.Type_id()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1267)
			p.Constant_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1268)
			p.Id_expression()
		}

	}

	return localctx
}

// IType_name_specifierContext is an interface to support dynamic dispatch.
type IType_name_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_name_specifierContext differentiates from other interfaces.
	IsType_name_specifierContext()
}

type Type_name_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_specifierContext() *Type_name_specifierContext {
	var p = new(Type_name_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_name_specifier
	return p
}

func (*Type_name_specifierContext) IsType_name_specifierContext() {}

func NewType_name_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_specifierContext {
	var p = new(Type_name_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_name_specifier

	return p
}

func (s *Type_name_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_specifierContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Type_name_specifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Type_name_specifierContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Type_name_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_name_specifier(s)
	}
}

func (s *Type_name_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_name_specifier(s)
	}
}

func (p *PandaParser) Type_name_specifier() (localctx IType_name_specifierContext) {
	localctx = NewType_name_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, PandaParserRULE_type_name_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1277)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1271)
			p.nested_name_specifier(0)
		}
		{
			p.SetState(1272)
			p.Match(PandaParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1274)
			p.nested_name_specifier(0)
		}
		{
			p.SetState(1275)
			p.Template_id()
		}

	}

	return localctx
}

// ITry_blockContext is an interface to support dynamic dispatch.
type ITry_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_blockContext differentiates from other interfaces.
	IsTry_blockContext()
}

type Try_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_blockContext() *Try_blockContext {
	var p = new(Try_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_try_block
	return p
}

func (*Try_blockContext) IsTry_blockContext() {}

func NewTry_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_blockContext {
	var p = new(Try_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_try_block

	return p
}

func (s *Try_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_blockContext) Try() antlr.TerminalNode {
	return s.GetToken(PandaParserTry, 0)
}

func (s *Try_blockContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Try_blockContext) Handler_sequence() IHandler_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHandler_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHandler_sequenceContext)
}

func (s *Try_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Try_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTry_block(s)
	}
}

func (s *Try_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTry_block(s)
	}
}

func (p *PandaParser) Try_block() (localctx ITry_blockContext) {
	localctx = NewTry_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, PandaParserRULE_try_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1279)
		p.Match(PandaParserTry)
	}
	{
		p.SetState(1280)
		p.Compound_statement()
	}
	{
		p.SetState(1281)
		p.Handler_sequence()
	}

	return localctx
}

// IFunction_try_blockContext is an interface to support dynamic dispatch.
type IFunction_try_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_try_blockContext differentiates from other interfaces.
	IsFunction_try_blockContext()
}

type Function_try_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_try_blockContext() *Function_try_blockContext {
	var p = new(Function_try_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_function_try_block
	return p
}

func (*Function_try_blockContext) IsFunction_try_blockContext() {}

func NewFunction_try_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_try_blockContext {
	var p = new(Function_try_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_function_try_block

	return p
}

func (s *Function_try_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_try_blockContext) Try() antlr.TerminalNode {
	return s.GetToken(PandaParserTry, 0)
}

func (s *Function_try_blockContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Function_try_blockContext) Handler_sequence() IHandler_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHandler_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHandler_sequenceContext)
}

func (s *Function_try_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_try_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_try_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFunction_try_block(s)
	}
}

func (s *Function_try_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFunction_try_block(s)
	}
}

func (p *PandaParser) Function_try_block() (localctx IFunction_try_blockContext) {
	localctx = NewFunction_try_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, PandaParserRULE_function_try_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1283)
		p.Match(PandaParserTry)
	}
	{
		p.SetState(1284)
		p.Compound_statement()
	}
	{
		p.SetState(1285)
		p.Handler_sequence()
	}

	return localctx
}

// IHandler_sequenceContext is an interface to support dynamic dispatch.
type IHandler_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHandler_sequenceContext differentiates from other interfaces.
	IsHandler_sequenceContext()
}

type Handler_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandler_sequenceContext() *Handler_sequenceContext {
	var p = new(Handler_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_handler_sequence
	return p
}

func (*Handler_sequenceContext) IsHandler_sequenceContext() {}

func NewHandler_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Handler_sequenceContext {
	var p = new(Handler_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_handler_sequence

	return p
}

func (s *Handler_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Handler_sequenceContext) Handler() IHandlerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHandlerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHandlerContext)
}

func (s *Handler_sequenceContext) Handler_sequence() IHandler_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHandler_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHandler_sequenceContext)
}

func (s *Handler_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Handler_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Handler_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterHandler_sequence(s)
	}
}

func (s *Handler_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitHandler_sequence(s)
	}
}

func (p *PandaParser) Handler_sequence() (localctx IHandler_sequenceContext) {
	localctx = NewHandler_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, PandaParserRULE_handler_sequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1287)
		p.Handler()
	}
	p.SetState(1289)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1288)
			p.Handler_sequence()
		}

	}

	return localctx
}

// IHandlerContext is an interface to support dynamic dispatch.
type IHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHandlerContext differentiates from other interfaces.
	IsHandlerContext()
}

type HandlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerContext() *HandlerContext {
	var p = new(HandlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_handler
	return p
}

func (*HandlerContext) IsHandlerContext() {}

func NewHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerContext {
	var p = new(HandlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_handler

	return p
}

func (s *HandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerContext) Catch() antlr.TerminalNode {
	return s.GetToken(PandaParserCatch, 0)
}

func (s *HandlerContext) Exception_declaration() IException_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_declarationContext)
}

func (s *HandlerContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *HandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterHandler(s)
	}
}

func (s *HandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitHandler(s)
	}
}

func (p *PandaParser) Handler() (localctx IHandlerContext) {
	localctx = NewHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, PandaParserRULE_handler)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1291)
		p.Match(PandaParserCatch)
	}
	{
		p.SetState(1292)
		p.Match(PandaParserLeftParen)
	}
	{
		p.SetState(1293)
		p.Exception_declaration()
	}
	{
		p.SetState(1294)
		p.Match(PandaParserRightParen)
	}
	{
		p.SetState(1295)
		p.Compound_statement()
	}

	return localctx
}

// IException_declarationContext is an interface to support dynamic dispatch.
type IException_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_declarationContext differentiates from other interfaces.
	IsException_declarationContext()
}

type Exception_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_declarationContext() *Exception_declarationContext {
	var p = new(Exception_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_exception_declaration
	return p
}

func (*Exception_declarationContext) IsException_declarationContext() {}

func NewException_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_declarationContext {
	var p = new(Exception_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_exception_declaration

	return p
}

func (s *Exception_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_declarationContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *Exception_declarationContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Exception_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterException_declaration(s)
	}
}

func (s *Exception_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitException_declaration(s)
	}
}

func (p *PandaParser) Exception_declaration() (localctx IException_declarationContext) {
	localctx = NewException_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, PandaParserRULE_exception_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1302)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1297)
			p.Type_specifier_sequence()
		}
		{
			p.SetState(1298)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1300)
			p.Type_specifier_sequence()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1301)
			p.Match(PandaParserEllipsis)
		}

	}

	return localctx
}

// IThrow_expressionContext is an interface to support dynamic dispatch.
type IThrow_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrow_expressionContext differentiates from other interfaces.
	IsThrow_expressionContext()
}

type Throw_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrow_expressionContext() *Throw_expressionContext {
	var p = new(Throw_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_throw_expression
	return p
}

func (*Throw_expressionContext) IsThrow_expressionContext() {}

func NewThrow_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Throw_expressionContext {
	var p = new(Throw_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_throw_expression

	return p
}

func (s *Throw_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Throw_expressionContext) Throw() antlr.TerminalNode {
	return s.GetToken(PandaParserThrow, 0)
}

func (s *Throw_expressionContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Throw_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Throw_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Throw_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterThrow_expression(s)
	}
}

func (s *Throw_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitThrow_expression(s)
	}
}

func (p *PandaParser) Throw_expression() (localctx IThrow_expressionContext) {
	localctx = NewThrow_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, PandaParserRULE_throw_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1304)
		p.Match(PandaParserThrow)
	}
	p.SetState(1306)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1305)
			p.Assignment_expression()
		}

	}

	return localctx
}

// IException_specificationContext is an interface to support dynamic dispatch.
type IException_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_specificationContext differentiates from other interfaces.
	IsException_specificationContext()
}

type Exception_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_specificationContext() *Exception_specificationContext {
	var p = new(Exception_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_exception_specification
	return p
}

func (*Exception_specificationContext) IsException_specificationContext() {}

func NewException_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_specificationContext {
	var p = new(Exception_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_exception_specification

	return p
}

func (s *Exception_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_specificationContext) Throw() antlr.TerminalNode {
	return s.GetToken(PandaParserThrow, 0)
}

func (s *Exception_specificationContext) Type_id_list() IType_id_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_id_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_id_listContext)
}

func (s *Exception_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterException_specification(s)
	}
}

func (s *Exception_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitException_specification(s)
	}
}

func (p *PandaParser) Exception_specification() (localctx IException_specificationContext) {
	localctx = NewException_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, PandaParserRULE_exception_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1308)
		p.Match(PandaParserThrow)
	}
	{
		p.SetState(1309)
		p.Match(PandaParserLeftParen)
	}
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserAuto)|(1<<PandaParserBool)|(1<<PandaParserClass)|(1<<PandaParserDouble)|(1<<PandaParserEnum)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong))) != 0) || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(PandaParserShort-36))|(1<<(PandaParserUint-36))|(1<<(PandaParserUint8-36))|(1<<(PandaParserUint16-36))|(1<<(PandaParserUint32-36))|(1<<(PandaParserUint64-36))|(1<<(PandaParserUlong-36))|(1<<(PandaParserUshort-36))|(1<<(PandaParserVoid-36)))) != 0) || _la == PandaParserIdentifier {
		{
			p.SetState(1310)
			p.type_id_list(0)
		}

	}
	{
		p.SetState(1313)
		p.Match(PandaParserRightParen)
	}

	return localctx
}

// IType_id_listContext is an interface to support dynamic dispatch.
type IType_id_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_id_listContext differentiates from other interfaces.
	IsType_id_listContext()
}

type Type_id_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_id_listContext() *Type_id_listContext {
	var p = new(Type_id_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_id_list
	return p
}

func (*Type_id_listContext) IsType_id_listContext() {}

func NewType_id_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_id_listContext {
	var p = new(Type_id_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_id_list

	return p
}

func (s *Type_id_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_id_listContext) Type_id() IType_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Type_id_listContext) Type_id_list() IType_id_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_id_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_id_listContext)
}

func (s *Type_id_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_id_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_id_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_id_list(s)
	}
}

func (s *Type_id_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_id_list(s)
	}
}

func (p *PandaParser) Type_id_list() (localctx IType_id_listContext) {
	return p.type_id_list(0)
}

func (p *PandaParser) type_id_list(_p int) (localctx IType_id_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewType_id_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IType_id_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 254
	p.EnterRecursionRule(localctx, 254, PandaParserRULE_type_id_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1316)
		p.Type_id()
	}
	p.SetState(1318)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1317)
			p.Match(PandaParserEllipsis)
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1328)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewType_id_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_type_id_list)
			p.SetState(1320)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1321)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(1322)
				p.Type_id()
			}
			p.SetState(1324)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1323)
					p.Match(PandaParserEllipsis)
				}

			}

		}
		p.SetState(1330)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())
	}

	return localctx
}

// IOperatorsContext is an interface to support dynamic dispatch.
type IOperatorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperatorsContext differentiates from other interfaces.
	IsOperatorsContext()
}

type OperatorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperatorsContext() *OperatorsContext {
	var p = new(OperatorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_operators
	return p
}

func (*OperatorsContext) IsOperatorsContext() {}

func NewOperatorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorsContext {
	var p = new(OperatorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_operators

	return p
}

func (s *OperatorsContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorsContext) New() antlr.TerminalNode {
	return s.GetToken(PandaParserNew, 0)
}

func (s *OperatorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterOperators(s)
	}
}

func (s *OperatorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitOperators(s)
	}
}

func (p *PandaParser) Operators() (localctx IOperatorsContext) {
	localctx = NewOperatorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, PandaParserRULE_operators)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1370)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserNew:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1331)
			p.Match(PandaParserNew)
		}

	case PandaParserPlus:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1332)
			p.Match(PandaParserPlus)
		}

	case PandaParserMinus:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1333)
			p.Match(PandaParserMinus)
		}

	case PandaParserStar:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1334)
			p.Match(PandaParserStar)
		}

	case PandaParserDiv:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1335)
			p.Match(PandaParserDiv)
		}

	case PandaParserMod:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1336)
			p.Match(PandaParserMod)
		}

	case PandaParserCaret:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1337)
			p.Match(PandaParserCaret)
		}

	case PandaParserAnd:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1338)
			p.Match(PandaParserAnd)
		}

	case PandaParserOr:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1339)
			p.Match(PandaParserOr)
		}

	case PandaParserTilde:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1340)
			p.Match(PandaParserTilde)
		}

	case PandaParserNot:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1341)
			p.Match(PandaParserNot)
		}

	case PandaParserAssign:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1342)
			p.Match(PandaParserAssign)
		}

	case PandaParserLess:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1343)
			p.Match(PandaParserLess)
		}

	case PandaParserGreater:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1344)
			p.Match(PandaParserGreater)
		}

	case PandaParserPlusAssign:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1345)
			p.Match(PandaParserPlusAssign)
		}

	case PandaParserMinusAssign:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1346)
			p.Match(PandaParserMinusAssign)
		}

	case PandaParserDivAssign:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1347)
			p.Match(PandaParserDivAssign)
		}

	case PandaParserModAssign:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1348)
			p.Match(PandaParserModAssign)
		}

	case PandaParserXorAssign:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1349)
			p.Match(PandaParserXorAssign)
		}

	case PandaParserAndAssign:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1350)
			p.Match(PandaParserAndAssign)
		}

	case PandaParserOrAssign:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1351)
			p.Match(PandaParserOrAssign)
		}

	case PandaParserLeftShift:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1352)
			p.Match(PandaParserLeftShift)
		}

	case PandaParserRightShift:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1353)
			p.Match(PandaParserRightShift)
		}

	case PandaParserRightShiftAssign:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1354)
			p.Match(PandaParserRightShiftAssign)
		}

	case PandaParserLeftShiftAssign:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1355)
			p.Match(PandaParserLeftShiftAssign)
		}

	case PandaParserEqual:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1356)
			p.Match(PandaParserEqual)
		}

	case PandaParserNotEqual:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1357)
			p.Match(PandaParserNotEqual)
		}

	case PandaParserLessEqual:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1358)
			p.Match(PandaParserLessEqual)
		}

	case PandaParserGreaterEqual:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1359)
			p.Match(PandaParserGreaterEqual)
		}

	case PandaParserAndAnd:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1360)
			p.Match(PandaParserAndAnd)
		}

	case PandaParserOrOr:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1361)
			p.Match(PandaParserOrOr)
		}

	case PandaParserPlusPlus:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1362)
			p.Match(PandaParserPlusPlus)
		}

	case PandaParserMinusMinus:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1363)
			p.Match(PandaParserMinusMinus)
		}

	case PandaParserComma:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1364)
			p.Match(PandaParserComma)
		}

	case PandaParserArrow:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1365)
			p.Match(PandaParserArrow)
		}

	case PandaParserLeftParen:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1366)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(1367)
			p.Match(PandaParserRightParen)
		}

	case PandaParserLeftBracket:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1368)
			p.Match(PandaParserLeftBracket)
		}
		{
			p.SetState(1369)
			p.Match(PandaParserRightBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserIntegerLiteral, 0)
}

func (s *LiteralContext) FloatLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserFloatLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserStringLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserBooleanLiteral, 0)
}

func (s *LiteralContext) PointerLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserPointerLiteral, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *PandaParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, PandaParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1372)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(PandaParserIntegerLiteral-97))|(1<<(PandaParserFloatLiteral-97))|(1<<(PandaParserStringLiteral-97))|(1<<(PandaParserBooleanLiteral-97))|(1<<(PandaParserPointerLiteral-97)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *PandaParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 5:
		var t *Nested_name_specifierContext = nil
		if localctx != nil {
			t = localctx.(*Nested_name_specifierContext)
		}
		return p.Nested_name_specifier_Sempred(t, predIndex)

	case 8:
		var t *Post_fix_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Post_fix_expressionContext)
		}
		return p.Post_fix_expression_Sempred(t, predIndex)

	case 14:
		var t *Multiplicative_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Multiplicative_expressionContext)
		}
		return p.Multiplicative_expression_Sempred(t, predIndex)

	case 15:
		var t *Additive_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Additive_expressionContext)
		}
		return p.Additive_expression_Sempred(t, predIndex)

	case 16:
		var t *Shift_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Shift_expressionContext)
		}
		return p.Shift_expression_Sempred(t, predIndex)

	case 18:
		var t *Relational_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Relational_expressionContext)
		}
		return p.Relational_expression_Sempred(t, predIndex)

	case 19:
		var t *Equality_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Equality_expressionContext)
		}
		return p.Equality_expression_Sempred(t, predIndex)

	case 20:
		var t *And_expressionContext = nil
		if localctx != nil {
			t = localctx.(*And_expressionContext)
		}
		return p.And_expression_Sempred(t, predIndex)

	case 21:
		var t *Exclusiveor_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Exclusiveor_expressionContext)
		}
		return p.Exclusiveor_expression_Sempred(t, predIndex)

	case 22:
		var t *Inclusiveor_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Inclusiveor_expressionContext)
		}
		return p.Inclusiveor_expression_Sempred(t, predIndex)

	case 23:
		var t *Logical_and_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Logical_and_expressionContext)
		}
		return p.Logical_and_expression_Sempred(t, predIndex)

	case 24:
		var t *Logical_or_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Logical_or_expressionContext)
		}
		return p.Logical_or_expression_Sempred(t, predIndex)

	case 28:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 34:
		var t *Statement_sequenceContext = nil
		if localctx != nil {
			t = localctx.(*Statement_sequenceContext)
		}
		return p.Statement_sequence_Sempred(t, predIndex)

	case 43:
		var t *Declaration_sequenceContext = nil
		if localctx != nil {
			t = localctx.(*Declaration_sequenceContext)
		}
		return p.Declaration_sequence_Sempred(t, predIndex)

	case 61:
		var t *Enumerator_listContext = nil
		if localctx != nil {
			t = localctx.(*Enumerator_listContext)
		}
		return p.Enumerator_list_Sempred(t, predIndex)

	case 73:
		var t *Init_declarator_listContext = nil
		if localctx != nil {
			t = localctx.(*Init_declarator_listContext)
		}
		return p.Init_declarator_list_Sempred(t, predIndex)

	case 77:
		var t *Noptr_declaratorContext = nil
		if localctx != nil {
			t = localctx.(*Noptr_declaratorContext)
		}
		return p.Noptr_declarator_Sempred(t, predIndex)

	case 85:
		var t *Parameter_declaration_listContext = nil
		if localctx != nil {
			t = localctx.(*Parameter_declaration_listContext)
		}
		return p.Parameter_declaration_list_Sempred(t, predIndex)

	case 92:
		var t *Initializer_listContext = nil
		if localctx != nil {
			t = localctx.(*Initializer_listContext)
		}
		return p.Initializer_list_Sempred(t, predIndex)

	case 100:
		var t *Member_declarator_listContext = nil
		if localctx != nil {
			t = localctx.(*Member_declarator_listContext)
		}
		return p.Member_declarator_list_Sempred(t, predIndex)

	case 103:
		var t *Base_specifier_listContext = nil
		if localctx != nil {
			t = localctx.(*Base_specifier_listContext)
		}
		return p.Base_specifier_list_Sempred(t, predIndex)

	case 112:
		var t *Template_parameter_listContext = nil
		if localctx != nil {
			t = localctx.(*Template_parameter_listContext)
		}
		return p.Template_parameter_list_Sempred(t, predIndex)

	case 117:
		var t *Template_argument_listContext = nil
		if localctx != nil {
			t = localctx.(*Template_argument_listContext)
		}
		return p.Template_argument_list_Sempred(t, predIndex)

	case 127:
		var t *Type_id_listContext = nil
		if localctx != nil {
			t = localctx.(*Type_id_listContext)
		}
		return p.Type_id_list_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *PandaParser) Nested_name_specifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Post_fix_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Multiplicative_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Additive_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Shift_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Relational_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Equality_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) And_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 20:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Exclusiveor_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 21:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Inclusiveor_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 22:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Logical_and_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 23:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Logical_or_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 24:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 25:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Statement_sequence_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 26:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Declaration_sequence_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 27:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Enumerator_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 28:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Init_declarator_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 29:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Noptr_declarator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 30:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 31:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Parameter_declaration_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 32:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Initializer_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 33:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Member_declarator_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 34:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Base_specifier_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 35:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Template_parameter_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 36:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Template_argument_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 37:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Type_id_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 38:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
