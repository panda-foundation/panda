// Code generated from PandaParser.g4 by ANTLR 4.7.1. DO NOT EDIT.

package compiler // PandaParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 111, 1142,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	3, 2, 5, 2, 214, 10, 2, 3, 2, 5, 2, 217, 10, 2, 3, 2, 5, 2, 220, 10, 2,
	3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 231, 10, 3,
	3, 4, 3, 4, 5, 4, 235, 10, 4, 3, 5, 3, 5, 3, 5, 5, 5, 240, 10, 5, 3, 6,
	3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 252, 10, 7,
	3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 7, 7, 261, 10, 7, 12, 7, 14,
	7, 264, 11, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 271, 10, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 3, 8, 5, 8, 278, 10, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3,
	8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 296,
	10, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 306, 10, 8,
	3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 7, 8, 316, 10, 8, 12, 8,
	14, 8, 319, 11, 8, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 5, 10, 332, 10, 10, 3, 11, 3, 11, 3, 12, 3, 12, 3,
	12, 3, 12, 3, 13, 3, 13, 5, 13, 342, 10, 13, 3, 13, 3, 13, 5, 13, 346,
	10, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 7, 14, 360, 10, 14, 12, 14, 14, 14, 363, 11, 14, 3,
	15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15, 374,
	10, 15, 12, 15, 14, 15, 377, 11, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
	3, 16, 3, 16, 7, 16, 386, 10, 16, 12, 16, 14, 16, 389, 11, 16, 3, 17, 3,
	17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 7, 18, 408, 10, 18, 12, 18, 14, 18,
	411, 11, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3,
	19, 7, 19, 422, 10, 19, 12, 19, 14, 19, 425, 11, 19, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 7, 20, 433, 10, 20, 12, 20, 14, 20, 436, 11, 20, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 7, 21, 444, 10, 21, 12, 21, 14,
	21, 447, 11, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 7, 22, 455,
	10, 22, 12, 22, 14, 22, 458, 11, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 7, 23, 466, 10, 23, 12, 23, 14, 23, 469, 11, 23, 3, 24, 3, 24, 3,
	24, 3, 24, 3, 24, 3, 24, 7, 24, 477, 10, 24, 12, 24, 14, 24, 480, 11, 24,
	3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25, 489, 10, 25, 3,
	26, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 497, 10, 26, 3, 27, 3, 27,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 507, 10, 28, 12, 28, 14,
	28, 510, 11, 28, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 5, 30, 522, 10, 30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3,
	31, 3, 31, 3, 31, 5, 31, 532, 10, 31, 3, 32, 5, 32, 535, 10, 32, 3, 32,
	3, 32, 3, 33, 3, 33, 5, 33, 541, 10, 33, 3, 33, 3, 33, 3, 34, 3, 34, 3,
	34, 3, 34, 3, 34, 7, 34, 550, 10, 34, 12, 34, 14, 34, 553, 11, 34, 3, 35,
	3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 575,
	10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36,
	3, 36, 5, 36, 587, 10, 36, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 593, 10,
	37, 3, 37, 3, 37, 5, 37, 597, 10, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 610, 10, 37, 3, 38, 3,
	38, 5, 38, 614, 10, 38, 3, 39, 3, 39, 3, 39, 3, 40, 3, 40, 5, 40, 621,
	10, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 629, 10, 41, 3,
	41, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 636, 10, 41, 3, 42, 3, 42, 3, 43,
	3, 43, 3, 43, 3, 43, 3, 43, 7, 43, 645, 10, 43, 12, 43, 14, 43, 648, 11,
	43, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 655, 10, 44, 3, 45, 5, 45,
	658, 10, 45, 3, 45, 5, 45, 661, 10, 45, 3, 45, 3, 45, 3, 46, 3, 46, 3,
	47, 5, 47, 668, 10, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 48, 3, 48, 5, 48,
	676, 10, 48, 3, 49, 3, 49, 3, 49, 3, 49, 5, 49, 682, 10, 49, 3, 50, 5,
	50, 685, 10, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3,
	50, 3, 50, 3, 50, 3, 50, 5, 50, 709, 10, 50, 3, 51, 3, 51, 3, 51, 5, 51,
	714, 10, 51, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 5, 53, 721, 10, 53, 3,
	53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53, 731, 10, 53,
	3, 54, 3, 54, 5, 54, 735, 10, 54, 3, 54, 5, 54, 738, 10, 54, 3, 55, 3,
	55, 3, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 7, 56, 749, 10, 56,
	12, 56, 14, 56, 752, 11, 56, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 5, 57,
	759, 10, 57, 3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 7,
	59, 769, 10, 59, 12, 59, 14, 59, 772, 11, 59, 3, 60, 3, 60, 5, 60, 776,
	10, 60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62,
	3, 62, 3, 62, 7, 62, 789, 10, 62, 12, 62, 14, 62, 792, 11, 62, 3, 63, 3,
	63, 3, 63, 3, 63, 3, 63, 3, 63, 7, 63, 800, 10, 63, 12, 63, 14, 63, 803,
	11, 63, 3, 64, 3, 64, 5, 64, 807, 10, 64, 3, 65, 3, 65, 3, 65, 3, 65, 5,
	65, 813, 10, 65, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 819, 10, 66, 3, 67,
	3, 67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 827, 10, 67, 3, 67, 3, 67, 7,
	67, 831, 10, 67, 12, 67, 14, 67, 834, 11, 67, 3, 68, 3, 68, 3, 68, 3, 68,
	3, 69, 3, 69, 3, 70, 5, 70, 843, 10, 70, 3, 70, 3, 70, 3, 71, 3, 71, 3,
	72, 5, 72, 850, 10, 72, 3, 72, 5, 72, 853, 10, 72, 3, 72, 3, 72, 3, 72,
	3, 72, 5, 72, 859, 10, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 7,
	73, 867, 10, 73, 12, 73, 14, 73, 870, 11, 73, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 885,
	10, 74, 3, 75, 5, 75, 888, 10, 75, 3, 75, 5, 75, 891, 10, 75, 3, 75, 3,
	75, 3, 75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 901, 10, 76, 3, 77,
	3, 77, 3, 77, 5, 77, 906, 10, 77, 3, 78, 3, 78, 5, 78, 910, 10, 78, 3,
	79, 3, 79, 3, 79, 5, 79, 915, 10, 79, 3, 79, 3, 79, 3, 79, 3, 79, 5, 79,
	921, 10, 79, 7, 79, 923, 10, 79, 12, 79, 14, 79, 926, 11, 79, 3, 80, 3,
	80, 3, 80, 5, 80, 931, 10, 80, 3, 80, 3, 80, 3, 80, 3, 80, 5, 80, 937,
	10, 80, 3, 81, 3, 81, 3, 81, 5, 81, 942, 10, 81, 3, 81, 3, 81, 5, 81, 946,
	10, 81, 3, 81, 3, 81, 3, 82, 3, 82, 5, 82, 952, 10, 82, 3, 83, 3, 83, 5,
	83, 956, 10, 83, 3, 84, 5, 84, 959, 10, 84, 3, 84, 5, 84, 962, 10, 84,
	3, 84, 3, 84, 3, 84, 5, 84, 967, 10, 84, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 3, 85, 7, 85, 975, 10, 85, 12, 85, 14, 85, 978, 11, 85, 3, 86, 3, 86,
	3, 86, 5, 86, 983, 10, 86, 5, 86, 985, 10, 86, 3, 87, 3, 87, 3, 87, 3,
	87, 3, 87, 7, 87, 992, 10, 87, 12, 87, 14, 87, 995, 11, 87, 3, 88, 3, 88,
	3, 88, 5, 88, 1000, 10, 88, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 3, 91, 3,
	91, 3, 91, 3, 91, 3, 91, 3, 91, 7, 91, 1013, 10, 91, 12, 91, 14, 91, 1016,
	11, 91, 3, 92, 5, 92, 1019, 10, 92, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93,
	3, 94, 3, 94, 3, 94, 3, 95, 3, 95, 5, 95, 1031, 10, 95, 3, 95, 3, 95, 3,
	96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 7, 96, 1041, 10, 96, 12, 96, 14,
	96, 1044, 11, 96, 3, 97, 3, 97, 3, 97, 5, 97, 1049, 10, 97, 3, 98, 3, 98,
	3, 98, 3, 98, 3, 98, 3, 98, 5, 98, 1057, 10, 98, 3, 99, 3, 99, 3, 99, 5,
	99, 1062, 10, 99, 3, 99, 3, 99, 3, 99, 3, 99, 5, 99, 1068, 10, 99, 7, 99,
	1070, 10, 99, 12, 99, 14, 99, 1073, 11, 99, 3, 100, 3, 100, 3, 100, 3,
	100, 3, 101, 3, 101, 5, 101, 1081, 10, 101, 3, 102, 3, 102, 3, 102, 3,
	102, 3, 102, 3, 102, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 5, 103, 1094,
	10, 103, 3, 104, 3, 104, 5, 104, 1098, 10, 104, 3, 105, 3, 105, 3, 105,
	3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105,
	3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105,
	3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105,
	3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 105, 5, 105,
	1138, 10, 105, 3, 106, 3, 106, 3, 106, 2, 29, 12, 14, 26, 28, 30, 34, 36,
	38, 40, 42, 44, 46, 54, 66, 84, 110, 116, 122, 124, 132, 144, 156, 168,
	172, 180, 190, 196, 107, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
	28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
	64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
	100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
	130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
	160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
	190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 2, 7, 4, 2, 60,
	61, 67, 69, 3, 2, 80, 81, 5, 2, 70, 70, 73, 79, 82, 83, 3, 2, 34, 36, 4,
	2, 99, 99, 104, 107, 2, 1242, 2, 213, 3, 2, 2, 2, 4, 230, 3, 2, 2, 2, 6,
	234, 3, 2, 2, 2, 8, 239, 3, 2, 2, 2, 10, 241, 3, 2, 2, 2, 12, 251, 3, 2,
	2, 2, 14, 295, 3, 2, 2, 2, 16, 320, 3, 2, 2, 2, 18, 331, 3, 2, 2, 2, 20,
	333, 3, 2, 2, 2, 22, 335, 3, 2, 2, 2, 24, 345, 3, 2, 2, 2, 26, 347, 3,
	2, 2, 2, 28, 364, 3, 2, 2, 2, 30, 378, 3, 2, 2, 2, 32, 390, 3, 2, 2, 2,
	34, 392, 3, 2, 2, 2, 36, 412, 3, 2, 2, 2, 38, 426, 3, 2, 2, 2, 40, 437,
	3, 2, 2, 2, 42, 448, 3, 2, 2, 2, 44, 459, 3, 2, 2, 2, 46, 470, 3, 2, 2,
	2, 48, 488, 3, 2, 2, 2, 50, 496, 3, 2, 2, 2, 52, 498, 3, 2, 2, 2, 54, 500,
	3, 2, 2, 2, 56, 511, 3, 2, 2, 2, 58, 521, 3, 2, 2, 2, 60, 531, 3, 2, 2,
	2, 62, 534, 3, 2, 2, 2, 64, 538, 3, 2, 2, 2, 66, 544, 3, 2, 2, 2, 68, 574,
	3, 2, 2, 2, 70, 586, 3, 2, 2, 2, 72, 609, 3, 2, 2, 2, 74, 613, 3, 2, 2,
	2, 76, 615, 3, 2, 2, 2, 78, 620, 3, 2, 2, 2, 80, 635, 3, 2, 2, 2, 82, 637,
	3, 2, 2, 2, 84, 639, 3, 2, 2, 2, 86, 654, 3, 2, 2, 2, 88, 657, 3, 2, 2,
	2, 90, 664, 3, 2, 2, 2, 92, 667, 3, 2, 2, 2, 94, 675, 3, 2, 2, 2, 96, 681,
	3, 2, 2, 2, 98, 708, 3, 2, 2, 2, 100, 713, 3, 2, 2, 2, 102, 715, 3, 2,
	2, 2, 104, 730, 3, 2, 2, 2, 106, 732, 3, 2, 2, 2, 108, 739, 3, 2, 2, 2,
	110, 742, 3, 2, 2, 2, 112, 758, 3, 2, 2, 2, 114, 760, 3, 2, 2, 2, 116,
	762, 3, 2, 2, 2, 118, 773, 3, 2, 2, 2, 120, 779, 3, 2, 2, 2, 122, 783,
	3, 2, 2, 2, 124, 793, 3, 2, 2, 2, 126, 804, 3, 2, 2, 2, 128, 812, 3, 2,
	2, 2, 130, 818, 3, 2, 2, 2, 132, 826, 3, 2, 2, 2, 134, 835, 3, 2, 2, 2,
	136, 839, 3, 2, 2, 2, 138, 842, 3, 2, 2, 2, 140, 846, 3, 2, 2, 2, 142,
	858, 3, 2, 2, 2, 144, 860, 3, 2, 2, 2, 146, 884, 3, 2, 2, 2, 148, 887,
	3, 2, 2, 2, 150, 900, 3, 2, 2, 2, 152, 905, 3, 2, 2, 2, 154, 909, 3, 2,
	2, 2, 156, 911, 3, 2, 2, 2, 158, 936, 3, 2, 2, 2, 160, 938, 3, 2, 2, 2,
	162, 951, 3, 2, 2, 2, 164, 953, 3, 2, 2, 2, 166, 966, 3, 2, 2, 2, 168,
	968, 3, 2, 2, 2, 170, 984, 3, 2, 2, 2, 172, 986, 3, 2, 2, 2, 174, 999,
	3, 2, 2, 2, 176, 1001, 3, 2, 2, 2, 178, 1003, 3, 2, 2, 2, 180, 1006, 3,
	2, 2, 2, 182, 1018, 3, 2, 2, 2, 184, 1022, 3, 2, 2, 2, 186, 1025, 3, 2,
	2, 2, 188, 1028, 3, 2, 2, 2, 190, 1034, 3, 2, 2, 2, 192, 1048, 3, 2, 2,
	2, 194, 1056, 3, 2, 2, 2, 196, 1058, 3, 2, 2, 2, 198, 1074, 3, 2, 2, 2,
	200, 1078, 3, 2, 2, 2, 202, 1082, 3, 2, 2, 2, 204, 1093, 3, 2, 2, 2, 206,
	1095, 3, 2, 2, 2, 208, 1137, 3, 2, 2, 2, 210, 1139, 3, 2, 2, 2, 212, 214,
	5, 118, 60, 2, 213, 212, 3, 2, 2, 2, 213, 214, 3, 2, 2, 2, 214, 216, 3,
	2, 2, 2, 215, 217, 5, 122, 62, 2, 216, 215, 3, 2, 2, 2, 216, 217, 3, 2,
	2, 2, 217, 219, 3, 2, 2, 2, 218, 220, 5, 84, 43, 2, 219, 218, 3, 2, 2,
	2, 219, 220, 3, 2, 2, 2, 220, 221, 3, 2, 2, 2, 221, 222, 7, 2, 2, 3, 222,
	3, 3, 2, 2, 2, 223, 231, 5, 210, 106, 2, 224, 231, 7, 41, 2, 2, 225, 226,
	7, 54, 2, 2, 226, 227, 5, 54, 28, 2, 227, 228, 7, 55, 2, 2, 228, 231, 3,
	2, 2, 2, 229, 231, 5, 6, 4, 2, 230, 223, 3, 2, 2, 2, 230, 224, 3, 2, 2,
	2, 230, 225, 3, 2, 2, 2, 230, 229, 3, 2, 2, 2, 231, 5, 3, 2, 2, 2, 232,
	235, 5, 8, 5, 2, 233, 235, 5, 10, 6, 2, 234, 232, 3, 2, 2, 2, 234, 233,
	3, 2, 2, 2, 235, 7, 3, 2, 2, 2, 236, 240, 7, 98, 2, 2, 237, 240, 5, 184,
	93, 2, 238, 240, 5, 186, 94, 2, 239, 236, 3, 2, 2, 2, 239, 237, 3, 2, 2,
	2, 239, 238, 3, 2, 2, 2, 240, 9, 3, 2, 2, 2, 241, 242, 5, 12, 7, 2, 242,
	243, 5, 8, 5, 2, 243, 11, 3, 2, 2, 2, 244, 245, 8, 7, 1, 2, 245, 246, 5,
	100, 51, 2, 246, 247, 7, 96, 2, 2, 247, 252, 3, 2, 2, 2, 248, 249, 5, 116,
	59, 2, 249, 250, 7, 96, 2, 2, 250, 252, 3, 2, 2, 2, 251, 244, 3, 2, 2,
	2, 251, 248, 3, 2, 2, 2, 252, 262, 3, 2, 2, 2, 253, 254, 12, 4, 2, 2, 254,
	255, 7, 98, 2, 2, 255, 261, 7, 96, 2, 2, 256, 257, 12, 3, 2, 2, 257, 258,
	5, 186, 94, 2, 258, 259, 7, 96, 2, 2, 259, 261, 3, 2, 2, 2, 260, 253, 3,
	2, 2, 2, 260, 256, 3, 2, 2, 2, 261, 264, 3, 2, 2, 2, 262, 260, 3, 2, 2,
	2, 262, 263, 3, 2, 2, 2, 263, 13, 3, 2, 2, 2, 264, 262, 3, 2, 2, 2, 265,
	266, 8, 8, 1, 2, 266, 296, 5, 4, 3, 2, 267, 268, 5, 98, 50, 2, 268, 270,
	7, 54, 2, 2, 269, 271, 5, 16, 9, 2, 270, 269, 3, 2, 2, 2, 270, 271, 3,
	2, 2, 2, 271, 272, 3, 2, 2, 2, 272, 273, 7, 55, 2, 2, 273, 296, 3, 2, 2,
	2, 274, 275, 5, 194, 98, 2, 275, 277, 7, 54, 2, 2, 276, 278, 5, 16, 9,
	2, 277, 276, 3, 2, 2, 2, 277, 278, 3, 2, 2, 2, 278, 279, 3, 2, 2, 2, 279,
	280, 7, 55, 2, 2, 280, 296, 3, 2, 2, 2, 281, 282, 5, 98, 50, 2, 282, 283,
	5, 158, 80, 2, 283, 296, 3, 2, 2, 2, 284, 285, 5, 194, 98, 2, 285, 286,
	5, 158, 80, 2, 286, 296, 3, 2, 2, 2, 287, 288, 7, 8, 2, 2, 288, 289, 7,
	71, 2, 2, 289, 290, 5, 140, 71, 2, 290, 291, 7, 72, 2, 2, 291, 292, 7,
	54, 2, 2, 292, 293, 5, 54, 28, 2, 293, 294, 7, 55, 2, 2, 294, 296, 3, 2,
	2, 2, 295, 265, 3, 2, 2, 2, 295, 267, 3, 2, 2, 2, 295, 274, 3, 2, 2, 2,
	295, 281, 3, 2, 2, 2, 295, 284, 3, 2, 2, 2, 295, 287, 3, 2, 2, 2, 296,
	317, 3, 2, 2, 2, 297, 298, 12, 12, 2, 2, 298, 299, 7, 56, 2, 2, 299, 300,
	5, 54, 28, 2, 300, 301, 7, 57, 2, 2, 301, 316, 3, 2, 2, 2, 302, 303, 12,
	11, 2, 2, 303, 305, 7, 54, 2, 2, 304, 306, 5, 16, 9, 2, 305, 304, 3, 2,
	2, 2, 305, 306, 3, 2, 2, 2, 306, 307, 3, 2, 2, 2, 307, 316, 7, 55, 2, 2,
	308, 309, 12, 6, 2, 2, 309, 310, 7, 96, 2, 2, 310, 316, 5, 6, 4, 2, 311,
	312, 12, 5, 2, 2, 312, 316, 7, 90, 2, 2, 313, 314, 12, 4, 2, 2, 314, 316,
	7, 91, 2, 2, 315, 297, 3, 2, 2, 2, 315, 302, 3, 2, 2, 2, 315, 308, 3, 2,
	2, 2, 315, 311, 3, 2, 2, 2, 315, 313, 3, 2, 2, 2, 316, 319, 3, 2, 2, 2,
	317, 315, 3, 2, 2, 2, 317, 318, 3, 2, 2, 2, 318, 15, 3, 2, 2, 2, 319, 317,
	3, 2, 2, 2, 320, 321, 5, 156, 79, 2, 321, 17, 3, 2, 2, 2, 322, 332, 5,
	14, 8, 2, 323, 324, 7, 90, 2, 2, 324, 332, 5, 18, 10, 2, 325, 326, 7, 91,
	2, 2, 326, 332, 5, 18, 10, 2, 327, 328, 5, 20, 11, 2, 328, 329, 5, 18,
	10, 2, 329, 332, 3, 2, 2, 2, 330, 332, 5, 22, 12, 2, 331, 322, 3, 2, 2,
	2, 331, 323, 3, 2, 2, 2, 331, 325, 3, 2, 2, 2, 331, 327, 3, 2, 2, 2, 331,
	330, 3, 2, 2, 2, 332, 19, 3, 2, 2, 2, 333, 334, 9, 2, 2, 2, 334, 21, 3,
	2, 2, 2, 335, 336, 7, 31, 2, 2, 336, 337, 5, 96, 49, 2, 337, 338, 5, 24,
	13, 2, 338, 23, 3, 2, 2, 2, 339, 341, 7, 54, 2, 2, 340, 342, 5, 16, 9,
	2, 341, 340, 3, 2, 2, 2, 341, 342, 3, 2, 2, 2, 342, 343, 3, 2, 2, 2, 343,
	346, 7, 55, 2, 2, 344, 346, 5, 158, 80, 2, 345, 339, 3, 2, 2, 2, 345, 344,
	3, 2, 2, 2, 346, 25, 3, 2, 2, 2, 347, 348, 8, 14, 1, 2, 348, 349, 5, 18,
	10, 2, 349, 361, 3, 2, 2, 2, 350, 351, 12, 5, 2, 2, 351, 352, 7, 62, 2,
	2, 352, 360, 5, 18, 10, 2, 353, 354, 12, 4, 2, 2, 354, 355, 7, 63, 2, 2,
	355, 360, 5, 18, 10, 2, 356, 357, 12, 3, 2, 2, 357, 358, 7, 64, 2, 2, 358,
	360, 5, 18, 10, 2, 359, 350, 3, 2, 2, 2, 359, 353, 3, 2, 2, 2, 359, 356,
	3, 2, 2, 2, 360, 363, 3, 2, 2, 2, 361, 359, 3, 2, 2, 2, 361, 362, 3, 2,
	2, 2, 362, 27, 3, 2, 2, 2, 363, 361, 3, 2, 2, 2, 364, 365, 8, 15, 1, 2,
	365, 366, 5, 26, 14, 2, 366, 375, 3, 2, 2, 2, 367, 368, 12, 4, 2, 2, 368,
	369, 7, 60, 2, 2, 369, 374, 5, 26, 14, 2, 370, 371, 12, 3, 2, 2, 371, 372,
	7, 61, 2, 2, 372, 374, 5, 26, 14, 2, 373, 367, 3, 2, 2, 2, 373, 370, 3,
	2, 2, 2, 374, 377, 3, 2, 2, 2, 375, 373, 3, 2, 2, 2, 375, 376, 3, 2, 2,
	2, 376, 29, 3, 2, 2, 2, 377, 375, 3, 2, 2, 2, 378, 379, 8, 16, 1, 2, 379,
	380, 5, 28, 15, 2, 380, 387, 3, 2, 2, 2, 381, 382, 12, 3, 2, 2, 382, 383,
	5, 32, 17, 2, 383, 384, 5, 28, 15, 2, 384, 386, 3, 2, 2, 2, 385, 381, 3,
	2, 2, 2, 386, 389, 3, 2, 2, 2, 387, 385, 3, 2, 2, 2, 387, 388, 3, 2, 2,
	2, 388, 31, 3, 2, 2, 2, 389, 387, 3, 2, 2, 2, 390, 391, 9, 3, 2, 2, 391,
	33, 3, 2, 2, 2, 392, 393, 8, 18, 1, 2, 393, 394, 5, 30, 16, 2, 394, 409,
	3, 2, 2, 2, 395, 396, 12, 6, 2, 2, 396, 397, 7, 71, 2, 2, 397, 408, 5,
	30, 16, 2, 398, 399, 12, 5, 2, 2, 399, 400, 7, 72, 2, 2, 400, 408, 5, 30,
	16, 2, 401, 402, 12, 4, 2, 2, 402, 403, 7, 86, 2, 2, 403, 408, 5, 30, 16,
	2, 404, 405, 12, 3, 2, 2, 405, 406, 7, 87, 2, 2, 406, 408, 5, 30, 16, 2,
	407, 395, 3, 2, 2, 2, 407, 398, 3, 2, 2, 2, 407, 401, 3, 2, 2, 2, 407,
	404, 3, 2, 2, 2, 408, 411, 3, 2, 2, 2, 409, 407, 3, 2, 2, 2, 409, 410,
	3, 2, 2, 2, 410, 35, 3, 2, 2, 2, 411, 409, 3, 2, 2, 2, 412, 413, 8, 19,
	1, 2, 413, 414, 5, 34, 18, 2, 414, 423, 3, 2, 2, 2, 415, 416, 12, 4, 2,
	2, 416, 417, 7, 84, 2, 2, 417, 422, 5, 34, 18, 2, 418, 419, 12, 3, 2, 2,
	419, 420, 7, 85, 2, 2, 420, 422, 5, 34, 18, 2, 421, 415, 3, 2, 2, 2, 421,
	418, 3, 2, 2, 2, 422, 425, 3, 2, 2, 2, 423, 421, 3, 2, 2, 2, 423, 424,
	3, 2, 2, 2, 424, 37, 3, 2, 2, 2, 425, 423, 3, 2, 2, 2, 426, 427, 8, 20,
	1, 2, 427, 428, 5, 36, 19, 2, 428, 434, 3, 2, 2, 2, 429, 430, 12, 3, 2,
	2, 430, 431, 7, 66, 2, 2, 431, 433, 5, 36, 19, 2, 432, 429, 3, 2, 2, 2,
	433, 436, 3, 2, 2, 2, 434, 432, 3, 2, 2, 2, 434, 435, 3, 2, 2, 2, 435,
	39, 3, 2, 2, 2, 436, 434, 3, 2, 2, 2, 437, 438, 8, 21, 1, 2, 438, 439,
	5, 38, 20, 2, 439, 445, 3, 2, 2, 2, 440, 441, 12, 3, 2, 2, 441, 442, 7,
	65, 2, 2, 442, 444, 5, 38, 20, 2, 443, 440, 3, 2, 2, 2, 444, 447, 3, 2,
	2, 2, 445, 443, 3, 2, 2, 2, 445, 446, 3, 2, 2, 2, 446, 41, 3, 2, 2, 2,
	447, 445, 3, 2, 2, 2, 448, 449, 8, 22, 1, 2, 449, 450, 5, 40, 21, 2, 450,
	456, 3, 2, 2, 2, 451, 452, 12, 3, 2, 2, 452, 453, 7, 67, 2, 2, 453, 455,
	5, 40, 21, 2, 454, 451, 3, 2, 2, 2, 455, 458, 3, 2, 2, 2, 456, 454, 3,
	2, 2, 2, 456, 457, 3, 2, 2, 2, 457, 43, 3, 2, 2, 2, 458, 456, 3, 2, 2,
	2, 459, 460, 8, 23, 1, 2, 460, 461, 5, 42, 22, 2, 461, 467, 3, 2, 2, 2,
	462, 463, 12, 3, 2, 2, 463, 464, 7, 88, 2, 2, 464, 466, 5, 42, 22, 2, 465,
	462, 3, 2, 2, 2, 466, 469, 3, 2, 2, 2, 467, 465, 3, 2, 2, 2, 467, 468,
	3, 2, 2, 2, 468, 45, 3, 2, 2, 2, 469, 467, 3, 2, 2, 2, 470, 471, 8, 24,
	1, 2, 471, 472, 5, 44, 23, 2, 472, 478, 3, 2, 2, 2, 473, 474, 12, 3, 2,
	2, 474, 475, 7, 89, 2, 2, 475, 477, 5, 44, 23, 2, 476, 473, 3, 2, 2, 2,
	477, 480, 3, 2, 2, 2, 478, 476, 3, 2, 2, 2, 478, 479, 3, 2, 2, 2, 479,
	47, 3, 2, 2, 2, 480, 478, 3, 2, 2, 2, 481, 489, 5, 46, 24, 2, 482, 483,
	5, 46, 24, 2, 483, 484, 7, 93, 2, 2, 484, 485, 5, 54, 28, 2, 485, 486,
	7, 94, 2, 2, 486, 487, 5, 50, 26, 2, 487, 489, 3, 2, 2, 2, 488, 481, 3,
	2, 2, 2, 488, 482, 3, 2, 2, 2, 489, 49, 3, 2, 2, 2, 490, 497, 5, 48, 25,
	2, 491, 492, 5, 46, 24, 2, 492, 493, 5, 52, 27, 2, 493, 494, 5, 154, 78,
	2, 494, 497, 3, 2, 2, 2, 495, 497, 5, 206, 104, 2, 496, 490, 3, 2, 2, 2,
	496, 491, 3, 2, 2, 2, 496, 495, 3, 2, 2, 2, 497, 51, 3, 2, 2, 2, 498, 499,
	9, 4, 2, 2, 499, 53, 3, 2, 2, 2, 500, 501, 8, 28, 1, 2, 501, 502, 5, 50,
	26, 2, 502, 508, 3, 2, 2, 2, 503, 504, 12, 3, 2, 2, 504, 505, 7, 92, 2,
	2, 505, 507, 5, 50, 26, 2, 506, 503, 3, 2, 2, 2, 507, 510, 3, 2, 2, 2,
	508, 506, 3, 2, 2, 2, 508, 509, 3, 2, 2, 2, 509, 55, 3, 2, 2, 2, 510, 508,
	3, 2, 2, 2, 511, 512, 5, 48, 25, 2, 512, 57, 3, 2, 2, 2, 513, 522, 5, 60,
	31, 2, 514, 522, 5, 62, 32, 2, 515, 522, 5, 64, 33, 2, 516, 522, 5, 68,
	35, 2, 517, 522, 5, 72, 37, 2, 518, 522, 5, 80, 41, 2, 519, 522, 5, 82,
	42, 2, 520, 522, 5, 198, 100, 2, 521, 513, 3, 2, 2, 2, 521, 514, 3, 2,
	2, 2, 521, 515, 3, 2, 2, 2, 521, 516, 3, 2, 2, 2, 521, 517, 3, 2, 2, 2,
	521, 518, 3, 2, 2, 2, 521, 519, 3, 2, 2, 2, 521, 520, 3, 2, 2, 2, 522,
	59, 3, 2, 2, 2, 523, 524, 7, 7, 2, 2, 524, 525, 5, 56, 29, 2, 525, 526,
	7, 94, 2, 2, 526, 527, 5, 58, 30, 2, 527, 532, 3, 2, 2, 2, 528, 529, 7,
	13, 2, 2, 529, 530, 7, 94, 2, 2, 530, 532, 5, 58, 30, 2, 531, 523, 3, 2,
	2, 2, 531, 528, 3, 2, 2, 2, 532, 61, 3, 2, 2, 2, 533, 535, 5, 54, 28, 2,
	534, 533, 3, 2, 2, 2, 534, 535, 3, 2, 2, 2, 535, 536, 3, 2, 2, 2, 536,
	537, 7, 95, 2, 2, 537, 63, 3, 2, 2, 2, 538, 540, 7, 58, 2, 2, 539, 541,
	5, 66, 34, 2, 540, 539, 3, 2, 2, 2, 540, 541, 3, 2, 2, 2, 541, 542, 3,
	2, 2, 2, 542, 543, 7, 59, 2, 2, 543, 65, 3, 2, 2, 2, 544, 545, 8, 34, 1,
	2, 545, 546, 5, 58, 30, 2, 546, 551, 3, 2, 2, 2, 547, 548, 12, 3, 2, 2,
	548, 550, 5, 58, 30, 2, 549, 547, 3, 2, 2, 2, 550, 553, 3, 2, 2, 2, 551,
	549, 3, 2, 2, 2, 551, 552, 3, 2, 2, 2, 552, 67, 3, 2, 2, 2, 553, 551, 3,
	2, 2, 2, 554, 555, 7, 23, 2, 2, 555, 556, 7, 54, 2, 2, 556, 557, 5, 70,
	36, 2, 557, 558, 7, 55, 2, 2, 558, 559, 5, 58, 30, 2, 559, 575, 3, 2, 2,
	2, 560, 561, 7, 23, 2, 2, 561, 562, 7, 54, 2, 2, 562, 563, 5, 70, 36, 2,
	563, 564, 7, 55, 2, 2, 564, 565, 5, 58, 30, 2, 565, 566, 7, 15, 2, 2, 566,
	567, 5, 58, 30, 2, 567, 575, 3, 2, 2, 2, 568, 569, 7, 40, 2, 2, 569, 570,
	7, 54, 2, 2, 570, 571, 5, 70, 36, 2, 571, 572, 7, 55, 2, 2, 572, 573, 5,
	58, 30, 2, 573, 575, 3, 2, 2, 2, 574, 554, 3, 2, 2, 2, 574, 560, 3, 2,
	2, 2, 574, 568, 3, 2, 2, 2, 575, 69, 3, 2, 2, 2, 576, 587, 5, 54, 28, 2,
	577, 578, 5, 94, 48, 2, 578, 579, 5, 128, 65, 2, 579, 580, 7, 70, 2, 2,
	580, 581, 5, 154, 78, 2, 581, 587, 3, 2, 2, 2, 582, 583, 5, 94, 48, 2,
	583, 584, 5, 128, 65, 2, 584, 585, 5, 158, 80, 2, 585, 587, 3, 2, 2, 2,
	586, 576, 3, 2, 2, 2, 586, 577, 3, 2, 2, 2, 586, 582, 3, 2, 2, 2, 587,
	71, 3, 2, 2, 2, 588, 589, 7, 21, 2, 2, 589, 590, 7, 54, 2, 2, 590, 592,
	5, 74, 38, 2, 591, 593, 5, 70, 36, 2, 592, 591, 3, 2, 2, 2, 592, 593, 3,
	2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 596, 7, 95, 2, 2, 595, 597, 5, 54,
	28, 2, 596, 595, 3, 2, 2, 2, 596, 597, 3, 2, 2, 2, 597, 598, 3, 2, 2, 2,
	598, 599, 7, 55, 2, 2, 599, 600, 5, 58, 30, 2, 600, 610, 3, 2, 2, 2, 601,
	602, 7, 21, 2, 2, 602, 603, 7, 54, 2, 2, 603, 604, 5, 76, 39, 2, 604, 605,
	7, 94, 2, 2, 605, 606, 5, 78, 40, 2, 606, 607, 7, 55, 2, 2, 607, 608, 5,
	58, 30, 2, 608, 610, 3, 2, 2, 2, 609, 588, 3, 2, 2, 2, 609, 601, 3, 2,
	2, 2, 610, 73, 3, 2, 2, 2, 611, 614, 5, 62, 32, 2, 612, 614, 5, 88, 45,
	2, 613, 611, 3, 2, 2, 2, 613, 612, 3, 2, 2, 2, 614, 75, 3, 2, 2, 2, 615,
	616, 5, 94, 48, 2, 616, 617, 5, 128, 65, 2, 617, 77, 3, 2, 2, 2, 618, 621,
	5, 54, 28, 2, 619, 621, 5, 158, 80, 2, 620, 618, 3, 2, 2, 2, 620, 619,
	3, 2, 2, 2, 621, 79, 3, 2, 2, 2, 622, 623, 7, 5, 2, 2, 623, 636, 7, 95,
	2, 2, 624, 625, 7, 12, 2, 2, 625, 636, 7, 95, 2, 2, 626, 628, 7, 37, 2,
	2, 627, 629, 5, 54, 28, 2, 628, 627, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2,
	629, 630, 3, 2, 2, 2, 630, 636, 7, 95, 2, 2, 631, 632, 7, 37, 2, 2, 632,
	633, 5, 158, 80, 2, 633, 634, 7, 95, 2, 2, 634, 636, 3, 2, 2, 2, 635, 622,
	3, 2, 2, 2, 635, 624, 3, 2, 2, 2, 635, 626, 3, 2, 2, 2, 635, 631, 3, 2,
	2, 2, 636, 81, 3, 2, 2, 2, 637, 638, 5, 88, 45, 2, 638, 83, 3, 2, 2, 2,
	639, 640, 8, 43, 1, 2, 640, 641, 5, 86, 44, 2, 641, 646, 3, 2, 2, 2, 642,
	643, 12, 3, 2, 2, 643, 645, 5, 86, 44, 2, 644, 642, 3, 2, 2, 2, 645, 648,
	3, 2, 2, 2, 646, 644, 3, 2, 2, 2, 646, 647, 3, 2, 2, 2, 647, 85, 3, 2,
	2, 2, 648, 646, 3, 2, 2, 2, 649, 655, 5, 88, 45, 2, 650, 655, 5, 148, 75,
	2, 651, 655, 5, 104, 53, 2, 652, 655, 5, 160, 81, 2, 653, 655, 5, 90, 46,
	2, 654, 649, 3, 2, 2, 2, 654, 650, 3, 2, 2, 2, 654, 651, 3, 2, 2, 2, 654,
	652, 3, 2, 2, 2, 654, 653, 3, 2, 2, 2, 655, 87, 3, 2, 2, 2, 656, 658, 5,
	94, 48, 2, 657, 656, 3, 2, 2, 2, 657, 658, 3, 2, 2, 2, 658, 660, 3, 2,
	2, 2, 659, 661, 5, 124, 63, 2, 660, 659, 3, 2, 2, 2, 660, 661, 3, 2, 2,
	2, 661, 662, 3, 2, 2, 2, 662, 663, 7, 95, 2, 2, 663, 89, 3, 2, 2, 2, 664,
	665, 7, 95, 2, 2, 665, 91, 3, 2, 2, 2, 666, 668, 5, 172, 87, 2, 667, 666,
	3, 2, 2, 2, 667, 668, 3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669, 670, 5, 98,
	50, 2, 670, 93, 3, 2, 2, 2, 671, 676, 5, 92, 47, 2, 672, 673, 5, 92, 47,
	2, 673, 674, 5, 94, 48, 2, 674, 676, 3, 2, 2, 2, 675, 671, 3, 2, 2, 2,
	675, 672, 3, 2, 2, 2, 676, 95, 3, 2, 2, 2, 677, 682, 5, 98, 50, 2, 678,
	679, 5, 98, 50, 2, 679, 680, 5, 96, 49, 2, 680, 682, 3, 2, 2, 2, 681, 677,
	3, 2, 2, 2, 681, 678, 3, 2, 2, 2, 682, 97, 3, 2, 2, 2, 683, 685, 5, 12,
	7, 2, 684, 683, 3, 2, 2, 2, 684, 685, 3, 2, 2, 2, 685, 686, 3, 2, 2, 2,
	686, 709, 5, 100, 51, 2, 687, 709, 7, 4, 2, 2, 688, 709, 7, 25, 2, 2, 689,
	709, 7, 26, 2, 2, 690, 709, 7, 27, 2, 2, 691, 709, 7, 28, 2, 2, 692, 709,
	7, 46, 2, 2, 693, 709, 7, 47, 2, 2, 694, 709, 7, 48, 2, 2, 695, 709, 7,
	49, 2, 2, 696, 709, 7, 24, 2, 2, 697, 709, 7, 45, 2, 2, 698, 709, 7, 39,
	2, 2, 699, 709, 7, 51, 2, 2, 700, 709, 7, 29, 2, 2, 701, 709, 7, 50, 2,
	2, 702, 709, 7, 17, 2, 2, 703, 709, 7, 18, 2, 2, 704, 709, 7, 20, 2, 2,
	705, 709, 7, 14, 2, 2, 706, 709, 7, 53, 2, 2, 707, 709, 7, 52, 2, 2, 708,
	684, 3, 2, 2, 2, 708, 687, 3, 2, 2, 2, 708, 688, 3, 2, 2, 2, 708, 689,
	3, 2, 2, 2, 708, 690, 3, 2, 2, 2, 708, 691, 3, 2, 2, 2, 708, 692, 3, 2,
	2, 2, 708, 693, 3, 2, 2, 2, 708, 694, 3, 2, 2, 2, 708, 695, 3, 2, 2, 2,
	708, 696, 3, 2, 2, 2, 708, 697, 3, 2, 2, 2, 708, 698, 3, 2, 2, 2, 708,
	699, 3, 2, 2, 2, 708, 700, 3, 2, 2, 2, 708, 701, 3, 2, 2, 2, 708, 702,
	3, 2, 2, 2, 708, 703, 3, 2, 2, 2, 708, 704, 3, 2, 2, 2, 708, 705, 3, 2,
	2, 2, 708, 706, 3, 2, 2, 2, 708, 707, 3, 2, 2, 2, 709, 99, 3, 2, 2, 2,
	710, 714, 5, 162, 82, 2, 711, 714, 5, 102, 52, 2, 712, 714, 5, 186, 94,
	2, 713, 710, 3, 2, 2, 2, 713, 711, 3, 2, 2, 2, 713, 712, 3, 2, 2, 2, 714,
	101, 3, 2, 2, 2, 715, 716, 7, 98, 2, 2, 716, 103, 3, 2, 2, 2, 717, 718,
	5, 106, 54, 2, 718, 720, 7, 58, 2, 2, 719, 721, 5, 110, 56, 2, 720, 719,
	3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721, 722, 3, 2, 2, 2, 722, 723, 7, 59,
	2, 2, 723, 731, 3, 2, 2, 2, 724, 725, 5, 106, 54, 2, 725, 726, 7, 58, 2,
	2, 726, 727, 5, 110, 56, 2, 727, 728, 7, 92, 2, 2, 728, 729, 7, 59, 2,
	2, 729, 731, 3, 2, 2, 2, 730, 717, 3, 2, 2, 2, 730, 724, 3, 2, 2, 2, 731,
	105, 3, 2, 2, 2, 732, 734, 7, 16, 2, 2, 733, 735, 7, 98, 2, 2, 734, 733,
	3, 2, 2, 2, 734, 735, 3, 2, 2, 2, 735, 737, 3, 2, 2, 2, 736, 738, 5, 108,
	55, 2, 737, 736, 3, 2, 2, 2, 737, 738, 3, 2, 2, 2, 738, 107, 3, 2, 2, 2,
	739, 740, 7, 94, 2, 2, 740, 741, 5, 96, 49, 2, 741, 109, 3, 2, 2, 2, 742,
	743, 8, 56, 1, 2, 743, 744, 5, 112, 57, 2, 744, 750, 3, 2, 2, 2, 745, 746,
	12, 3, 2, 2, 746, 747, 7, 92, 2, 2, 747, 749, 5, 112, 57, 2, 748, 745,
	3, 2, 2, 2, 749, 752, 3, 2, 2, 2, 750, 748, 3, 2, 2, 2, 750, 751, 3, 2,
	2, 2, 751, 111, 3, 2, 2, 2, 752, 750, 3, 2, 2, 2, 753, 759, 5, 114, 58,
	2, 754, 755, 5, 114, 58, 2, 755, 756, 7, 70, 2, 2, 756, 757, 5, 56, 29,
	2, 757, 759, 3, 2, 2, 2, 758, 753, 3, 2, 2, 2, 758, 754, 3, 2, 2, 2, 759,
	113, 3, 2, 2, 2, 760, 761, 7, 98, 2, 2, 761, 115, 3, 2, 2, 2, 762, 763,
	8, 59, 1, 2, 763, 764, 7, 98, 2, 2, 764, 770, 3, 2, 2, 2, 765, 766, 12,
	3, 2, 2, 766, 767, 7, 96, 2, 2, 767, 769, 7, 98, 2, 2, 768, 765, 3, 2,
	2, 2, 769, 772, 3, 2, 2, 2, 770, 768, 3, 2, 2, 2, 770, 771, 3, 2, 2, 2,
	771, 117, 3, 2, 2, 2, 772, 770, 3, 2, 2, 2, 773, 775, 7, 30, 2, 2, 774,
	776, 5, 116, 59, 2, 775, 774, 3, 2, 2, 2, 775, 776, 3, 2, 2, 2, 776, 777,
	3, 2, 2, 2, 777, 778, 7, 95, 2, 2, 778, 119, 3, 2, 2, 2, 779, 780, 7, 22,
	2, 2, 780, 781, 5, 116, 59, 2, 781, 782, 7, 95, 2, 2, 782, 121, 3, 2, 2,
	2, 783, 784, 8, 62, 1, 2, 784, 785, 5, 120, 61, 2, 785, 790, 3, 2, 2, 2,
	786, 787, 12, 3, 2, 2, 787, 789, 5, 120, 61, 2, 788, 786, 3, 2, 2, 2, 789,
	792, 3, 2, 2, 2, 790, 788, 3, 2, 2, 2, 790, 791, 3, 2, 2, 2, 791, 123,
	3, 2, 2, 2, 792, 790, 3, 2, 2, 2, 793, 794, 8, 63, 1, 2, 794, 795, 5, 126,
	64, 2, 795, 801, 3, 2, 2, 2, 796, 797, 12, 3, 2, 2, 797, 798, 7, 92, 2,
	2, 798, 800, 5, 126, 64, 2, 799, 796, 3, 2, 2, 2, 800, 803, 3, 2, 2, 2,
	801, 799, 3, 2, 2, 2, 801, 802, 3, 2, 2, 2, 802, 125, 3, 2, 2, 2, 803,
	801, 3, 2, 2, 2, 804, 806, 5, 128, 65, 2, 805, 807, 5, 150, 76, 2, 806,
	805, 3, 2, 2, 2, 806, 807, 3, 2, 2, 2, 807, 127, 3, 2, 2, 2, 808, 813,
	5, 130, 66, 2, 809, 810, 5, 132, 67, 2, 810, 811, 5, 134, 68, 2, 811, 813,
	3, 2, 2, 2, 812, 808, 3, 2, 2, 2, 812, 809, 3, 2, 2, 2, 813, 129, 3, 2,
	2, 2, 814, 819, 5, 132, 67, 2, 815, 816, 5, 136, 69, 2, 816, 817, 5, 130,
	66, 2, 817, 819, 3, 2, 2, 2, 818, 814, 3, 2, 2, 2, 818, 815, 3, 2, 2, 2,
	819, 131, 3, 2, 2, 2, 820, 821, 8, 67, 1, 2, 821, 827, 5, 138, 70, 2, 822,
	823, 7, 54, 2, 2, 823, 824, 5, 130, 66, 2, 824, 825, 7, 55, 2, 2, 825,
	827, 3, 2, 2, 2, 826, 820, 3, 2, 2, 2, 826, 822, 3, 2, 2, 2, 827, 832,
	3, 2, 2, 2, 828, 829, 12, 4, 2, 2, 829, 831, 5, 134, 68, 2, 830, 828, 3,
	2, 2, 2, 831, 834, 3, 2, 2, 2, 832, 830, 3, 2, 2, 2, 832, 833, 3, 2, 2,
	2, 833, 133, 3, 2, 2, 2, 834, 832, 3, 2, 2, 2, 835, 836, 7, 54, 2, 2, 836,
	837, 5, 142, 72, 2, 837, 838, 7, 55, 2, 2, 838, 135, 3, 2, 2, 2, 839, 840,
	7, 66, 2, 2, 840, 137, 3, 2, 2, 2, 841, 843, 7, 97, 2, 2, 842, 841, 3,
	2, 2, 2, 842, 843, 3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 845, 5, 6, 4,
	2, 845, 139, 3, 2, 2, 2, 846, 847, 5, 96, 49, 2, 847, 141, 3, 2, 2, 2,
	848, 850, 5, 144, 73, 2, 849, 848, 3, 2, 2, 2, 849, 850, 3, 2, 2, 2, 850,
	852, 3, 2, 2, 2, 851, 853, 7, 97, 2, 2, 852, 851, 3, 2, 2, 2, 852, 853,
	3, 2, 2, 2, 853, 859, 3, 2, 2, 2, 854, 855, 5, 144, 73, 2, 855, 856, 7,
	92, 2, 2, 856, 857, 7, 97, 2, 2, 857, 859, 3, 2, 2, 2, 858, 849, 3, 2,
	2, 2, 858, 854, 3, 2, 2, 2, 859, 143, 3, 2, 2, 2, 860, 861, 8, 73, 1, 2,
	861, 862, 5, 146, 74, 2, 862, 868, 3, 2, 2, 2, 863, 864, 12, 3, 2, 2, 864,
	865, 7, 92, 2, 2, 865, 867, 5, 146, 74, 2, 866, 863, 3, 2, 2, 2, 867, 870,
	3, 2, 2, 2, 868, 866, 3, 2, 2, 2, 868, 869, 3, 2, 2, 2, 869, 145, 3, 2,
	2, 2, 870, 868, 3, 2, 2, 2, 871, 872, 5, 94, 48, 2, 872, 873, 5, 128, 65,
	2, 873, 885, 3, 2, 2, 2, 874, 875, 5, 94, 48, 2, 875, 876, 5, 128, 65,
	2, 876, 877, 7, 70, 2, 2, 877, 878, 5, 154, 78, 2, 878, 885, 3, 2, 2, 2,
	879, 885, 5, 94, 48, 2, 880, 881, 5, 94, 48, 2, 881, 882, 7, 70, 2, 2,
	882, 883, 5, 154, 78, 2, 883, 885, 3, 2, 2, 2, 884, 871, 3, 2, 2, 2, 884,
	874, 3, 2, 2, 2, 884, 879, 3, 2, 2, 2, 884, 880, 3, 2, 2, 2, 885, 147,
	3, 2, 2, 2, 886, 888, 5, 172, 87, 2, 887, 886, 3, 2, 2, 2, 887, 888, 3,
	2, 2, 2, 888, 890, 3, 2, 2, 2, 889, 891, 5, 94, 48, 2, 890, 889, 3, 2,
	2, 2, 890, 891, 3, 2, 2, 2, 891, 892, 3, 2, 2, 2, 892, 893, 5, 128, 65,
	2, 893, 894, 5, 64, 33, 2, 894, 149, 3, 2, 2, 2, 895, 901, 5, 152, 77,
	2, 896, 897, 7, 54, 2, 2, 897, 898, 5, 16, 9, 2, 898, 899, 7, 55, 2, 2,
	899, 901, 3, 2, 2, 2, 900, 895, 3, 2, 2, 2, 900, 896, 3, 2, 2, 2, 901,
	151, 3, 2, 2, 2, 902, 903, 7, 70, 2, 2, 903, 906, 5, 154, 78, 2, 904, 906,
	5, 158, 80, 2, 905, 902, 3, 2, 2, 2, 905, 904, 3, 2, 2, 2, 906, 153, 3,
	2, 2, 2, 907, 910, 5, 50, 26, 2, 908, 910, 5, 158, 80, 2, 909, 907, 3,
	2, 2, 2, 909, 908, 3, 2, 2, 2, 910, 155, 3, 2, 2, 2, 911, 912, 8, 79, 1,
	2, 912, 914, 5, 154, 78, 2, 913, 915, 7, 97, 2, 2, 914, 913, 3, 2, 2, 2,
	914, 915, 3, 2, 2, 2, 915, 924, 3, 2, 2, 2, 916, 917, 12, 3, 2, 2, 917,
	918, 7, 92, 2, 2, 918, 920, 5, 154, 78, 2, 919, 921, 7, 97, 2, 2, 920,
	919, 3, 2, 2, 2, 920, 921, 3, 2, 2, 2, 921, 923, 3, 2, 2, 2, 922, 916,
	3, 2, 2, 2, 923, 926, 3, 2, 2, 2, 924, 922, 3, 2, 2, 2, 924, 925, 3, 2,
	2, 2, 925, 157, 3, 2, 2, 2, 926, 924, 3, 2, 2, 2, 927, 928, 7, 58, 2, 2,
	928, 930, 5, 156, 79, 2, 929, 931, 7, 92, 2, 2, 930, 929, 3, 2, 2, 2, 930,
	931, 3, 2, 2, 2, 931, 932, 3, 2, 2, 2, 932, 933, 7, 59, 2, 2, 933, 937,
	3, 2, 2, 2, 934, 935, 7, 58, 2, 2, 935, 937, 7, 59, 2, 2, 936, 927, 3,
	2, 2, 2, 936, 934, 3, 2, 2, 2, 937, 159, 3, 2, 2, 2, 938, 939, 7, 10, 2,
	2, 939, 941, 5, 162, 82, 2, 940, 942, 5, 178, 90, 2, 941, 940, 3, 2, 2,
	2, 941, 942, 3, 2, 2, 2, 942, 943, 3, 2, 2, 2, 943, 945, 7, 58, 2, 2, 944,
	946, 5, 164, 83, 2, 945, 944, 3, 2, 2, 2, 945, 946, 3, 2, 2, 2, 946, 947,
	3, 2, 2, 2, 947, 948, 7, 59, 2, 2, 948, 161, 3, 2, 2, 2, 949, 952, 7, 98,
	2, 2, 950, 952, 5, 186, 94, 2, 951, 949, 3, 2, 2, 2, 951, 950, 3, 2, 2,
	2, 952, 163, 3, 2, 2, 2, 953, 955, 5, 166, 84, 2, 954, 956, 5, 164, 83,
	2, 955, 954, 3, 2, 2, 2, 955, 956, 3, 2, 2, 2, 956, 165, 3, 2, 2, 2, 957,
	959, 5, 94, 48, 2, 958, 957, 3, 2, 2, 2, 958, 959, 3, 2, 2, 2, 959, 961,
	3, 2, 2, 2, 960, 962, 5, 168, 85, 2, 961, 960, 3, 2, 2, 2, 961, 962, 3,
	2, 2, 2, 962, 963, 3, 2, 2, 2, 963, 967, 7, 95, 2, 2, 964, 967, 5, 148,
	75, 2, 965, 967, 5, 90, 46, 2, 966, 958, 3, 2, 2, 2, 966, 964, 3, 2, 2,
	2, 966, 965, 3, 2, 2, 2, 967, 167, 3, 2, 2, 2, 968, 969, 8, 85, 1, 2, 969,
	970, 5, 170, 86, 2, 970, 976, 3, 2, 2, 2, 971, 972, 12, 3, 2, 2, 972, 973,
	7, 92, 2, 2, 973, 975, 5, 170, 86, 2, 974, 971, 3, 2, 2, 2, 975, 978, 3,
	2, 2, 2, 976, 974, 3, 2, 2, 2, 976, 977, 3, 2, 2, 2, 977, 169, 3, 2, 2,
	2, 978, 976, 3, 2, 2, 2, 979, 985, 5, 128, 65, 2, 980, 982, 5, 128, 65,
	2, 981, 983, 5, 152, 77, 2, 982, 981, 3, 2, 2, 2, 982, 983, 3, 2, 2, 2,
	983, 985, 3, 2, 2, 2, 984, 979, 3, 2, 2, 2, 984, 980, 3, 2, 2, 2, 985,
	171, 3, 2, 2, 2, 986, 987, 8, 87, 1, 2, 987, 988, 5, 174, 88, 2, 988, 993,
	3, 2, 2, 2, 989, 990, 12, 3, 2, 2, 990, 992, 5, 174, 88, 2, 991, 989, 3,
	2, 2, 2, 992, 995, 3, 2, 2, 2, 993, 991, 3, 2, 2, 2, 993, 994, 3, 2, 2,
	2, 994, 173, 3, 2, 2, 2, 995, 993, 3, 2, 2, 2, 996, 1000, 7, 38, 2, 2,
	997, 1000, 7, 11, 2, 2, 998, 1000, 5, 176, 89, 2, 999, 996, 3, 2, 2, 2,
	999, 997, 3, 2, 2, 2, 999, 998, 3, 2, 2, 2, 1000, 175, 3, 2, 2, 2, 1001,
	1002, 9, 5, 2, 2, 1002, 177, 3, 2, 2, 2, 1003, 1004, 7, 94, 2, 2, 1004,
	1005, 5, 180, 91, 2, 1005, 179, 3, 2, 2, 2, 1006, 1007, 8, 91, 1, 2, 1007,
	1008, 5, 182, 92, 2, 1008, 1014, 3, 2, 2, 2, 1009, 1010, 12, 3, 2, 2, 1010,
	1011, 7, 92, 2, 2, 1011, 1013, 5, 182, 92, 2, 1012, 1009, 3, 2, 2, 2, 1013,
	1016, 3, 2, 2, 2, 1014, 1012, 3, 2, 2, 2, 1014, 1015, 3, 2, 2, 2, 1015,
	181, 3, 2, 2, 2, 1016, 1014, 3, 2, 2, 2, 1017, 1019, 5, 12, 7, 2, 1018,
	1017, 3, 2, 2, 2, 1018, 1019, 3, 2, 2, 2, 1019, 1020, 3, 2, 2, 2, 1020,
	1021, 5, 162, 82, 2, 1021, 183, 3, 2, 2, 2, 1022, 1023, 7, 33, 2, 2, 1023,
	1024, 5, 208, 105, 2, 1024, 185, 3, 2, 2, 2, 1025, 1026, 7, 98, 2, 2, 1026,
	1027, 5, 188, 95, 2, 1027, 187, 3, 2, 2, 2, 1028, 1030, 7, 71, 2, 2, 1029,
	1031, 5, 190, 96, 2, 1030, 1029, 3, 2, 2, 2, 1030, 1031, 3, 2, 2, 2, 1031,
	1032, 3, 2, 2, 2, 1032, 1033, 7, 72, 2, 2, 1033, 189, 3, 2, 2, 2, 1034,
	1035, 8, 96, 1, 2, 1035, 1036, 5, 192, 97, 2, 1036, 1042, 3, 2, 2, 2, 1037,
	1038, 12, 3, 2, 2, 1038, 1039, 7, 92, 2, 2, 1039, 1041, 5, 192, 97, 2,
	1040, 1037, 3, 2, 2, 2, 1041, 1044, 3, 2, 2, 2, 1042, 1040, 3, 2, 2, 2,
	1042, 1043, 3, 2, 2, 2, 1043, 191, 3, 2, 2, 2, 1044, 1042, 3, 2, 2, 2,
	1045, 1049, 5, 140, 71, 2, 1046, 1049, 5, 56, 29, 2, 1047, 1049, 5, 6,
	4, 2, 1048, 1045, 3, 2, 2, 2, 1048, 1046, 3, 2, 2, 2, 1048, 1047, 3, 2,
	2, 2, 1049, 193, 3, 2, 2, 2, 1050, 1051, 5, 12, 7, 2, 1051, 1052, 7, 98,
	2, 2, 1052, 1057, 3, 2, 2, 2, 1053, 1054, 5, 12, 7, 2, 1054, 1055, 5, 186,
	94, 2, 1055, 1057, 3, 2, 2, 2, 1056, 1050, 3, 2, 2, 2, 1056, 1053, 3, 2,
	2, 2, 1057, 195, 3, 2, 2, 2, 1058, 1059, 8, 99, 1, 2, 1059, 1061, 5, 140,
	71, 2, 1060, 1062, 7, 97, 2, 2, 1061, 1060, 3, 2, 2, 2, 1061, 1062, 3,
	2, 2, 2, 1062, 1071, 3, 2, 2, 2, 1063, 1064, 12, 3, 2, 2, 1064, 1065, 7,
	92, 2, 2, 1065, 1067, 5, 140, 71, 2, 1066, 1068, 7, 97, 2, 2, 1067, 1066,
	3, 2, 2, 2, 1067, 1068, 3, 2, 2, 2, 1068, 1070, 3, 2, 2, 2, 1069, 1063,
	3, 2, 2, 2, 1070, 1073, 3, 2, 2, 2, 1071, 1069, 3, 2, 2, 2, 1071, 1072,
	3, 2, 2, 2, 1072, 197, 3, 2, 2, 2, 1073, 1071, 3, 2, 2, 2, 1074, 1075,
	7, 44, 2, 2, 1075, 1076, 5, 64, 33, 2, 1076, 1077, 5, 200, 101, 2, 1077,
	199, 3, 2, 2, 2, 1078, 1080, 5, 202, 102, 2, 1079, 1081, 5, 200, 101, 2,
	1080, 1079, 3, 2, 2, 2, 1080, 1081, 3, 2, 2, 2, 1081, 201, 3, 2, 2, 2,
	1082, 1083, 7, 9, 2, 2, 1083, 1084, 7, 54, 2, 2, 1084, 1085, 5, 204, 103,
	2, 1085, 1086, 7, 55, 2, 2, 1086, 1087, 5, 64, 33, 2, 1087, 203, 3, 2,
	2, 2, 1088, 1089, 5, 96, 49, 2, 1089, 1090, 5, 128, 65, 2, 1090, 1094,
	3, 2, 2, 2, 1091, 1094, 5, 96, 49, 2, 1092, 1094, 7, 97, 2, 2, 1093, 1088,
	3, 2, 2, 2, 1093, 1091, 3, 2, 2, 2, 1093, 1092, 3, 2, 2, 2, 1094, 205,
	3, 2, 2, 2, 1095, 1097, 7, 42, 2, 2, 1096, 1098, 5, 50, 26, 2, 1097, 1096,
	3, 2, 2, 2, 1097, 1098, 3, 2, 2, 2, 1098, 207, 3, 2, 2, 2, 1099, 1138,
	7, 31, 2, 2, 1100, 1138, 7, 60, 2, 2, 1101, 1138, 7, 61, 2, 2, 1102, 1138,
	7, 62, 2, 2, 1103, 1138, 7, 63, 2, 2, 1104, 1138, 7, 64, 2, 2, 1105, 1138,
	7, 65, 2, 2, 1106, 1138, 7, 66, 2, 2, 1107, 1138, 7, 67, 2, 2, 1108, 1138,
	7, 68, 2, 2, 1109, 1138, 7, 69, 2, 2, 1110, 1138, 7, 70, 2, 2, 1111, 1138,
	7, 71, 2, 2, 1112, 1138, 7, 72, 2, 2, 1113, 1138, 7, 73, 2, 2, 1114, 1138,
	7, 74, 2, 2, 1115, 1138, 7, 75, 2, 2, 1116, 1138, 7, 76, 2, 2, 1117, 1138,
	7, 77, 2, 2, 1118, 1138, 7, 78, 2, 2, 1119, 1138, 7, 79, 2, 2, 1120, 1138,
	7, 80, 2, 2, 1121, 1138, 7, 81, 2, 2, 1122, 1138, 7, 83, 2, 2, 1123, 1138,
	7, 82, 2, 2, 1124, 1138, 7, 84, 2, 2, 1125, 1138, 7, 85, 2, 2, 1126, 1138,
	7, 86, 2, 2, 1127, 1138, 7, 87, 2, 2, 1128, 1138, 7, 88, 2, 2, 1129, 1138,
	7, 89, 2, 2, 1130, 1138, 7, 90, 2, 2, 1131, 1138, 7, 91, 2, 2, 1132, 1138,
	7, 92, 2, 2, 1133, 1134, 7, 54, 2, 2, 1134, 1138, 7, 55, 2, 2, 1135, 1136,
	7, 56, 2, 2, 1136, 1138, 7, 57, 2, 2, 1137, 1099, 3, 2, 2, 2, 1137, 1100,
	3, 2, 2, 2, 1137, 1101, 3, 2, 2, 2, 1137, 1102, 3, 2, 2, 2, 1137, 1103,
	3, 2, 2, 2, 1137, 1104, 3, 2, 2, 2, 1137, 1105, 3, 2, 2, 2, 1137, 1106,
	3, 2, 2, 2, 1137, 1107, 3, 2, 2, 2, 1137, 1108, 3, 2, 2, 2, 1137, 1109,
	3, 2, 2, 2, 1137, 1110, 3, 2, 2, 2, 1137, 1111, 3, 2, 2, 2, 1137, 1112,
	3, 2, 2, 2, 1137, 1113, 3, 2, 2, 2, 1137, 1114, 3, 2, 2, 2, 1137, 1115,
	3, 2, 2, 2, 1137, 1116, 3, 2, 2, 2, 1137, 1117, 3, 2, 2, 2, 1137, 1118,
	3, 2, 2, 2, 1137, 1119, 3, 2, 2, 2, 1137, 1120, 3, 2, 2, 2, 1137, 1121,
	3, 2, 2, 2, 1137, 1122, 3, 2, 2, 2, 1137, 1123, 3, 2, 2, 2, 1137, 1124,
	3, 2, 2, 2, 1137, 1125, 3, 2, 2, 2, 1137, 1126, 3, 2, 2, 2, 1137, 1127,
	3, 2, 2, 2, 1137, 1128, 3, 2, 2, 2, 1137, 1129, 3, 2, 2, 2, 1137, 1130,
	3, 2, 2, 2, 1137, 1131, 3, 2, 2, 2, 1137, 1132, 3, 2, 2, 2, 1137, 1133,
	3, 2, 2, 2, 1137, 1135, 3, 2, 2, 2, 1138, 209, 3, 2, 2, 2, 1139, 1140,
	9, 6, 2, 2, 1140, 211, 3, 2, 2, 2, 117, 213, 216, 219, 230, 234, 239, 251,
	260, 262, 270, 277, 295, 305, 315, 317, 331, 341, 345, 359, 361, 373, 375,
	387, 407, 409, 421, 423, 434, 445, 456, 467, 478, 488, 496, 508, 521, 531,
	534, 540, 551, 574, 586, 592, 596, 609, 613, 620, 628, 635, 646, 654, 657,
	660, 667, 675, 681, 684, 708, 713, 720, 730, 734, 737, 750, 758, 770, 775,
	790, 801, 806, 812, 818, 826, 832, 842, 849, 852, 858, 868, 884, 887, 890,
	900, 905, 909, 914, 920, 924, 930, 936, 941, 945, 951, 955, 958, 961, 966,
	976, 982, 984, 993, 999, 1014, 1018, 1030, 1042, 1048, 1056, 1061, 1067,
	1071, 1080, 1093, 1097, 1137,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'base'", "'bool'", "'break'", "'byte'", "'case'", "'cast'", "'catch'",
	"'class'", "'const'", "'continue'", "'default'", "'double'", "'else'",
	"'enum'", "'f32'", "'f64'", "'false'", "'float'", "'for'", "'include'",
	"'if'", "'int'", "'i8'", "'i16'", "'i32'", "'i64'", "'long'", "'namespace'",
	"'new'", "'null'", "'operator'", "'private'", "'protected'", "'public'",
	"'return'", "'static'", "'short'", "'switch'", "'this'", "'throw'", "'true'",
	"'try'", "'uint'", "'u8'", "'u16'", "'u32'", "'u64'", "'ulong'", "'ushort'",
	"'var'", "'void'", "'('", "')'", "'['", "']'", "'{'", "'}'", "'+'", "'-'",
	"'*'", "'/'", "'%'", "'^'", "'&'", "'|'", "'~'", "'!'", "'='", "'<'", "'>'",
	"'+='", "'-='", "'/='", "'%='", "'^='", "'&='", "'|='", "'<<'", "'>>'",
	"'<<='", "'>>='", "'=='", "'!='", "'<='", "'>='", "'&&'", "'||'", "'++'",
	"'--'", "','", "'?'", "':'", "';'", "'.'", "'...'",
}
var symbolicNames = []string{
	"", "Base", "Bool", "Break", "Byte", "Case", "Cast", "Catch", "Class",
	"Const", "Continue", "Default", "Double", "Else", "Enum", "Float32", "Float64",
	"False", "Float", "For", "Include", "If", "Int", "Int8", "Int16", "Int32",
	"Int64", "Long", "Namespace", "New", "Null", "Operator", "Private", "Protected",
	"Public", "Return", "Static", "Short", "Switch", "This", "Throw", "True",
	"Try", "Uint", "Uint8", "Uint16", "Uint32", "Uint64", "Ulong", "Ushort",
	"Var", "Void", "LeftParen", "RightParen", "LeftBracket", "RightBracket",
	"LeftBrace", "RightBrace", "Plus", "Minus", "Star", "Div", "Mod", "Caret",
	"And", "Or", "Tilde", "Not", "Assign", "Less", "Greater", "PlusAssign",
	"MinusAssign", "DivAssign", "ModAssign", "XorAssign", "AndAssign", "OrAssign",
	"LeftShift", "RightShift", "LeftShiftAssign", "RightShiftAssign", "Equal",
	"NotEqual", "LessEqual", "GreaterEqual", "AndAnd", "OrOr", "PlusPlus",
	"MinusMinus", "Comma", "Question", "Colon", "Semi", "Dot", "Ellipsis",
	"Identifier", "IntegerLiteral", "DecimalLiteral", "OctalLiteral", "HexadecimalLiteral",
	"BinaryLiteral", "FloatLiteral", "StringLiteral", "BooleanLiteral", "PointerLiteral",
	"Whitespace", "Newline", "BlockComment", "LineComment",
}

var ruleNames = []string{
	"translation_unit", "primary_expression", "id_expression", "unqualified_id",
	"qualified_id", "nested_name_specifier", "post_fix_expression", "expression_list",
	"unary_expression", "unary_operator", "new_expression", "new_initializer",
	"multiplicative_expression", "additive_expression", "shift_expression",
	"shiftoperator", "relational_expression", "equality_expression", "and_expression",
	"exclusiveor_expression", "inclusiveor_expression", "logical_and_expression",
	"logical_or_expression", "conditional_expression", "assignment_expression",
	"assignment_operator", "expression", "constant_expression", "statement",
	"labeled_statement", "expression_statement", "compound_statement", "statement_sequence",
	"selection_statement", "condition", "iteration_statement", "for_init_statement",
	"for_range_declaration", "for_range_initializer", "jump_statement", "declaration_statement",
	"declaration_sequence", "declaration", "block_declaration", "empty_declaration",
	"decl_specifier", "decl_specifier_sequence", "type_specifier_sequence",
	"type_specifier", "type_name", "enum_name", "enum_definition", "enum_head",
	"enum_base", "enumerator_list", "enumerator_definition", "enumerator",
	"namespace_name", "namespace_definition", "include_definition", "include_definition_sequence",
	"init_declarator_list", "init_declarator", "declarator", "ptr_declarator",
	"noptr_declarator", "parameters_and_qualifiers", "ref_operator", "declarator_id",
	"type_id", "parameter_declaration_clause", "parameter_declaration_list",
	"parameter_declaration", "function_definition", "initializer", "brace_or_equal_initializer",
	"initializer_clause", "initializer_list", "braced_init_list", "class_definition",
	"class_name", "member_specification", "member_declaration", "member_declarator_list",
	"member_declarator", "modifier_specifier_sequence", "modifier_specifier",
	"access_specifier", "base_clause", "base_specifier_list", "base_specifier",
	"operator_function_id", "template_id", "template_definition", "template_argument_list",
	"template_argument", "type_name_specifier", "type_id_list", "try_block",
	"handler_sequence", "handler", "exception_declaration", "throw_expression",
	"operators", "literal",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type PandaParser struct {
	*antlr.BaseParser
}

func NewPandaParser(input antlr.TokenStream) *PandaParser {
	this := new(PandaParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "PandaParser.g4"

	return this
}

// PandaParser tokens.
const (
	PandaParserEOF                = antlr.TokenEOF
	PandaParserBase               = 1
	PandaParserBool               = 2
	PandaParserBreak              = 3
	PandaParserByte               = 4
	PandaParserCase               = 5
	PandaParserCast               = 6
	PandaParserCatch              = 7
	PandaParserClass              = 8
	PandaParserConst              = 9
	PandaParserContinue           = 10
	PandaParserDefault            = 11
	PandaParserDouble             = 12
	PandaParserElse               = 13
	PandaParserEnum               = 14
	PandaParserFloat32            = 15
	PandaParserFloat64            = 16
	PandaParserFalse              = 17
	PandaParserFloat              = 18
	PandaParserFor                = 19
	PandaParserInclude            = 20
	PandaParserIf                 = 21
	PandaParserInt                = 22
	PandaParserInt8               = 23
	PandaParserInt16              = 24
	PandaParserInt32              = 25
	PandaParserInt64              = 26
	PandaParserLong               = 27
	PandaParserNamespace          = 28
	PandaParserNew                = 29
	PandaParserNull               = 30
	PandaParserOperator           = 31
	PandaParserPrivate            = 32
	PandaParserProtected          = 33
	PandaParserPublic             = 34
	PandaParserReturn             = 35
	PandaParserStatic             = 36
	PandaParserShort              = 37
	PandaParserSwitch             = 38
	PandaParserThis               = 39
	PandaParserThrow              = 40
	PandaParserTrue               = 41
	PandaParserTry                = 42
	PandaParserUint               = 43
	PandaParserUint8              = 44
	PandaParserUint16             = 45
	PandaParserUint32             = 46
	PandaParserUint64             = 47
	PandaParserUlong              = 48
	PandaParserUshort             = 49
	PandaParserVar                = 50
	PandaParserVoid               = 51
	PandaParserLeftParen          = 52
	PandaParserRightParen         = 53
	PandaParserLeftBracket        = 54
	PandaParserRightBracket       = 55
	PandaParserLeftBrace          = 56
	PandaParserRightBrace         = 57
	PandaParserPlus               = 58
	PandaParserMinus              = 59
	PandaParserStar               = 60
	PandaParserDiv                = 61
	PandaParserMod                = 62
	PandaParserCaret              = 63
	PandaParserAnd                = 64
	PandaParserOr                 = 65
	PandaParserTilde              = 66
	PandaParserNot                = 67
	PandaParserAssign             = 68
	PandaParserLess               = 69
	PandaParserGreater            = 70
	PandaParserPlusAssign         = 71
	PandaParserMinusAssign        = 72
	PandaParserDivAssign          = 73
	PandaParserModAssign          = 74
	PandaParserXorAssign          = 75
	PandaParserAndAssign          = 76
	PandaParserOrAssign           = 77
	PandaParserLeftShift          = 78
	PandaParserRightShift         = 79
	PandaParserLeftShiftAssign    = 80
	PandaParserRightShiftAssign   = 81
	PandaParserEqual              = 82
	PandaParserNotEqual           = 83
	PandaParserLessEqual          = 84
	PandaParserGreaterEqual       = 85
	PandaParserAndAnd             = 86
	PandaParserOrOr               = 87
	PandaParserPlusPlus           = 88
	PandaParserMinusMinus         = 89
	PandaParserComma              = 90
	PandaParserQuestion           = 91
	PandaParserColon              = 92
	PandaParserSemi               = 93
	PandaParserDot                = 94
	PandaParserEllipsis           = 95
	PandaParserIdentifier         = 96
	PandaParserIntegerLiteral     = 97
	PandaParserDecimalLiteral     = 98
	PandaParserOctalLiteral       = 99
	PandaParserHexadecimalLiteral = 100
	PandaParserBinaryLiteral      = 101
	PandaParserFloatLiteral       = 102
	PandaParserStringLiteral      = 103
	PandaParserBooleanLiteral     = 104
	PandaParserPointerLiteral     = 105
	PandaParserWhitespace         = 106
	PandaParserNewline            = 107
	PandaParserBlockComment       = 108
	PandaParserLineComment        = 109
)

// PandaParser rules.
const (
	PandaParserRULE_translation_unit             = 0
	PandaParserRULE_primary_expression           = 1
	PandaParserRULE_id_expression                = 2
	PandaParserRULE_unqualified_id               = 3
	PandaParserRULE_qualified_id                 = 4
	PandaParserRULE_nested_name_specifier        = 5
	PandaParserRULE_post_fix_expression          = 6
	PandaParserRULE_expression_list              = 7
	PandaParserRULE_unary_expression             = 8
	PandaParserRULE_unary_operator               = 9
	PandaParserRULE_new_expression               = 10
	PandaParserRULE_new_initializer              = 11
	PandaParserRULE_multiplicative_expression    = 12
	PandaParserRULE_additive_expression          = 13
	PandaParserRULE_shift_expression             = 14
	PandaParserRULE_shiftoperator                = 15
	PandaParserRULE_relational_expression        = 16
	PandaParserRULE_equality_expression          = 17
	PandaParserRULE_and_expression               = 18
	PandaParserRULE_exclusiveor_expression       = 19
	PandaParserRULE_inclusiveor_expression       = 20
	PandaParserRULE_logical_and_expression       = 21
	PandaParserRULE_logical_or_expression        = 22
	PandaParserRULE_conditional_expression       = 23
	PandaParserRULE_assignment_expression        = 24
	PandaParserRULE_assignment_operator          = 25
	PandaParserRULE_expression                   = 26
	PandaParserRULE_constant_expression          = 27
	PandaParserRULE_statement                    = 28
	PandaParserRULE_labeled_statement            = 29
	PandaParserRULE_expression_statement         = 30
	PandaParserRULE_compound_statement           = 31
	PandaParserRULE_statement_sequence           = 32
	PandaParserRULE_selection_statement          = 33
	PandaParserRULE_condition                    = 34
	PandaParserRULE_iteration_statement          = 35
	PandaParserRULE_for_init_statement           = 36
	PandaParserRULE_for_range_declaration        = 37
	PandaParserRULE_for_range_initializer        = 38
	PandaParserRULE_jump_statement               = 39
	PandaParserRULE_declaration_statement        = 40
	PandaParserRULE_declaration_sequence         = 41
	PandaParserRULE_declaration                  = 42
	PandaParserRULE_block_declaration            = 43
	PandaParserRULE_empty_declaration            = 44
	PandaParserRULE_decl_specifier               = 45
	PandaParserRULE_decl_specifier_sequence      = 46
	PandaParserRULE_type_specifier_sequence      = 47
	PandaParserRULE_type_specifier               = 48
	PandaParserRULE_type_name                    = 49
	PandaParserRULE_enum_name                    = 50
	PandaParserRULE_enum_definition              = 51
	PandaParserRULE_enum_head                    = 52
	PandaParserRULE_enum_base                    = 53
	PandaParserRULE_enumerator_list              = 54
	PandaParserRULE_enumerator_definition        = 55
	PandaParserRULE_enumerator                   = 56
	PandaParserRULE_namespace_name               = 57
	PandaParserRULE_namespace_definition         = 58
	PandaParserRULE_include_definition           = 59
	PandaParserRULE_include_definition_sequence  = 60
	PandaParserRULE_init_declarator_list         = 61
	PandaParserRULE_init_declarator              = 62
	PandaParserRULE_declarator                   = 63
	PandaParserRULE_ptr_declarator               = 64
	PandaParserRULE_noptr_declarator             = 65
	PandaParserRULE_parameters_and_qualifiers    = 66
	PandaParserRULE_ref_operator                 = 67
	PandaParserRULE_declarator_id                = 68
	PandaParserRULE_type_id                      = 69
	PandaParserRULE_parameter_declaration_clause = 70
	PandaParserRULE_parameter_declaration_list   = 71
	PandaParserRULE_parameter_declaration        = 72
	PandaParserRULE_function_definition          = 73
	PandaParserRULE_initializer                  = 74
	PandaParserRULE_brace_or_equal_initializer   = 75
	PandaParserRULE_initializer_clause           = 76
	PandaParserRULE_initializer_list             = 77
	PandaParserRULE_braced_init_list             = 78
	PandaParserRULE_class_definition             = 79
	PandaParserRULE_class_name                   = 80
	PandaParserRULE_member_specification         = 81
	PandaParserRULE_member_declaration           = 82
	PandaParserRULE_member_declarator_list       = 83
	PandaParserRULE_member_declarator            = 84
	PandaParserRULE_modifier_specifier_sequence  = 85
	PandaParserRULE_modifier_specifier           = 86
	PandaParserRULE_access_specifier             = 87
	PandaParserRULE_base_clause                  = 88
	PandaParserRULE_base_specifier_list          = 89
	PandaParserRULE_base_specifier               = 90
	PandaParserRULE_operator_function_id         = 91
	PandaParserRULE_template_id                  = 92
	PandaParserRULE_template_definition          = 93
	PandaParserRULE_template_argument_list       = 94
	PandaParserRULE_template_argument            = 95
	PandaParserRULE_type_name_specifier          = 96
	PandaParserRULE_type_id_list                 = 97
	PandaParserRULE_try_block                    = 98
	PandaParserRULE_handler_sequence             = 99
	PandaParserRULE_handler                      = 100
	PandaParserRULE_exception_declaration        = 101
	PandaParserRULE_throw_expression             = 102
	PandaParserRULE_operators                    = 103
	PandaParserRULE_literal                      = 104
)

// ITranslation_unitContext is an interface to support dynamic dispatch.
type ITranslation_unitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTranslation_unitContext differentiates from other interfaces.
	IsTranslation_unitContext()
}

type Translation_unitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslation_unitContext() *Translation_unitContext {
	var p = new(Translation_unitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_translation_unit
	return p
}

func (*Translation_unitContext) IsTranslation_unitContext() {}

func NewTranslation_unitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Translation_unitContext {
	var p = new(Translation_unitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_translation_unit

	return p
}

func (s *Translation_unitContext) GetParser() antlr.Parser { return s.parser }

func (s *Translation_unitContext) EOF() antlr.TerminalNode {
	return s.GetToken(PandaParserEOF, 0)
}

func (s *Translation_unitContext) Namespace_definition() INamespace_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_definitionContext)
}

func (s *Translation_unitContext) Include_definition_sequence() IInclude_definition_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclude_definition_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclude_definition_sequenceContext)
}

func (s *Translation_unitContext) Declaration_sequence() IDeclaration_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_sequenceContext)
}

func (s *Translation_unitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Translation_unitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Translation_unitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTranslation_unit(s)
	}
}

func (s *Translation_unitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTranslation_unit(s)
	}
}

func (s *Translation_unitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitTranslation_unit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Translation_unit() (localctx ITranslation_unitContext) {
	localctx = NewTranslation_unitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PandaParserRULE_translation_unit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(211)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserNamespace {
		{
			p.SetState(210)
			p.Namespace_definition()
		}

	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserInclude {
		{
			p.SetState(213)
			p.include_definition_sequence(0)
		}

	}
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-2)&-(0x1f+1)) == 0 && ((1<<uint((_la-2)))&((1<<(PandaParserBool-2))|(1<<(PandaParserClass-2))|(1<<(PandaParserConst-2))|(1<<(PandaParserDouble-2))|(1<<(PandaParserEnum-2))|(1<<(PandaParserFloat32-2))|(1<<(PandaParserFloat64-2))|(1<<(PandaParserFloat-2))|(1<<(PandaParserInt-2))|(1<<(PandaParserInt8-2))|(1<<(PandaParserInt16-2))|(1<<(PandaParserInt32-2))|(1<<(PandaParserInt64-2))|(1<<(PandaParserLong-2))|(1<<(PandaParserOperator-2))|(1<<(PandaParserPrivate-2))|(1<<(PandaParserProtected-2)))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(PandaParserPublic-34))|(1<<(PandaParserStatic-34))|(1<<(PandaParserShort-34))|(1<<(PandaParserUint-34))|(1<<(PandaParserUint8-34))|(1<<(PandaParserUint16-34))|(1<<(PandaParserUint32-34))|(1<<(PandaParserUint64-34))|(1<<(PandaParserUlong-34))|(1<<(PandaParserUshort-34))|(1<<(PandaParserVar-34))|(1<<(PandaParserVoid-34))|(1<<(PandaParserLeftParen-34))|(1<<(PandaParserAnd-34)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(PandaParserSemi-93))|(1<<(PandaParserEllipsis-93))|(1<<(PandaParserIdentifier-93)))) != 0) {
		{
			p.SetState(216)
			p.declaration_sequence(0)
		}

	}
	{
		p.SetState(219)
		p.Match(PandaParserEOF)
	}

	return localctx
}

// IPrimary_expressionContext is an interface to support dynamic dispatch.
type IPrimary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_expressionContext differentiates from other interfaces.
	IsPrimary_expressionContext()
}

type Primary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_expressionContext() *Primary_expressionContext {
	var p = new(Primary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_primary_expression
	return p
}

func (*Primary_expressionContext) IsPrimary_expressionContext() {}

func NewPrimary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_expressionContext {
	var p = new(Primary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_primary_expression

	return p
}

func (s *Primary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_expressionContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Primary_expressionContext) This() antlr.TerminalNode {
	return s.GetToken(PandaParserThis, 0)
}

func (s *Primary_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Primary_expressionContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Primary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterPrimary_expression(s)
	}
}

func (s *Primary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitPrimary_expression(s)
	}
}

func (s *Primary_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitPrimary_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Primary_expression() (localctx IPrimary_expressionContext) {
	localctx = NewPrimary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PandaParserRULE_primary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(228)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserIntegerLiteral, PandaParserFloatLiteral, PandaParserStringLiteral, PandaParserBooleanLiteral, PandaParserPointerLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(221)
			p.Literal()
		}

	case PandaParserThis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(222)
			p.Match(PandaParserThis)
		}

	case PandaParserLeftParen:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(223)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(224)
			p.expression(0)
		}
		{
			p.SetState(225)
			p.Match(PandaParserRightParen)
		}

	case PandaParserOperator, PandaParserIdentifier:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(227)
			p.Id_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IId_expressionContext is an interface to support dynamic dispatch.
type IId_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsId_expressionContext differentiates from other interfaces.
	IsId_expressionContext()
}

type Id_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyId_expressionContext() *Id_expressionContext {
	var p = new(Id_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_id_expression
	return p
}

func (*Id_expressionContext) IsId_expressionContext() {}

func NewId_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Id_expressionContext {
	var p = new(Id_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_id_expression

	return p
}

func (s *Id_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Id_expressionContext) Unqualified_id() IUnqualified_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnqualified_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnqualified_idContext)
}

func (s *Id_expressionContext) Qualified_id() IQualified_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualified_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualified_idContext)
}

func (s *Id_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Id_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Id_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterId_expression(s)
	}
}

func (s *Id_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitId_expression(s)
	}
}

func (s *Id_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitId_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Id_expression() (localctx IId_expressionContext) {
	localctx = NewId_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PandaParserRULE_id_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(232)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(230)
			p.Unqualified_id()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(231)
			p.Qualified_id()
		}

	}

	return localctx
}

// IUnqualified_idContext is an interface to support dynamic dispatch.
type IUnqualified_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnqualified_idContext differentiates from other interfaces.
	IsUnqualified_idContext()
}

type Unqualified_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnqualified_idContext() *Unqualified_idContext {
	var p = new(Unqualified_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_unqualified_id
	return p
}

func (*Unqualified_idContext) IsUnqualified_idContext() {}

func NewUnqualified_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unqualified_idContext {
	var p = new(Unqualified_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_unqualified_id

	return p
}

func (s *Unqualified_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Unqualified_idContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Unqualified_idContext) Operator_function_id() IOperator_function_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperator_function_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperator_function_idContext)
}

func (s *Unqualified_idContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Unqualified_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unqualified_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unqualified_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterUnqualified_id(s)
	}
}

func (s *Unqualified_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitUnqualified_id(s)
	}
}

func (s *Unqualified_idContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitUnqualified_id(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Unqualified_id() (localctx IUnqualified_idContext) {
	localctx = NewUnqualified_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PandaParserRULE_unqualified_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(234)
			p.Match(PandaParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(235)
			p.Operator_function_id()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(236)
			p.Template_id()
		}

	}

	return localctx
}

// IQualified_idContext is an interface to support dynamic dispatch.
type IQualified_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualified_idContext differentiates from other interfaces.
	IsQualified_idContext()
}

type Qualified_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualified_idContext() *Qualified_idContext {
	var p = new(Qualified_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_qualified_id
	return p
}

func (*Qualified_idContext) IsQualified_idContext() {}

func NewQualified_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualified_idContext {
	var p = new(Qualified_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_qualified_id

	return p
}

func (s *Qualified_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualified_idContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Qualified_idContext) Unqualified_id() IUnqualified_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnqualified_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnqualified_idContext)
}

func (s *Qualified_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualified_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qualified_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterQualified_id(s)
	}
}

func (s *Qualified_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitQualified_id(s)
	}
}

func (s *Qualified_idContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitQualified_id(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Qualified_id() (localctx IQualified_idContext) {
	localctx = NewQualified_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PandaParserRULE_qualified_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.nested_name_specifier(0)
	}
	{
		p.SetState(240)
		p.Unqualified_id()
	}

	return localctx
}

// INested_name_specifierContext is an interface to support dynamic dispatch.
type INested_name_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNested_name_specifierContext differentiates from other interfaces.
	IsNested_name_specifierContext()
}

type Nested_name_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNested_name_specifierContext() *Nested_name_specifierContext {
	var p = new(Nested_name_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_nested_name_specifier
	return p
}

func (*Nested_name_specifierContext) IsNested_name_specifierContext() {}

func NewNested_name_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nested_name_specifierContext {
	var p = new(Nested_name_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_nested_name_specifier

	return p
}

func (s *Nested_name_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Nested_name_specifierContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Nested_name_specifierContext) Namespace_name() INamespace_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Nested_name_specifierContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Nested_name_specifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Nested_name_specifierContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Nested_name_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nested_name_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nested_name_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNested_name_specifier(s)
	}
}

func (s *Nested_name_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNested_name_specifier(s)
	}
}

func (s *Nested_name_specifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitNested_name_specifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Nested_name_specifier() (localctx INested_name_specifierContext) {
	return p.nested_name_specifier(0)
}

func (p *PandaParser) nested_name_specifier(_p int) (localctx INested_name_specifierContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewNested_name_specifierContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INested_name_specifierContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 10
	p.EnterRecursionRule(localctx, 10, PandaParserRULE_nested_name_specifier, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(243)
			p.Type_name()
		}
		{
			p.SetState(244)
			p.Match(PandaParserDot)
		}

	case 2:
		{
			p.SetState(246)
			p.namespace_name(0)
		}
		{
			p.SetState(247)
			p.Match(PandaParserDot)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(260)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(258)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
			case 1:
				localctx = NewNested_name_specifierContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_nested_name_specifier)
				p.SetState(251)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(252)
					p.Match(PandaParserIdentifier)
				}
				{
					p.SetState(253)
					p.Match(PandaParserDot)
				}

			case 2:
				localctx = NewNested_name_specifierContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_nested_name_specifier)
				p.SetState(254)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(255)
					p.Template_id()
				}
				{
					p.SetState(256)
					p.Match(PandaParserDot)
				}

			}

		}
		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}

	return localctx
}

// IPost_fix_expressionContext is an interface to support dynamic dispatch.
type IPost_fix_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPost_fix_expressionContext differentiates from other interfaces.
	IsPost_fix_expressionContext()
}

type Post_fix_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPost_fix_expressionContext() *Post_fix_expressionContext {
	var p = new(Post_fix_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_post_fix_expression
	return p
}

func (*Post_fix_expressionContext) IsPost_fix_expressionContext() {}

func NewPost_fix_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Post_fix_expressionContext {
	var p = new(Post_fix_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_post_fix_expression

	return p
}

func (s *Post_fix_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Post_fix_expressionContext) Primary_expression() IPrimary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_expressionContext)
}

func (s *Post_fix_expressionContext) Type_specifier() IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Post_fix_expressionContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Post_fix_expressionContext) Type_name_specifier() IType_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_name_specifierContext)
}

func (s *Post_fix_expressionContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *Post_fix_expressionContext) Cast() antlr.TerminalNode {
	return s.GetToken(PandaParserCast, 0)
}

func (s *Post_fix_expressionContext) Type_id() IType_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Post_fix_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Post_fix_expressionContext) Post_fix_expression() IPost_fix_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPost_fix_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPost_fix_expressionContext)
}

func (s *Post_fix_expressionContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Post_fix_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Post_fix_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Post_fix_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterPost_fix_expression(s)
	}
}

func (s *Post_fix_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitPost_fix_expression(s)
	}
}

func (s *Post_fix_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitPost_fix_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Post_fix_expression() (localctx IPost_fix_expressionContext) {
	return p.post_fix_expression(0)
}

func (p *PandaParser) post_fix_expression(_p int) (localctx IPost_fix_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPost_fix_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPost_fix_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 12
	p.EnterRecursionRule(localctx, 12, PandaParserRULE_post_fix_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(264)
			p.Primary_expression()
		}

	case 2:
		{
			p.SetState(265)
			p.Type_specifier()
		}
		{
			p.SetState(266)
			p.Match(PandaParserLeftParen)
		}
		p.SetState(268)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(PandaParserShort-37))|(1<<(PandaParserThis-37))|(1<<(PandaParserThrow-37))|(1<<(PandaParserUint-37))|(1<<(PandaParserUint8-37))|(1<<(PandaParserUint16-37))|(1<<(PandaParserUint32-37))|(1<<(PandaParserUint64-37))|(1<<(PandaParserUlong-37))|(1<<(PandaParserUshort-37))|(1<<(PandaParserVar-37))|(1<<(PandaParserVoid-37))|(1<<(PandaParserLeftParen-37))|(1<<(PandaParserLeftBrace-37))|(1<<(PandaParserPlus-37))|(1<<(PandaParserMinus-37))|(1<<(PandaParserOr-37))|(1<<(PandaParserTilde-37))|(1<<(PandaParserNot-37)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(PandaParserPlusPlus-88))|(1<<(PandaParserMinusMinus-88))|(1<<(PandaParserIdentifier-88))|(1<<(PandaParserIntegerLiteral-88))|(1<<(PandaParserFloatLiteral-88))|(1<<(PandaParserStringLiteral-88))|(1<<(PandaParserBooleanLiteral-88))|(1<<(PandaParserPointerLiteral-88)))) != 0) {
			{
				p.SetState(267)
				p.Expression_list()
			}

		}
		{
			p.SetState(270)
			p.Match(PandaParserRightParen)
		}

	case 3:
		{
			p.SetState(272)
			p.Type_name_specifier()
		}
		{
			p.SetState(273)
			p.Match(PandaParserLeftParen)
		}
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(PandaParserShort-37))|(1<<(PandaParserThis-37))|(1<<(PandaParserThrow-37))|(1<<(PandaParserUint-37))|(1<<(PandaParserUint8-37))|(1<<(PandaParserUint16-37))|(1<<(PandaParserUint32-37))|(1<<(PandaParserUint64-37))|(1<<(PandaParserUlong-37))|(1<<(PandaParserUshort-37))|(1<<(PandaParserVar-37))|(1<<(PandaParserVoid-37))|(1<<(PandaParserLeftParen-37))|(1<<(PandaParserLeftBrace-37))|(1<<(PandaParserPlus-37))|(1<<(PandaParserMinus-37))|(1<<(PandaParserOr-37))|(1<<(PandaParserTilde-37))|(1<<(PandaParserNot-37)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(PandaParserPlusPlus-88))|(1<<(PandaParserMinusMinus-88))|(1<<(PandaParserIdentifier-88))|(1<<(PandaParserIntegerLiteral-88))|(1<<(PandaParserFloatLiteral-88))|(1<<(PandaParserStringLiteral-88))|(1<<(PandaParserBooleanLiteral-88))|(1<<(PandaParserPointerLiteral-88)))) != 0) {
			{
				p.SetState(274)
				p.Expression_list()
			}

		}
		{
			p.SetState(277)
			p.Match(PandaParserRightParen)
		}

	case 4:
		{
			p.SetState(279)
			p.Type_specifier()
		}
		{
			p.SetState(280)
			p.Braced_init_list()
		}

	case 5:
		{
			p.SetState(282)
			p.Type_name_specifier()
		}
		{
			p.SetState(283)
			p.Braced_init_list()
		}

	case 6:
		{
			p.SetState(285)
			p.Match(PandaParserCast)
		}
		{
			p.SetState(286)
			p.Match(PandaParserLess)
		}
		{
			p.SetState(287)
			p.Type_id()
		}
		{
			p.SetState(288)
			p.Match(PandaParserGreater)
		}
		{
			p.SetState(289)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(290)
			p.expression(0)
		}
		{
			p.SetState(291)
			p.Match(PandaParserRightParen)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(315)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(313)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(295)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(296)
					p.Match(PandaParserLeftBracket)
				}
				{
					p.SetState(297)
					p.expression(0)
				}
				{
					p.SetState(298)
					p.Match(PandaParserRightBracket)
				}

			case 2:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(300)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(301)
					p.Match(PandaParserLeftParen)
				}
				p.SetState(303)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(PandaParserShort-37))|(1<<(PandaParserThis-37))|(1<<(PandaParserThrow-37))|(1<<(PandaParserUint-37))|(1<<(PandaParserUint8-37))|(1<<(PandaParserUint16-37))|(1<<(PandaParserUint32-37))|(1<<(PandaParserUint64-37))|(1<<(PandaParserUlong-37))|(1<<(PandaParserUshort-37))|(1<<(PandaParserVar-37))|(1<<(PandaParserVoid-37))|(1<<(PandaParserLeftParen-37))|(1<<(PandaParserLeftBrace-37))|(1<<(PandaParserPlus-37))|(1<<(PandaParserMinus-37))|(1<<(PandaParserOr-37))|(1<<(PandaParserTilde-37))|(1<<(PandaParserNot-37)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(PandaParserPlusPlus-88))|(1<<(PandaParserMinusMinus-88))|(1<<(PandaParserIdentifier-88))|(1<<(PandaParserIntegerLiteral-88))|(1<<(PandaParserFloatLiteral-88))|(1<<(PandaParserStringLiteral-88))|(1<<(PandaParserBooleanLiteral-88))|(1<<(PandaParserPointerLiteral-88)))) != 0) {
					{
						p.SetState(302)
						p.Expression_list()
					}

				}
				{
					p.SetState(305)
					p.Match(PandaParserRightParen)
				}

			case 3:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(306)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(307)
					p.Match(PandaParserDot)
				}
				{
					p.SetState(308)
					p.Id_expression()
				}

			case 4:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(309)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(310)
					p.Match(PandaParserPlusPlus)
				}

			case 5:
				localctx = NewPost_fix_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_post_fix_expression)
				p.SetState(311)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(312)
					p.Match(PandaParserMinusMinus)
				}

			}

		}
		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())
	}

	return localctx
}

// IExpression_listContext is an interface to support dynamic dispatch.
type IExpression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_listContext differentiates from other interfaces.
	IsExpression_listContext()
}

type Expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_listContext() *Expression_listContext {
	var p = new(Expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_expression_list
	return p
}

func (*Expression_listContext) IsExpression_listContext() {}

func NewExpression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_listContext {
	var p = new(Expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_expression_list

	return p
}

func (s *Expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_listContext) Initializer_list() IInitializer_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_listContext)
}

func (s *Expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterExpression_list(s)
	}
}

func (s *Expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitExpression_list(s)
	}
}

func (s *Expression_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitExpression_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Expression_list() (localctx IExpression_listContext) {
	localctx = NewExpression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PandaParserRULE_expression_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.initializer_list(0)
	}

	return localctx
}

// IUnary_expressionContext is an interface to support dynamic dispatch.
type IUnary_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_expressionContext differentiates from other interfaces.
	IsUnary_expressionContext()
}

type Unary_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_expressionContext() *Unary_expressionContext {
	var p = new(Unary_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_unary_expression
	return p
}

func (*Unary_expressionContext) IsUnary_expressionContext() {}

func NewUnary_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_expressionContext {
	var p = new(Unary_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_unary_expression

	return p
}

func (s *Unary_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_expressionContext) Post_fix_expression() IPost_fix_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPost_fix_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPost_fix_expressionContext)
}

func (s *Unary_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Unary_expressionContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Unary_expressionContext) New_expression() INew_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INew_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INew_expressionContext)
}

func (s *Unary_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterUnary_expression(s)
	}
}

func (s *Unary_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitUnary_expression(s)
	}
}

func (s *Unary_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitUnary_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Unary_expression() (localctx IUnary_expressionContext) {
	localctx = NewUnary_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PandaParserRULE_unary_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(329)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserBool, PandaParserCast, PandaParserDouble, PandaParserFloat32, PandaParserFloat64, PandaParserFloat, PandaParserInt, PandaParserInt8, PandaParserInt16, PandaParserInt32, PandaParserInt64, PandaParserLong, PandaParserOperator, PandaParserShort, PandaParserThis, PandaParserUint, PandaParserUint8, PandaParserUint16, PandaParserUint32, PandaParserUint64, PandaParserUlong, PandaParserUshort, PandaParserVar, PandaParserVoid, PandaParserLeftParen, PandaParserIdentifier, PandaParserIntegerLiteral, PandaParserFloatLiteral, PandaParserStringLiteral, PandaParserBooleanLiteral, PandaParserPointerLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(320)
			p.post_fix_expression(0)
		}

	case PandaParserPlusPlus:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(321)
			p.Match(PandaParserPlusPlus)
		}
		{
			p.SetState(322)
			p.Unary_expression()
		}

	case PandaParserMinusMinus:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(323)
			p.Match(PandaParserMinusMinus)
		}
		{
			p.SetState(324)
			p.Unary_expression()
		}

	case PandaParserPlus, PandaParserMinus, PandaParserOr, PandaParserTilde, PandaParserNot:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(325)
			p.Unary_operator()
		}
		{
			p.SetState(326)
			p.Unary_expression()
		}

	case PandaParserNew:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(328)
			p.New_expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (s *Unary_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitUnary_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PandaParserRULE_unary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(331)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-58)&-(0x1f+1)) == 0 && ((1<<uint((_la-58)))&((1<<(PandaParserPlus-58))|(1<<(PandaParserMinus-58))|(1<<(PandaParserOr-58))|(1<<(PandaParserTilde-58))|(1<<(PandaParserNot-58)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INew_expressionContext is an interface to support dynamic dispatch.
type INew_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNew_expressionContext differentiates from other interfaces.
	IsNew_expressionContext()
}

type New_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_expressionContext() *New_expressionContext {
	var p = new(New_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_new_expression
	return p
}

func (*New_expressionContext) IsNew_expressionContext() {}

func NewNew_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_expressionContext {
	var p = new(New_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_new_expression

	return p
}

func (s *New_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *New_expressionContext) New() antlr.TerminalNode {
	return s.GetToken(PandaParserNew, 0)
}

func (s *New_expressionContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *New_expressionContext) New_initializer() INew_initializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INew_initializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INew_initializerContext)
}

func (s *New_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNew_expression(s)
	}
}

func (s *New_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNew_expression(s)
	}
}

func (s *New_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitNew_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) New_expression() (localctx INew_expressionContext) {
	localctx = NewNew_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PandaParserRULE_new_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Match(PandaParserNew)
	}
	{
		p.SetState(334)
		p.Type_specifier_sequence()
	}
	{
		p.SetState(335)
		p.New_initializer()
	}

	return localctx
}

// INew_initializerContext is an interface to support dynamic dispatch.
type INew_initializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNew_initializerContext differentiates from other interfaces.
	IsNew_initializerContext()
}

type New_initializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNew_initializerContext() *New_initializerContext {
	var p = new(New_initializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_new_initializer
	return p
}

func (*New_initializerContext) IsNew_initializerContext() {}

func NewNew_initializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *New_initializerContext {
	var p = new(New_initializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_new_initializer

	return p
}

func (s *New_initializerContext) GetParser() antlr.Parser { return s.parser }

func (s *New_initializerContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *New_initializerContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *New_initializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *New_initializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *New_initializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNew_initializer(s)
	}
}

func (s *New_initializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNew_initializer(s)
	}
}

func (s *New_initializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitNew_initializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) New_initializer() (localctx INew_initializerContext) {
	localctx = NewNew_initializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PandaParserRULE_new_initializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(343)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserLeftParen:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(337)
			p.Match(PandaParserLeftParen)
		}
		p.SetState(339)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(PandaParserShort-37))|(1<<(PandaParserThis-37))|(1<<(PandaParserThrow-37))|(1<<(PandaParserUint-37))|(1<<(PandaParserUint8-37))|(1<<(PandaParserUint16-37))|(1<<(PandaParserUint32-37))|(1<<(PandaParserUint64-37))|(1<<(PandaParserUlong-37))|(1<<(PandaParserUshort-37))|(1<<(PandaParserVar-37))|(1<<(PandaParserVoid-37))|(1<<(PandaParserLeftParen-37))|(1<<(PandaParserLeftBrace-37))|(1<<(PandaParserPlus-37))|(1<<(PandaParserMinus-37))|(1<<(PandaParserOr-37))|(1<<(PandaParserTilde-37))|(1<<(PandaParserNot-37)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(PandaParserPlusPlus-88))|(1<<(PandaParserMinusMinus-88))|(1<<(PandaParserIdentifier-88))|(1<<(PandaParserIntegerLiteral-88))|(1<<(PandaParserFloatLiteral-88))|(1<<(PandaParserStringLiteral-88))|(1<<(PandaParserBooleanLiteral-88))|(1<<(PandaParserPointerLiteral-88)))) != 0) {
			{
				p.SetState(338)
				p.Expression_list()
			}

		}
		{
			p.SetState(341)
			p.Match(PandaParserRightParen)
		}

	case PandaParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(342)
			p.Braced_init_list()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMultiplicative_expressionContext is an interface to support dynamic dispatch.
type IMultiplicative_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicative_expressionContext differentiates from other interfaces.
	IsMultiplicative_expressionContext()
}

type Multiplicative_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicative_expressionContext() *Multiplicative_expressionContext {
	var p = new(Multiplicative_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_multiplicative_expression
	return p
}

func (*Multiplicative_expressionContext) IsMultiplicative_expressionContext() {}

func NewMultiplicative_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Multiplicative_expressionContext {
	var p = new(Multiplicative_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_multiplicative_expression

	return p
}

func (s *Multiplicative_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Multiplicative_expressionContext) Unary_expression() IUnary_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_expressionContext)
}

func (s *Multiplicative_expressionContext) Multiplicative_expression() IMultiplicative_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicative_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplicative_expressionContext)
}

func (s *Multiplicative_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Multiplicative_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Multiplicative_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMultiplicative_expression(s)
	}
}

func (s *Multiplicative_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMultiplicative_expression(s)
	}
}

func (s *Multiplicative_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitMultiplicative_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Multiplicative_expression() (localctx IMultiplicative_expressionContext) {
	return p.multiplicative_expression(0)
}

func (p *PandaParser) multiplicative_expression(_p int) (localctx IMultiplicative_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewMultiplicative_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicative_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 24
	p.EnterRecursionRule(localctx, 24, PandaParserRULE_multiplicative_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(346)
		p.Unary_expression()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(357)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
			case 1:
				localctx = NewMultiplicative_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_multiplicative_expression)
				p.SetState(348)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(349)
					p.Match(PandaParserStar)
				}
				{
					p.SetState(350)
					p.Unary_expression()
				}

			case 2:
				localctx = NewMultiplicative_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_multiplicative_expression)
				p.SetState(351)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(352)
					p.Match(PandaParserDiv)
				}
				{
					p.SetState(353)
					p.Unary_expression()
				}

			case 3:
				localctx = NewMultiplicative_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_multiplicative_expression)
				p.SetState(354)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(355)
					p.Match(PandaParserMod)
				}
				{
					p.SetState(356)
					p.Unary_expression()
				}

			}

		}
		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}

	return localctx
}

// IAdditive_expressionContext is an interface to support dynamic dispatch.
type IAdditive_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditive_expressionContext differentiates from other interfaces.
	IsAdditive_expressionContext()
}

type Additive_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditive_expressionContext() *Additive_expressionContext {
	var p = new(Additive_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_additive_expression
	return p
}

func (*Additive_expressionContext) IsAdditive_expressionContext() {}

func NewAdditive_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Additive_expressionContext {
	var p = new(Additive_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_additive_expression

	return p
}

func (s *Additive_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Additive_expressionContext) Multiplicative_expression() IMultiplicative_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicative_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMultiplicative_expressionContext)
}

func (s *Additive_expressionContext) Additive_expression() IAdditive_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditive_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditive_expressionContext)
}

func (s *Additive_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Additive_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Additive_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAdditive_expression(s)
	}
}

func (s *Additive_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAdditive_expression(s)
	}
}

func (s *Additive_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitAdditive_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Additive_expression() (localctx IAdditive_expressionContext) {
	return p.additive_expression(0)
}

func (p *PandaParser) additive_expression(_p int) (localctx IAdditive_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewAdditive_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditive_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 26
	p.EnterRecursionRule(localctx, 26, PandaParserRULE_additive_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.multiplicative_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(371)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
			case 1:
				localctx = NewAdditive_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_additive_expression)
				p.SetState(365)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(366)
					p.Match(PandaParserPlus)
				}
				{
					p.SetState(367)
					p.multiplicative_expression(0)
				}

			case 2:
				localctx = NewAdditive_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_additive_expression)
				p.SetState(368)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(369)
					p.Match(PandaParserMinus)
				}
				{
					p.SetState(370)
					p.multiplicative_expression(0)
				}

			}

		}
		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// IShift_expressionContext is an interface to support dynamic dispatch.
type IShift_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_expressionContext differentiates from other interfaces.
	IsShift_expressionContext()
}

type Shift_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_expressionContext() *Shift_expressionContext {
	var p = new(Shift_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_shift_expression
	return p
}

func (*Shift_expressionContext) IsShift_expressionContext() {}

func NewShift_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_expressionContext {
	var p = new(Shift_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_shift_expression

	return p
}

func (s *Shift_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_expressionContext) Additive_expression() IAdditive_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditive_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAdditive_expressionContext)
}

func (s *Shift_expressionContext) Shift_expression() IShift_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_expressionContext)
}

func (s *Shift_expressionContext) Shiftoperator() IShiftoperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShiftoperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShiftoperatorContext)
}

func (s *Shift_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterShift_expression(s)
	}
}

func (s *Shift_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitShift_expression(s)
	}
}

func (s *Shift_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitShift_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Shift_expression() (localctx IShift_expressionContext) {
	return p.shift_expression(0)
}

func (p *PandaParser) shift_expression(_p int) (localctx IShift_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewShift_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IShift_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 28
	p.EnterRecursionRule(localctx, 28, PandaParserRULE_shift_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		p.additive_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewShift_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_shift_expression)
			p.SetState(379)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(380)
				p.Shiftoperator()
			}
			{
				p.SetState(381)
				p.additive_expression(0)
			}

		}
		p.SetState(387)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}

	return localctx
}

// IShiftoperatorContext is an interface to support dynamic dispatch.
type IShiftoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShiftoperatorContext differentiates from other interfaces.
	IsShiftoperatorContext()
}

type ShiftoperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftoperatorContext() *ShiftoperatorContext {
	var p = new(ShiftoperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_shiftoperator
	return p
}

func (*ShiftoperatorContext) IsShiftoperatorContext() {}

func NewShiftoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftoperatorContext {
	var p = new(ShiftoperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_shiftoperator

	return p
}

func (s *ShiftoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftoperatorContext) RightShift() antlr.TerminalNode {
	return s.GetToken(PandaParserRightShift, 0)
}

func (s *ShiftoperatorContext) LeftShift() antlr.TerminalNode {
	return s.GetToken(PandaParserLeftShift, 0)
}

func (s *ShiftoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterShiftoperator(s)
	}
}

func (s *ShiftoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitShiftoperator(s)
	}
}

func (s *ShiftoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitShiftoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Shiftoperator() (localctx IShiftoperatorContext) {
	localctx = NewShiftoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PandaParserRULE_shiftoperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(388)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PandaParserLeftShift || _la == PandaParserRightShift) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRelational_expressionContext is an interface to support dynamic dispatch.
type IRelational_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelational_expressionContext differentiates from other interfaces.
	IsRelational_expressionContext()
}

type Relational_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelational_expressionContext() *Relational_expressionContext {
	var p = new(Relational_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_relational_expression
	return p
}

func (*Relational_expressionContext) IsRelational_expressionContext() {}

func NewRelational_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Relational_expressionContext {
	var p = new(Relational_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_relational_expression

	return p
}

func (s *Relational_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Relational_expressionContext) Shift_expression() IShift_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IShift_expressionContext)
}

func (s *Relational_expressionContext) Relational_expression() IRelational_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelational_expressionContext)
}

func (s *Relational_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Relational_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Relational_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterRelational_expression(s)
	}
}

func (s *Relational_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitRelational_expression(s)
	}
}

func (s *Relational_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitRelational_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Relational_expression() (localctx IRelational_expressionContext) {
	return p.relational_expression(0)
}

func (p *PandaParser) relational_expression(_p int) (localctx IRelational_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRelational_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRelational_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 32
	p.EnterRecursionRule(localctx, 32, PandaParserRULE_relational_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.shift_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(405)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
			case 1:
				localctx = NewRelational_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_relational_expression)
				p.SetState(393)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(394)
					p.Match(PandaParserLess)
				}
				{
					p.SetState(395)
					p.shift_expression(0)
				}

			case 2:
				localctx = NewRelational_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_relational_expression)
				p.SetState(396)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(397)
					p.Match(PandaParserGreater)
				}
				{
					p.SetState(398)
					p.shift_expression(0)
				}

			case 3:
				localctx = NewRelational_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_relational_expression)
				p.SetState(399)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(400)
					p.Match(PandaParserLessEqual)
				}
				{
					p.SetState(401)
					p.shift_expression(0)
				}

			case 4:
				localctx = NewRelational_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_relational_expression)
				p.SetState(402)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(403)
					p.Match(PandaParserGreaterEqual)
				}
				{
					p.SetState(404)
					p.shift_expression(0)
				}

			}

		}
		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
	}

	return localctx
}

// IEquality_expressionContext is an interface to support dynamic dispatch.
type IEquality_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEquality_expressionContext differentiates from other interfaces.
	IsEquality_expressionContext()
}

type Equality_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEquality_expressionContext() *Equality_expressionContext {
	var p = new(Equality_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_equality_expression
	return p
}

func (*Equality_expressionContext) IsEquality_expressionContext() {}

func NewEquality_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Equality_expressionContext {
	var p = new(Equality_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_equality_expression

	return p
}

func (s *Equality_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Equality_expressionContext) Relational_expression() IRelational_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelational_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelational_expressionContext)
}

func (s *Equality_expressionContext) Equality_expression() IEquality_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquality_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEquality_expressionContext)
}

func (s *Equality_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Equality_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Equality_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEquality_expression(s)
	}
}

func (s *Equality_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEquality_expression(s)
	}
}

func (s *Equality_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitEquality_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Equality_expression() (localctx IEquality_expressionContext) {
	return p.equality_expression(0)
}

func (p *PandaParser) equality_expression(_p int) (localctx IEquality_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewEquality_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEquality_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 34
	p.EnterRecursionRule(localctx, 34, PandaParserRULE_equality_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(411)
		p.relational_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(419)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
			case 1:
				localctx = NewEquality_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_equality_expression)
				p.SetState(413)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(414)
					p.Match(PandaParserEqual)
				}
				{
					p.SetState(415)
					p.relational_expression(0)
				}

			case 2:
				localctx = NewEquality_expressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_equality_expression)
				p.SetState(416)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(417)
					p.Match(PandaParserNotEqual)
				}
				{
					p.SetState(418)
					p.relational_expression(0)
				}

			}

		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext())
	}

	return localctx
}

// IAnd_expressionContext is an interface to support dynamic dispatch.
type IAnd_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_expressionContext differentiates from other interfaces.
	IsAnd_expressionContext()
}

type And_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_expressionContext() *And_expressionContext {
	var p = new(And_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_and_expression
	return p
}

func (*And_expressionContext) IsAnd_expressionContext() {}

func NewAnd_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_expressionContext {
	var p = new(And_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_and_expression

	return p
}

func (s *And_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *And_expressionContext) Equality_expression() IEquality_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquality_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEquality_expressionContext)
}

func (s *And_expressionContext) And_expression() IAnd_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *And_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAnd_expression(s)
	}
}

func (s *And_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAnd_expression(s)
	}
}

func (s *And_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitAnd_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) And_expression() (localctx IAnd_expressionContext) {
	return p.and_expression(0)
}

func (p *PandaParser) and_expression(_p int) (localctx IAnd_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewAnd_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAnd_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 36
	p.EnterRecursionRule(localctx, 36, PandaParserRULE_and_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)
		p.equality_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(432)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAnd_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_and_expression)
			p.SetState(427)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(428)
				p.Match(PandaParserAnd)
			}
			{
				p.SetState(429)
				p.equality_expression(0)
			}

		}
		p.SetState(434)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext())
	}

	return localctx
}

// IExclusiveor_expressionContext is an interface to support dynamic dispatch.
type IExclusiveor_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusiveor_expressionContext differentiates from other interfaces.
	IsExclusiveor_expressionContext()
}

type Exclusiveor_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusiveor_expressionContext() *Exclusiveor_expressionContext {
	var p = new(Exclusiveor_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_exclusiveor_expression
	return p
}

func (*Exclusiveor_expressionContext) IsExclusiveor_expressionContext() {}

func NewExclusiveor_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exclusiveor_expressionContext {
	var p = new(Exclusiveor_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_exclusiveor_expression

	return p
}

func (s *Exclusiveor_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Exclusiveor_expressionContext) And_expression() IAnd_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnd_expressionContext)
}

func (s *Exclusiveor_expressionContext) Exclusiveor_expression() IExclusiveor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusiveor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusiveor_expressionContext)
}

func (s *Exclusiveor_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exclusiveor_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exclusiveor_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterExclusiveor_expression(s)
	}
}

func (s *Exclusiveor_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitExclusiveor_expression(s)
	}
}

func (s *Exclusiveor_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitExclusiveor_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Exclusiveor_expression() (localctx IExclusiveor_expressionContext) {
	return p.exclusiveor_expression(0)
}

func (p *PandaParser) exclusiveor_expression(_p int) (localctx IExclusiveor_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExclusiveor_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExclusiveor_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 38
	p.EnterRecursionRule(localctx, 38, PandaParserRULE_exclusiveor_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(436)
		p.and_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExclusiveor_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_exclusiveor_expression)
			p.SetState(438)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(439)
				p.Match(PandaParserCaret)
			}
			{
				p.SetState(440)
				p.and_expression(0)
			}

		}
		p.SetState(445)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}

	return localctx
}

// IInclusiveor_expressionContext is an interface to support dynamic dispatch.
type IInclusiveor_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInclusiveor_expressionContext differentiates from other interfaces.
	IsInclusiveor_expressionContext()
}

type Inclusiveor_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclusiveor_expressionContext() *Inclusiveor_expressionContext {
	var p = new(Inclusiveor_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_inclusiveor_expression
	return p
}

func (*Inclusiveor_expressionContext) IsInclusiveor_expressionContext() {}

func NewInclusiveor_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Inclusiveor_expressionContext {
	var p = new(Inclusiveor_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_inclusiveor_expression

	return p
}

func (s *Inclusiveor_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Inclusiveor_expressionContext) Exclusiveor_expression() IExclusiveor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusiveor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusiveor_expressionContext)
}

func (s *Inclusiveor_expressionContext) Inclusiveor_expression() IInclusiveor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclusiveor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclusiveor_expressionContext)
}

func (s *Inclusiveor_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Inclusiveor_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Inclusiveor_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInclusiveor_expression(s)
	}
}

func (s *Inclusiveor_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInclusiveor_expression(s)
	}
}

func (s *Inclusiveor_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitInclusiveor_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Inclusiveor_expression() (localctx IInclusiveor_expressionContext) {
	return p.inclusiveor_expression(0)
}

func (p *PandaParser) inclusiveor_expression(_p int) (localctx IInclusiveor_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInclusiveor_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInclusiveor_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 40
	p.EnterRecursionRule(localctx, 40, PandaParserRULE_inclusiveor_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.exclusiveor_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInclusiveor_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_inclusiveor_expression)
			p.SetState(449)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(450)
				p.Match(PandaParserOr)
			}
			{
				p.SetState(451)
				p.exclusiveor_expression(0)
			}

		}
		p.SetState(456)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
	}

	return localctx
}

// ILogical_and_expressionContext is an interface to support dynamic dispatch.
type ILogical_and_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_and_expressionContext differentiates from other interfaces.
	IsLogical_and_expressionContext()
}

type Logical_and_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_and_expressionContext() *Logical_and_expressionContext {
	var p = new(Logical_and_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_logical_and_expression
	return p
}

func (*Logical_and_expressionContext) IsLogical_and_expressionContext() {}

func NewLogical_and_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_and_expressionContext {
	var p = new(Logical_and_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_logical_and_expression

	return p
}

func (s *Logical_and_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_and_expressionContext) Inclusiveor_expression() IInclusiveor_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclusiveor_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclusiveor_expressionContext)
}

func (s *Logical_and_expressionContext) Logical_and_expression() ILogical_and_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_and_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_and_expressionContext)
}

func (s *Logical_and_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_and_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_and_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLogical_and_expression(s)
	}
}

func (s *Logical_and_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLogical_and_expression(s)
	}
}

func (s *Logical_and_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitLogical_and_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Logical_and_expression() (localctx ILogical_and_expressionContext) {
	return p.logical_and_expression(0)
}

func (p *PandaParser) logical_and_expression(_p int) (localctx ILogical_and_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewLogical_and_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogical_and_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 42
	p.EnterRecursionRule(localctx, 42, PandaParserRULE_logical_and_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.inclusiveor_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogical_and_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_logical_and_expression)
			p.SetState(460)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(461)
				p.Match(PandaParserAndAnd)
			}
			{
				p.SetState(462)
				p.inclusiveor_expression(0)
			}

		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}

	return localctx
}

// ILogical_or_expressionContext is an interface to support dynamic dispatch.
type ILogical_or_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogical_or_expressionContext differentiates from other interfaces.
	IsLogical_or_expressionContext()
}

type Logical_or_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogical_or_expressionContext() *Logical_or_expressionContext {
	var p = new(Logical_or_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_logical_or_expression
	return p
}

func (*Logical_or_expressionContext) IsLogical_or_expressionContext() {}

func NewLogical_or_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Logical_or_expressionContext {
	var p = new(Logical_or_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_logical_or_expression

	return p
}

func (s *Logical_or_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Logical_or_expressionContext) Logical_and_expression() ILogical_and_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_and_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_and_expressionContext)
}

func (s *Logical_or_expressionContext) Logical_or_expression() ILogical_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_or_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_or_expressionContext)
}

func (s *Logical_or_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Logical_or_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Logical_or_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLogical_or_expression(s)
	}
}

func (s *Logical_or_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLogical_or_expression(s)
	}
}

func (s *Logical_or_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitLogical_or_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Logical_or_expression() (localctx ILogical_or_expressionContext) {
	return p.logical_or_expression(0)
}

func (p *PandaParser) logical_or_expression(_p int) (localctx ILogical_or_expressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewLogical_or_expressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogical_or_expressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 44
	p.EnterRecursionRule(localctx, 44, PandaParserRULE_logical_or_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.logical_and_expression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogical_or_expressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_logical_or_expression)
			p.SetState(471)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(472)
				p.Match(PandaParserOrOr)
			}
			{
				p.SetState(473)
				p.logical_and_expression(0)
			}

		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}

	return localctx
}

// IConditional_expressionContext is an interface to support dynamic dispatch.
type IConditional_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditional_expressionContext differentiates from other interfaces.
	IsConditional_expressionContext()
}

type Conditional_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditional_expressionContext() *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_conditional_expression
	return p
}

func (*Conditional_expressionContext) IsConditional_expressionContext() {}

func NewConditional_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_expressionContext {
	var p = new(Conditional_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_conditional_expression

	return p
}

func (s *Conditional_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_expressionContext) Logical_or_expression() ILogical_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_or_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_or_expressionContext)
}

func (s *Conditional_expressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Conditional_expressionContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Conditional_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterConditional_expression(s)
	}
}

func (s *Conditional_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitConditional_expression(s)
	}
}

func (s *Conditional_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitConditional_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Conditional_expression() (localctx IConditional_expressionContext) {
	localctx = NewConditional_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PandaParserRULE_conditional_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(479)
			p.logical_or_expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(480)
			p.logical_or_expression(0)
		}
		{
			p.SetState(481)
			p.Match(PandaParserQuestion)
		}
		{
			p.SetState(482)
			p.expression(0)
		}
		{
			p.SetState(483)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(484)
			p.Assignment_expression()
		}

	}

	return localctx
}

// IAssignment_expressionContext is an interface to support dynamic dispatch.
type IAssignment_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_expressionContext differentiates from other interfaces.
	IsAssignment_expressionContext()
}

type Assignment_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_expressionContext() *Assignment_expressionContext {
	var p = new(Assignment_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_assignment_expression
	return p
}

func (*Assignment_expressionContext) IsAssignment_expressionContext() {}

func NewAssignment_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_expressionContext {
	var p = new(Assignment_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_assignment_expression

	return p
}

func (s *Assignment_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_expressionContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Assignment_expressionContext) Logical_or_expression() ILogical_or_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogical_or_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogical_or_expressionContext)
}

func (s *Assignment_expressionContext) Assignment_operator() IAssignment_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_operatorContext)
}

func (s *Assignment_expressionContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *Assignment_expressionContext) Throw_expression() IThrow_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrow_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrow_expressionContext)
}

func (s *Assignment_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAssignment_expression(s)
	}
}

func (s *Assignment_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAssignment_expression(s)
	}
}

func (s *Assignment_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitAssignment_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Assignment_expression() (localctx IAssignment_expressionContext) {
	localctx = NewAssignment_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PandaParserRULE_assignment_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(488)
			p.Conditional_expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(489)
			p.logical_or_expression(0)
		}
		{
			p.SetState(490)
			p.Assignment_operator()
		}
		{
			p.SetState(491)
			p.Initializer_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(493)
			p.Throw_expression()
		}

	}

	return localctx
}

// IAssignment_operatorContext is an interface to support dynamic dispatch.
type IAssignment_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_operatorContext differentiates from other interfaces.
	IsAssignment_operatorContext()
}

type Assignment_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_operatorContext() *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_assignment_operator
	return p
}

func (*Assignment_operatorContext) IsAssignment_operatorContext() {}

func NewAssignment_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_operatorContext {
	var p = new(Assignment_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_assignment_operator

	return p
}

func (s *Assignment_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_operatorContext) RightShiftAssign() antlr.TerminalNode {
	return s.GetToken(PandaParserRightShiftAssign, 0)
}

func (s *Assignment_operatorContext) LeftShiftAssign() antlr.TerminalNode {
	return s.GetToken(PandaParserLeftShiftAssign, 0)
}

func (s *Assignment_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAssignment_operator(s)
	}
}

func (s *Assignment_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAssignment_operator(s)
	}
}

func (s *Assignment_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitAssignment_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Assignment_operator() (localctx IAssignment_operatorContext) {
	localctx = NewAssignment_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PandaParserRULE_assignment_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(PandaParserAssign-68))|(1<<(PandaParserPlusAssign-68))|(1<<(PandaParserMinusAssign-68))|(1<<(PandaParserDivAssign-68))|(1<<(PandaParserModAssign-68))|(1<<(PandaParserXorAssign-68))|(1<<(PandaParserAndAssign-68))|(1<<(PandaParserOrAssign-68))|(1<<(PandaParserLeftShiftAssign-68))|(1<<(PandaParserRightShiftAssign-68)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *ExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *PandaParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 52
	p.EnterRecursionRule(localctx, 52, PandaParserRULE_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.Assignment_expression()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(506)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewExpressionContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_expression)
			p.SetState(501)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(502)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(503)
				p.Assignment_expression()
			}

		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext())
	}

	return localctx
}

// IConstant_expressionContext is an interface to support dynamic dispatch.
type IConstant_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_expressionContext differentiates from other interfaces.
	IsConstant_expressionContext()
}

type Constant_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_expressionContext() *Constant_expressionContext {
	var p = new(Constant_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_constant_expression
	return p
}

func (*Constant_expressionContext) IsConstant_expressionContext() {}

func NewConstant_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_expressionContext {
	var p = new(Constant_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_constant_expression

	return p
}

func (s *Constant_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_expressionContext) Conditional_expression() IConditional_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditional_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditional_expressionContext)
}

func (s *Constant_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterConstant_expression(s)
	}
}

func (s *Constant_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitConstant_expression(s)
	}
}

func (s *Constant_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitConstant_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Constant_expression() (localctx IConstant_expressionContext) {
	localctx = NewConstant_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PandaParserRULE_constant_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Conditional_expression()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Labeled_statement() ILabeled_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabeled_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabeled_statementContext)
}

func (s *StatementContext) Expression_statement() IExpression_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_statementContext)
}

func (s *StatementContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *StatementContext) Selection_statement() ISelection_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelection_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelection_statementContext)
}

func (s *StatementContext) Iteration_statement() IIteration_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteration_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteration_statementContext)
}

func (s *StatementContext) Jump_statement() IJump_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJump_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJump_statementContext)
}

func (s *StatementContext) Declaration_statement() IDeclaration_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_statementContext)
}

func (s *StatementContext) Try_block() ITry_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITry_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITry_blockContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PandaParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(519)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(511)
			p.Labeled_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(512)
			p.Expression_statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(513)
			p.Compound_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(514)
			p.Selection_statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(515)
			p.Iteration_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(516)
			p.Jump_statement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(517)
			p.Declaration_statement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(518)
			p.Try_block()
		}

	}

	return localctx
}

// ILabeled_statementContext is an interface to support dynamic dispatch.
type ILabeled_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabeled_statementContext differentiates from other interfaces.
	IsLabeled_statementContext()
}

type Labeled_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeled_statementContext() *Labeled_statementContext {
	var p = new(Labeled_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_labeled_statement
	return p
}

func (*Labeled_statementContext) IsLabeled_statementContext() {}

func NewLabeled_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Labeled_statementContext {
	var p = new(Labeled_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_labeled_statement

	return p
}

func (s *Labeled_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Labeled_statementContext) Case() antlr.TerminalNode {
	return s.GetToken(PandaParserCase, 0)
}

func (s *Labeled_statementContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Labeled_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Labeled_statementContext) Default() antlr.TerminalNode {
	return s.GetToken(PandaParserDefault, 0)
}

func (s *Labeled_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Labeled_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Labeled_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLabeled_statement(s)
	}
}

func (s *Labeled_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLabeled_statement(s)
	}
}

func (s *Labeled_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitLabeled_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Labeled_statement() (localctx ILabeled_statementContext) {
	localctx = NewLabeled_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PandaParserRULE_labeled_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(529)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserCase:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(521)
			p.Match(PandaParserCase)
		}
		{
			p.SetState(522)
			p.Constant_expression()
		}
		{
			p.SetState(523)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(524)
			p.Statement()
		}

	case PandaParserDefault:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(526)
			p.Match(PandaParserDefault)
		}
		{
			p.SetState(527)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(528)
			p.Statement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpression_statementContext is an interface to support dynamic dispatch.
type IExpression_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_statementContext differentiates from other interfaces.
	IsExpression_statementContext()
}

type Expression_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_statementContext() *Expression_statementContext {
	var p = new(Expression_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_expression_statement
	return p
}

func (*Expression_statementContext) IsExpression_statementContext() {}

func NewExpression_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_statementContext {
	var p = new(Expression_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_expression_statement

	return p
}

func (s *Expression_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterExpression_statement(s)
	}
}

func (s *Expression_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitExpression_statement(s)
	}
}

func (s *Expression_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitExpression_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Expression_statement() (localctx IExpression_statementContext) {
	localctx = NewExpression_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PandaParserRULE_expression_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(PandaParserShort-37))|(1<<(PandaParserThis-37))|(1<<(PandaParserThrow-37))|(1<<(PandaParserUint-37))|(1<<(PandaParserUint8-37))|(1<<(PandaParserUint16-37))|(1<<(PandaParserUint32-37))|(1<<(PandaParserUint64-37))|(1<<(PandaParserUlong-37))|(1<<(PandaParserUshort-37))|(1<<(PandaParserVar-37))|(1<<(PandaParserVoid-37))|(1<<(PandaParserLeftParen-37))|(1<<(PandaParserPlus-37))|(1<<(PandaParserMinus-37))|(1<<(PandaParserOr-37))|(1<<(PandaParserTilde-37))|(1<<(PandaParserNot-37)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(PandaParserPlusPlus-88))|(1<<(PandaParserMinusMinus-88))|(1<<(PandaParserIdentifier-88))|(1<<(PandaParserIntegerLiteral-88))|(1<<(PandaParserFloatLiteral-88))|(1<<(PandaParserStringLiteral-88))|(1<<(PandaParserBooleanLiteral-88))|(1<<(PandaParserPointerLiteral-88)))) != 0) {
		{
			p.SetState(531)
			p.expression(0)
		}

	}
	{
		p.SetState(534)
		p.Match(PandaParserSemi)
	}

	return localctx
}

// ICompound_statementContext is an interface to support dynamic dispatch.
type ICompound_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompound_statementContext differentiates from other interfaces.
	IsCompound_statementContext()
}

type Compound_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompound_statementContext() *Compound_statementContext {
	var p = new(Compound_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_compound_statement
	return p
}

func (*Compound_statementContext) IsCompound_statementContext() {}

func NewCompound_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Compound_statementContext {
	var p = new(Compound_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_compound_statement

	return p
}

func (s *Compound_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Compound_statementContext) Statement_sequence() IStatement_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_sequenceContext)
}

func (s *Compound_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Compound_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Compound_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterCompound_statement(s)
	}
}

func (s *Compound_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitCompound_statement(s)
	}
}

func (s *Compound_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitCompound_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Compound_statement() (localctx ICompound_statementContext) {
	localctx = NewCompound_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PandaParserRULE_compound_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(536)
		p.Match(PandaParserLeftBrace)
	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserBreak)|(1<<PandaParserCase)|(1<<PandaParserCast)|(1<<PandaParserConst)|(1<<PandaParserContinue)|(1<<PandaParserDefault)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserFor)|(1<<PandaParserIf)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PandaParserPrivate-32))|(1<<(PandaParserProtected-32))|(1<<(PandaParserPublic-32))|(1<<(PandaParserReturn-32))|(1<<(PandaParserStatic-32))|(1<<(PandaParserShort-32))|(1<<(PandaParserSwitch-32))|(1<<(PandaParserThis-32))|(1<<(PandaParserThrow-32))|(1<<(PandaParserTry-32))|(1<<(PandaParserUint-32))|(1<<(PandaParserUint8-32))|(1<<(PandaParserUint16-32))|(1<<(PandaParserUint32-32))|(1<<(PandaParserUint64-32))|(1<<(PandaParserUlong-32))|(1<<(PandaParserUshort-32))|(1<<(PandaParserVar-32))|(1<<(PandaParserVoid-32))|(1<<(PandaParserLeftParen-32))|(1<<(PandaParserLeftBrace-32))|(1<<(PandaParserPlus-32))|(1<<(PandaParserMinus-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PandaParserAnd-64))|(1<<(PandaParserOr-64))|(1<<(PandaParserTilde-64))|(1<<(PandaParserNot-64))|(1<<(PandaParserPlusPlus-64))|(1<<(PandaParserMinusMinus-64))|(1<<(PandaParserSemi-64))|(1<<(PandaParserEllipsis-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PandaParserIdentifier-96))|(1<<(PandaParserIntegerLiteral-96))|(1<<(PandaParserFloatLiteral-96))|(1<<(PandaParserStringLiteral-96))|(1<<(PandaParserBooleanLiteral-96))|(1<<(PandaParserPointerLiteral-96)))) != 0) {
		{
			p.SetState(537)
			p.statement_sequence(0)
		}

	}
	{
		p.SetState(540)
		p.Match(PandaParserRightBrace)
	}

	return localctx
}

// IStatement_sequenceContext is an interface to support dynamic dispatch.
type IStatement_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_sequenceContext differentiates from other interfaces.
	IsStatement_sequenceContext()
}

type Statement_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_sequenceContext() *Statement_sequenceContext {
	var p = new(Statement_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_statement_sequence
	return p
}

func (*Statement_sequenceContext) IsStatement_sequenceContext() {}

func NewStatement_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_sequenceContext {
	var p = new(Statement_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_statement_sequence

	return p
}

func (s *Statement_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_sequenceContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Statement_sequenceContext) Statement_sequence() IStatement_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_sequenceContext)
}

func (s *Statement_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterStatement_sequence(s)
	}
}

func (s *Statement_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitStatement_sequence(s)
	}
}

func (s *Statement_sequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitStatement_sequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Statement_sequence() (localctx IStatement_sequenceContext) {
	return p.statement_sequence(0)
}

func (p *PandaParser) statement_sequence(_p int) (localctx IStatement_sequenceContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewStatement_sequenceContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IStatement_sequenceContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 64
	p.EnterRecursionRule(localctx, 64, PandaParserRULE_statement_sequence, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.Statement()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(549)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewStatement_sequenceContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_statement_sequence)
			p.SetState(545)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(546)
				p.Statement()
			}

		}
		p.SetState(551)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
	}

	return localctx
}

// ISelection_statementContext is an interface to support dynamic dispatch.
type ISelection_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelection_statementContext differentiates from other interfaces.
	IsSelection_statementContext()
}

type Selection_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelection_statementContext() *Selection_statementContext {
	var p = new(Selection_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_selection_statement
	return p
}

func (*Selection_statementContext) IsSelection_statementContext() {}

func NewSelection_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Selection_statementContext {
	var p = new(Selection_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_selection_statement

	return p
}

func (s *Selection_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Selection_statementContext) If() antlr.TerminalNode {
	return s.GetToken(PandaParserIf, 0)
}

func (s *Selection_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Selection_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Selection_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Selection_statementContext) Else() antlr.TerminalNode {
	return s.GetToken(PandaParserElse, 0)
}

func (s *Selection_statementContext) Switch() antlr.TerminalNode {
	return s.GetToken(PandaParserSwitch, 0)
}

func (s *Selection_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Selection_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Selection_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterSelection_statement(s)
	}
}

func (s *Selection_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitSelection_statement(s)
	}
}

func (s *Selection_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitSelection_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Selection_statement() (localctx ISelection_statementContext) {
	localctx = NewSelection_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PandaParserRULE_selection_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(552)
			p.Match(PandaParserIf)
		}
		{
			p.SetState(553)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(554)
			p.Condition()
		}
		{
			p.SetState(555)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(556)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(558)
			p.Match(PandaParserIf)
		}
		{
			p.SetState(559)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(560)
			p.Condition()
		}
		{
			p.SetState(561)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(562)
			p.Statement()
		}
		{
			p.SetState(563)
			p.Match(PandaParserElse)
		}
		{
			p.SetState(564)
			p.Statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(566)
			p.Match(PandaParserSwitch)
		}
		{
			p.SetState(567)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(568)
			p.Condition()
		}
		{
			p.SetState(569)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(570)
			p.Statement()
		}

	}

	return localctx
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_condition
	return p
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *ConditionContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *ConditionContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *ConditionContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (s *ConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PandaParserRULE_condition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(574)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(575)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(576)
			p.Declarator()
		}
		{
			p.SetState(577)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(578)
			p.Initializer_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(580)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(581)
			p.Declarator()
		}
		{
			p.SetState(582)
			p.Braced_init_list()
		}

	}

	return localctx
}

// IIteration_statementContext is an interface to support dynamic dispatch.
type IIteration_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteration_statementContext differentiates from other interfaces.
	IsIteration_statementContext()
}

type Iteration_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteration_statementContext() *Iteration_statementContext {
	var p = new(Iteration_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_iteration_statement
	return p
}

func (*Iteration_statementContext) IsIteration_statementContext() {}

func NewIteration_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Iteration_statementContext {
	var p = new(Iteration_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_iteration_statement

	return p
}

func (s *Iteration_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Iteration_statementContext) For() antlr.TerminalNode {
	return s.GetToken(PandaParserFor, 0)
}

func (s *Iteration_statementContext) For_init_statement() IFor_init_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_init_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_init_statementContext)
}

func (s *Iteration_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Iteration_statementContext) Condition() IConditionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *Iteration_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Iteration_statementContext) For_range_declaration() IFor_range_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_range_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_range_declarationContext)
}

func (s *Iteration_statementContext) For_range_initializer() IFor_range_initializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_range_initializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_range_initializerContext)
}

func (s *Iteration_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Iteration_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Iteration_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterIteration_statement(s)
	}
}

func (s *Iteration_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitIteration_statement(s)
	}
}

func (s *Iteration_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitIteration_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Iteration_statement() (localctx IIteration_statementContext) {
	localctx = NewIteration_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PandaParserRULE_iteration_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(586)
			p.Match(PandaParserFor)
		}
		{
			p.SetState(587)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(588)
			p.For_init_statement()
		}
		p.SetState(590)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserConst)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PandaParserPrivate-32))|(1<<(PandaParserProtected-32))|(1<<(PandaParserPublic-32))|(1<<(PandaParserStatic-32))|(1<<(PandaParserShort-32))|(1<<(PandaParserThis-32))|(1<<(PandaParserThrow-32))|(1<<(PandaParserUint-32))|(1<<(PandaParserUint8-32))|(1<<(PandaParserUint16-32))|(1<<(PandaParserUint32-32))|(1<<(PandaParserUint64-32))|(1<<(PandaParserUlong-32))|(1<<(PandaParserUshort-32))|(1<<(PandaParserVar-32))|(1<<(PandaParserVoid-32))|(1<<(PandaParserLeftParen-32))|(1<<(PandaParserPlus-32))|(1<<(PandaParserMinus-32)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(PandaParserOr-65))|(1<<(PandaParserTilde-65))|(1<<(PandaParserNot-65))|(1<<(PandaParserPlusPlus-65))|(1<<(PandaParserMinusMinus-65))|(1<<(PandaParserIdentifier-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(PandaParserIntegerLiteral-97))|(1<<(PandaParserFloatLiteral-97))|(1<<(PandaParserStringLiteral-97))|(1<<(PandaParserBooleanLiteral-97))|(1<<(PandaParserPointerLiteral-97)))) != 0) {
			{
				p.SetState(589)
				p.Condition()
			}

		}
		{
			p.SetState(592)
			p.Match(PandaParserSemi)
		}
		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(PandaParserShort-37))|(1<<(PandaParserThis-37))|(1<<(PandaParserThrow-37))|(1<<(PandaParserUint-37))|(1<<(PandaParserUint8-37))|(1<<(PandaParserUint16-37))|(1<<(PandaParserUint32-37))|(1<<(PandaParserUint64-37))|(1<<(PandaParserUlong-37))|(1<<(PandaParserUshort-37))|(1<<(PandaParserVar-37))|(1<<(PandaParserVoid-37))|(1<<(PandaParserLeftParen-37))|(1<<(PandaParserPlus-37))|(1<<(PandaParserMinus-37))|(1<<(PandaParserOr-37))|(1<<(PandaParserTilde-37))|(1<<(PandaParserNot-37)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(PandaParserPlusPlus-88))|(1<<(PandaParserMinusMinus-88))|(1<<(PandaParserIdentifier-88))|(1<<(PandaParserIntegerLiteral-88))|(1<<(PandaParserFloatLiteral-88))|(1<<(PandaParserStringLiteral-88))|(1<<(PandaParserBooleanLiteral-88))|(1<<(PandaParserPointerLiteral-88)))) != 0) {
			{
				p.SetState(593)
				p.expression(0)
			}

		}
		{
			p.SetState(596)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(597)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(599)
			p.Match(PandaParserFor)
		}
		{
			p.SetState(600)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(601)
			p.For_range_declaration()
		}
		{
			p.SetState(602)
			p.Match(PandaParserColon)
		}
		{
			p.SetState(603)
			p.For_range_initializer()
		}
		{
			p.SetState(604)
			p.Match(PandaParserRightParen)
		}
		{
			p.SetState(605)
			p.Statement()
		}

	}

	return localctx
}

// IFor_init_statementContext is an interface to support dynamic dispatch.
type IFor_init_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_init_statementContext differentiates from other interfaces.
	IsFor_init_statementContext()
}

type For_init_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_init_statementContext() *For_init_statementContext {
	var p = new(For_init_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_for_init_statement
	return p
}

func (*For_init_statementContext) IsFor_init_statementContext() {}

func NewFor_init_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_init_statementContext {
	var p = new(For_init_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_for_init_statement

	return p
}

func (s *For_init_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *For_init_statementContext) Expression_statement() IExpression_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_statementContext)
}

func (s *For_init_statementContext) Block_declaration() IBlock_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarationContext)
}

func (s *For_init_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_init_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_init_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFor_init_statement(s)
	}
}

func (s *For_init_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFor_init_statement(s)
	}
}

func (s *For_init_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitFor_init_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) For_init_statement() (localctx IFor_init_statementContext) {
	localctx = NewFor_init_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PandaParserRULE_for_init_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(611)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(609)
			p.Expression_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(610)
			p.Block_declaration()
		}

	}

	return localctx
}

// IFor_range_declarationContext is an interface to support dynamic dispatch.
type IFor_range_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_range_declarationContext differentiates from other interfaces.
	IsFor_range_declarationContext()
}

type For_range_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_range_declarationContext() *For_range_declarationContext {
	var p = new(For_range_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_for_range_declaration
	return p
}

func (*For_range_declarationContext) IsFor_range_declarationContext() {}

func NewFor_range_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_range_declarationContext {
	var p = new(For_range_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_for_range_declaration

	return p
}

func (s *For_range_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *For_range_declarationContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *For_range_declarationContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *For_range_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_range_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_range_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFor_range_declaration(s)
	}
}

func (s *For_range_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFor_range_declaration(s)
	}
}

func (s *For_range_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitFor_range_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) For_range_declaration() (localctx IFor_range_declarationContext) {
	localctx = NewFor_range_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PandaParserRULE_for_range_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(613)
		p.Decl_specifier_sequence()
	}
	{
		p.SetState(614)
		p.Declarator()
	}

	return localctx
}

// IFor_range_initializerContext is an interface to support dynamic dispatch.
type IFor_range_initializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_range_initializerContext differentiates from other interfaces.
	IsFor_range_initializerContext()
}

type For_range_initializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_range_initializerContext() *For_range_initializerContext {
	var p = new(For_range_initializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_for_range_initializer
	return p
}

func (*For_range_initializerContext) IsFor_range_initializerContext() {}

func NewFor_range_initializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_range_initializerContext {
	var p = new(For_range_initializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_for_range_initializer

	return p
}

func (s *For_range_initializerContext) GetParser() antlr.Parser { return s.parser }

func (s *For_range_initializerContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *For_range_initializerContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *For_range_initializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_range_initializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_range_initializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFor_range_initializer(s)
	}
}

func (s *For_range_initializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFor_range_initializer(s)
	}
}

func (s *For_range_initializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitFor_range_initializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) For_range_initializer() (localctx IFor_range_initializerContext) {
	localctx = NewFor_range_initializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PandaParserRULE_for_range_initializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(618)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserBool, PandaParserCast, PandaParserDouble, PandaParserFloat32, PandaParserFloat64, PandaParserFloat, PandaParserInt, PandaParserInt8, PandaParserInt16, PandaParserInt32, PandaParserInt64, PandaParserLong, PandaParserNew, PandaParserOperator, PandaParserShort, PandaParserThis, PandaParserThrow, PandaParserUint, PandaParserUint8, PandaParserUint16, PandaParserUint32, PandaParserUint64, PandaParserUlong, PandaParserUshort, PandaParserVar, PandaParserVoid, PandaParserLeftParen, PandaParserPlus, PandaParserMinus, PandaParserOr, PandaParserTilde, PandaParserNot, PandaParserPlusPlus, PandaParserMinusMinus, PandaParserIdentifier, PandaParserIntegerLiteral, PandaParserFloatLiteral, PandaParserStringLiteral, PandaParserBooleanLiteral, PandaParserPointerLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(616)
			p.expression(0)
		}

	case PandaParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(617)
			p.Braced_init_list()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJump_statementContext is an interface to support dynamic dispatch.
type IJump_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJump_statementContext differentiates from other interfaces.
	IsJump_statementContext()
}

type Jump_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJump_statementContext() *Jump_statementContext {
	var p = new(Jump_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_jump_statement
	return p
}

func (*Jump_statementContext) IsJump_statementContext() {}

func NewJump_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Jump_statementContext {
	var p = new(Jump_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_jump_statement

	return p
}

func (s *Jump_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Jump_statementContext) Break() antlr.TerminalNode {
	return s.GetToken(PandaParserBreak, 0)
}

func (s *Jump_statementContext) Continue() antlr.TerminalNode {
	return s.GetToken(PandaParserContinue, 0)
}

func (s *Jump_statementContext) Return() antlr.TerminalNode {
	return s.GetToken(PandaParserReturn, 0)
}

func (s *Jump_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Jump_statementContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *Jump_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Jump_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Jump_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterJump_statement(s)
	}
}

func (s *Jump_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitJump_statement(s)
	}
}

func (s *Jump_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitJump_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Jump_statement() (localctx IJump_statementContext) {
	localctx = NewJump_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, PandaParserRULE_jump_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(620)
			p.Match(PandaParserBreak)
		}
		{
			p.SetState(621)
			p.Match(PandaParserSemi)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(622)
			p.Match(PandaParserContinue)
		}
		{
			p.SetState(623)
			p.Match(PandaParserSemi)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(624)
			p.Match(PandaParserReturn)
		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(PandaParserShort-37))|(1<<(PandaParserThis-37))|(1<<(PandaParserThrow-37))|(1<<(PandaParserUint-37))|(1<<(PandaParserUint8-37))|(1<<(PandaParserUint16-37))|(1<<(PandaParserUint32-37))|(1<<(PandaParserUint64-37))|(1<<(PandaParserUlong-37))|(1<<(PandaParserUshort-37))|(1<<(PandaParserVar-37))|(1<<(PandaParserVoid-37))|(1<<(PandaParserLeftParen-37))|(1<<(PandaParserPlus-37))|(1<<(PandaParserMinus-37))|(1<<(PandaParserOr-37))|(1<<(PandaParserTilde-37))|(1<<(PandaParserNot-37)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(PandaParserPlusPlus-88))|(1<<(PandaParserMinusMinus-88))|(1<<(PandaParserIdentifier-88))|(1<<(PandaParserIntegerLiteral-88))|(1<<(PandaParserFloatLiteral-88))|(1<<(PandaParserStringLiteral-88))|(1<<(PandaParserBooleanLiteral-88))|(1<<(PandaParserPointerLiteral-88)))) != 0) {
			{
				p.SetState(625)
				p.expression(0)
			}

		}
		{
			p.SetState(628)
			p.Match(PandaParserSemi)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(629)
			p.Match(PandaParserReturn)
		}
		{
			p.SetState(630)
			p.Braced_init_list()
		}
		{
			p.SetState(631)
			p.Match(PandaParserSemi)
		}

	}

	return localctx
}

// IDeclaration_statementContext is an interface to support dynamic dispatch.
type IDeclaration_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_statementContext differentiates from other interfaces.
	IsDeclaration_statementContext()
}

type Declaration_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_statementContext() *Declaration_statementContext {
	var p = new(Declaration_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declaration_statement
	return p
}

func (*Declaration_statementContext) IsDeclaration_statementContext() {}

func NewDeclaration_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_statementContext {
	var p = new(Declaration_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declaration_statement

	return p
}

func (s *Declaration_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_statementContext) Block_declaration() IBlock_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarationContext)
}

func (s *Declaration_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclaration_statement(s)
	}
}

func (s *Declaration_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclaration_statement(s)
	}
}

func (s *Declaration_statementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitDeclaration_statement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Declaration_statement() (localctx IDeclaration_statementContext) {
	localctx = NewDeclaration_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, PandaParserRULE_declaration_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.Block_declaration()
	}

	return localctx
}

// IDeclaration_sequenceContext is an interface to support dynamic dispatch.
type IDeclaration_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaration_sequenceContext differentiates from other interfaces.
	IsDeclaration_sequenceContext()
}

type Declaration_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaration_sequenceContext() *Declaration_sequenceContext {
	var p = new(Declaration_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declaration_sequence
	return p
}

func (*Declaration_sequenceContext) IsDeclaration_sequenceContext() {}

func NewDeclaration_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declaration_sequenceContext {
	var p = new(Declaration_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declaration_sequence

	return p
}

func (s *Declaration_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Declaration_sequenceContext) Declaration() IDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *Declaration_sequenceContext) Declaration_sequence() IDeclaration_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaration_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaration_sequenceContext)
}

func (s *Declaration_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declaration_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declaration_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclaration_sequence(s)
	}
}

func (s *Declaration_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclaration_sequence(s)
	}
}

func (s *Declaration_sequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitDeclaration_sequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Declaration_sequence() (localctx IDeclaration_sequenceContext) {
	return p.declaration_sequence(0)
}

func (p *PandaParser) declaration_sequence(_p int) (localctx IDeclaration_sequenceContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewDeclaration_sequenceContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IDeclaration_sequenceContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 82
	p.EnterRecursionRule(localctx, 82, PandaParserRULE_declaration_sequence, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(638)
		p.Declaration()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewDeclaration_sequenceContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_declaration_sequence)
			p.SetState(640)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(641)
				p.Declaration()
			}

		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
	}

	return localctx
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declaration
	return p
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) Block_declaration() IBlock_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlock_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlock_declarationContext)
}

func (s *DeclarationContext) Function_definition() IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *DeclarationContext) Enum_definition() IEnum_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_definitionContext)
}

func (s *DeclarationContext) Class_definition() IClass_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_definitionContext)
}

func (s *DeclarationContext) Empty_declaration() IEmpty_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_declarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, PandaParserRULE_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(647)
			p.Block_declaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(648)
			p.Function_definition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(649)
			p.Enum_definition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(650)
			p.Class_definition()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(651)
			p.Empty_declaration()
		}

	}

	return localctx
}

// IBlock_declarationContext is an interface to support dynamic dispatch.
type IBlock_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlock_declarationContext differentiates from other interfaces.
	IsBlock_declarationContext()
}

type Block_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_declarationContext() *Block_declarationContext {
	var p = new(Block_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_block_declaration
	return p
}

func (*Block_declarationContext) IsBlock_declarationContext() {}

func NewBlock_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_declarationContext {
	var p = new(Block_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_block_declaration

	return p
}

func (s *Block_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_declarationContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Block_declarationContext) Init_declarator_list() IInit_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declarator_listContext)
}

func (s *Block_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBlock_declaration(s)
	}
}

func (s *Block_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBlock_declaration(s)
	}
}

func (s *Block_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitBlock_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Block_declaration() (localctx IBlock_declarationContext) {
	localctx = NewBlock_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, PandaParserRULE_block_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(655)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(654)
			p.Decl_specifier_sequence()
		}

	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserOperator || _la == PandaParserLeftParen || _la == PandaParserAnd || _la == PandaParserEllipsis || _la == PandaParserIdentifier {
		{
			p.SetState(657)
			p.init_declarator_list(0)
		}

	}
	{
		p.SetState(660)
		p.Match(PandaParserSemi)
	}

	return localctx
}

// IEmpty_declarationContext is an interface to support dynamic dispatch.
type IEmpty_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmpty_declarationContext differentiates from other interfaces.
	IsEmpty_declarationContext()
}

type Empty_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_declarationContext() *Empty_declarationContext {
	var p = new(Empty_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_empty_declaration
	return p
}

func (*Empty_declarationContext) IsEmpty_declarationContext() {}

func NewEmpty_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_declarationContext {
	var p = new(Empty_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_empty_declaration

	return p
}

func (s *Empty_declarationContext) GetParser() antlr.Parser { return s.parser }
func (s *Empty_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEmpty_declaration(s)
	}
}

func (s *Empty_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEmpty_declaration(s)
	}
}

func (s *Empty_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitEmpty_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Empty_declaration() (localctx IEmpty_declarationContext) {
	localctx = NewEmpty_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, PandaParserRULE_empty_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Match(PandaParserSemi)
	}

	return localctx
}

// IDecl_specifierContext is an interface to support dynamic dispatch.
type IDecl_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecl_specifierContext differentiates from other interfaces.
	IsDecl_specifierContext()
}

type Decl_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecl_specifierContext() *Decl_specifierContext {
	var p = new(Decl_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_decl_specifier
	return p
}

func (*Decl_specifierContext) IsDecl_specifierContext() {}

func NewDecl_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Decl_specifierContext {
	var p = new(Decl_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_decl_specifier

	return p
}

func (s *Decl_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Decl_specifierContext) Type_specifier() IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Decl_specifierContext) Modifier_specifier_sequence() IModifier_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifier_specifier_sequenceContext)
}

func (s *Decl_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Decl_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Decl_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDecl_specifier(s)
	}
}

func (s *Decl_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDecl_specifier(s)
	}
}

func (s *Decl_specifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitDecl_specifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Decl_specifier() (localctx IDecl_specifierContext) {
	localctx = NewDecl_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, PandaParserRULE_decl_specifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-9)&-(0x1f+1)) == 0 && ((1<<uint((_la-9)))&((1<<(PandaParserConst-9))|(1<<(PandaParserPrivate-9))|(1<<(PandaParserProtected-9))|(1<<(PandaParserPublic-9))|(1<<(PandaParserStatic-9)))) != 0 {
		{
			p.SetState(664)
			p.modifier_specifier_sequence(0)
		}

	}
	{
		p.SetState(667)
		p.Type_specifier()
	}

	return localctx
}

// IDecl_specifier_sequenceContext is an interface to support dynamic dispatch.
type IDecl_specifier_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecl_specifier_sequenceContext differentiates from other interfaces.
	IsDecl_specifier_sequenceContext()
}

type Decl_specifier_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecl_specifier_sequenceContext() *Decl_specifier_sequenceContext {
	var p = new(Decl_specifier_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_decl_specifier_sequence
	return p
}

func (*Decl_specifier_sequenceContext) IsDecl_specifier_sequenceContext() {}

func NewDecl_specifier_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Decl_specifier_sequenceContext {
	var p = new(Decl_specifier_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_decl_specifier_sequence

	return p
}

func (s *Decl_specifier_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Decl_specifier_sequenceContext) Decl_specifier() IDecl_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifierContext)
}

func (s *Decl_specifier_sequenceContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Decl_specifier_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Decl_specifier_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Decl_specifier_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDecl_specifier_sequence(s)
	}
}

func (s *Decl_specifier_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDecl_specifier_sequence(s)
	}
}

func (s *Decl_specifier_sequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitDecl_specifier_sequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Decl_specifier_sequence() (localctx IDecl_specifier_sequenceContext) {
	localctx = NewDecl_specifier_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, PandaParserRULE_decl_specifier_sequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(673)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(669)
			p.Decl_specifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(670)
			p.Decl_specifier()
		}
		{
			p.SetState(671)
			p.Decl_specifier_sequence()
		}

	}

	return localctx
}

// IType_specifier_sequenceContext is an interface to support dynamic dispatch.
type IType_specifier_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specifier_sequenceContext differentiates from other interfaces.
	IsType_specifier_sequenceContext()
}

type Type_specifier_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specifier_sequenceContext() *Type_specifier_sequenceContext {
	var p = new(Type_specifier_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_specifier_sequence
	return p
}

func (*Type_specifier_sequenceContext) IsType_specifier_sequenceContext() {}

func NewType_specifier_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specifier_sequenceContext {
	var p = new(Type_specifier_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_specifier_sequence

	return p
}

func (s *Type_specifier_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specifier_sequenceContext) Type_specifier() IType_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifierContext)
}

func (s *Type_specifier_sequenceContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *Type_specifier_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specifier_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_specifier_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_specifier_sequence(s)
	}
}

func (s *Type_specifier_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_specifier_sequence(s)
	}
}

func (s *Type_specifier_sequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitType_specifier_sequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Type_specifier_sequence() (localctx IType_specifier_sequenceContext) {
	localctx = NewType_specifier_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, PandaParserRULE_type_specifier_sequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(675)
			p.Type_specifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(676)
			p.Type_specifier()
		}
		{
			p.SetState(677)
			p.Type_specifier_sequence()
		}

	}

	return localctx
}

// IType_specifierContext is an interface to support dynamic dispatch.
type IType_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specifierContext differentiates from other interfaces.
	IsType_specifierContext()
}

type Type_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specifierContext() *Type_specifierContext {
	var p = new(Type_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_specifier
	return p
}

func (*Type_specifierContext) IsType_specifierContext() {}

func NewType_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specifierContext {
	var p = new(Type_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_specifier

	return p
}

func (s *Type_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specifierContext) Type_name() IType_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_nameContext)
}

func (s *Type_specifierContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Type_specifierContext) Bool() antlr.TerminalNode {
	return s.GetToken(PandaParserBool, 0)
}

func (s *Type_specifierContext) Int8() antlr.TerminalNode {
	return s.GetToken(PandaParserInt8, 0)
}

func (s *Type_specifierContext) Int16() antlr.TerminalNode {
	return s.GetToken(PandaParserInt16, 0)
}

func (s *Type_specifierContext) Int32() antlr.TerminalNode {
	return s.GetToken(PandaParserInt32, 0)
}

func (s *Type_specifierContext) Int64() antlr.TerminalNode {
	return s.GetToken(PandaParserInt64, 0)
}

func (s *Type_specifierContext) Uint8() antlr.TerminalNode {
	return s.GetToken(PandaParserUint8, 0)
}

func (s *Type_specifierContext) Uint16() antlr.TerminalNode {
	return s.GetToken(PandaParserUint16, 0)
}

func (s *Type_specifierContext) Uint32() antlr.TerminalNode {
	return s.GetToken(PandaParserUint32, 0)
}

func (s *Type_specifierContext) Uint64() antlr.TerminalNode {
	return s.GetToken(PandaParserUint64, 0)
}

func (s *Type_specifierContext) Int() antlr.TerminalNode {
	return s.GetToken(PandaParserInt, 0)
}

func (s *Type_specifierContext) Uint() antlr.TerminalNode {
	return s.GetToken(PandaParserUint, 0)
}

func (s *Type_specifierContext) Short() antlr.TerminalNode {
	return s.GetToken(PandaParserShort, 0)
}

func (s *Type_specifierContext) Ushort() antlr.TerminalNode {
	return s.GetToken(PandaParserUshort, 0)
}

func (s *Type_specifierContext) Long() antlr.TerminalNode {
	return s.GetToken(PandaParserLong, 0)
}

func (s *Type_specifierContext) Ulong() antlr.TerminalNode {
	return s.GetToken(PandaParserUlong, 0)
}

func (s *Type_specifierContext) Float32() antlr.TerminalNode {
	return s.GetToken(PandaParserFloat32, 0)
}

func (s *Type_specifierContext) Float64() antlr.TerminalNode {
	return s.GetToken(PandaParserFloat64, 0)
}

func (s *Type_specifierContext) Float() antlr.TerminalNode {
	return s.GetToken(PandaParserFloat, 0)
}

func (s *Type_specifierContext) Double() antlr.TerminalNode {
	return s.GetToken(PandaParserDouble, 0)
}

func (s *Type_specifierContext) Void() antlr.TerminalNode {
	return s.GetToken(PandaParserVoid, 0)
}

func (s *Type_specifierContext) Var() antlr.TerminalNode {
	return s.GetToken(PandaParserVar, 0)
}

func (s *Type_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_specifier(s)
	}
}

func (s *Type_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_specifier(s)
	}
}

func (s *Type_specifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitType_specifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Type_specifier() (localctx IType_specifierContext) {
	localctx = NewType_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, PandaParserRULE_type_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(706)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(682)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(681)
				p.nested_name_specifier(0)
			}

		}
		{
			p.SetState(684)
			p.Type_name()
		}

	case PandaParserBool:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(685)
			p.Match(PandaParserBool)
		}

	case PandaParserInt8:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(686)
			p.Match(PandaParserInt8)
		}

	case PandaParserInt16:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(687)
			p.Match(PandaParserInt16)
		}

	case PandaParserInt32:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(688)
			p.Match(PandaParserInt32)
		}

	case PandaParserInt64:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(689)
			p.Match(PandaParserInt64)
		}

	case PandaParserUint8:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(690)
			p.Match(PandaParserUint8)
		}

	case PandaParserUint16:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(691)
			p.Match(PandaParserUint16)
		}

	case PandaParserUint32:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(692)
			p.Match(PandaParserUint32)
		}

	case PandaParserUint64:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(693)
			p.Match(PandaParserUint64)
		}

	case PandaParserInt:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(694)
			p.Match(PandaParserInt)
		}

	case PandaParserUint:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(695)
			p.Match(PandaParserUint)
		}

	case PandaParserShort:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(696)
			p.Match(PandaParserShort)
		}

	case PandaParserUshort:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(697)
			p.Match(PandaParserUshort)
		}

	case PandaParserLong:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(698)
			p.Match(PandaParserLong)
		}

	case PandaParserUlong:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(699)
			p.Match(PandaParserUlong)
		}

	case PandaParserFloat32:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(700)
			p.Match(PandaParserFloat32)
		}

	case PandaParserFloat64:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(701)
			p.Match(PandaParserFloat64)
		}

	case PandaParserFloat:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(702)
			p.Match(PandaParserFloat)
		}

	case PandaParserDouble:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(703)
			p.Match(PandaParserDouble)
		}

	case PandaParserVoid:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(704)
			p.Match(PandaParserVoid)
		}

	case PandaParserVar:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(705)
			p.Match(PandaParserVar)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_nameContext is an interface to support dynamic dispatch.
type IType_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_nameContext differentiates from other interfaces.
	IsType_nameContext()
}

type Type_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_nameContext() *Type_nameContext {
	var p = new(Type_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_name
	return p
}

func (*Type_nameContext) IsType_nameContext() {}

func NewType_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_nameContext {
	var p = new(Type_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_name

	return p
}

func (s *Type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_nameContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Type_nameContext) Enum_name() IEnum_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_nameContext)
}

func (s *Type_nameContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_name(s)
	}
}

func (s *Type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_name(s)
	}
}

func (s *Type_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitType_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Type_name() (localctx IType_nameContext) {
	localctx = NewType_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, PandaParserRULE_type_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(708)
			p.Class_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(709)
			p.Enum_name()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(710)
			p.Template_id()
		}

	}

	return localctx
}

// IEnum_nameContext is an interface to support dynamic dispatch.
type IEnum_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_nameContext differentiates from other interfaces.
	IsEnum_nameContext()
}

type Enum_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_nameContext() *Enum_nameContext {
	var p = new(Enum_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enum_name
	return p
}

func (*Enum_nameContext) IsEnum_nameContext() {}

func NewEnum_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_nameContext {
	var p = new(Enum_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enum_name

	return p
}

func (s *Enum_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_nameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Enum_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnum_name(s)
	}
}

func (s *Enum_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnum_name(s)
	}
}

func (s *Enum_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitEnum_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Enum_name() (localctx IEnum_nameContext) {
	localctx = NewEnum_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, PandaParserRULE_enum_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		p.Match(PandaParserIdentifier)
	}

	return localctx
}

// IEnum_definitionContext is an interface to support dynamic dispatch.
type IEnum_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_definitionContext differentiates from other interfaces.
	IsEnum_definitionContext()
}

type Enum_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_definitionContext() *Enum_definitionContext {
	var p = new(Enum_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enum_definition
	return p
}

func (*Enum_definitionContext) IsEnum_definitionContext() {}

func NewEnum_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_definitionContext {
	var p = new(Enum_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enum_definition

	return p
}

func (s *Enum_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_definitionContext) Enum_head() IEnum_headContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_headContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_headContext)
}

func (s *Enum_definitionContext) Enumerator_list() IEnumerator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerator_listContext)
}

func (s *Enum_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnum_definition(s)
	}
}

func (s *Enum_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnum_definition(s)
	}
}

func (s *Enum_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitEnum_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Enum_definition() (localctx IEnum_definitionContext) {
	localctx = NewEnum_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, PandaParserRULE_enum_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(715)
			p.Enum_head()
		}
		{
			p.SetState(716)
			p.Match(PandaParserLeftBrace)
		}
		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserIdentifier {
			{
				p.SetState(717)
				p.enumerator_list(0)
			}

		}
		{
			p.SetState(720)
			p.Match(PandaParserRightBrace)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(722)
			p.Enum_head()
		}
		{
			p.SetState(723)
			p.Match(PandaParserLeftBrace)
		}
		{
			p.SetState(724)
			p.enumerator_list(0)
		}
		{
			p.SetState(725)
			p.Match(PandaParserComma)
		}
		{
			p.SetState(726)
			p.Match(PandaParserRightBrace)
		}

	}

	return localctx
}

// IEnum_headContext is an interface to support dynamic dispatch.
type IEnum_headContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_headContext differentiates from other interfaces.
	IsEnum_headContext()
}

type Enum_headContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_headContext() *Enum_headContext {
	var p = new(Enum_headContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enum_head
	return p
}

func (*Enum_headContext) IsEnum_headContext() {}

func NewEnum_headContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_headContext {
	var p = new(Enum_headContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enum_head

	return p
}

func (s *Enum_headContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_headContext) Enum() antlr.TerminalNode {
	return s.GetToken(PandaParserEnum, 0)
}

func (s *Enum_headContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Enum_headContext) Enum_base() IEnum_baseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_baseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_baseContext)
}

func (s *Enum_headContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_headContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_headContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnum_head(s)
	}
}

func (s *Enum_headContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnum_head(s)
	}
}

func (s *Enum_headContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitEnum_head(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Enum_head() (localctx IEnum_headContext) {
	localctx = NewEnum_headContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, PandaParserRULE_enum_head)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.Match(PandaParserEnum)
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserIdentifier {
		{
			p.SetState(731)
			p.Match(PandaParserIdentifier)
		}

	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserColon {
		{
			p.SetState(734)
			p.Enum_base()
		}

	}

	return localctx
}

// IEnum_baseContext is an interface to support dynamic dispatch.
type IEnum_baseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_baseContext differentiates from other interfaces.
	IsEnum_baseContext()
}

type Enum_baseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_baseContext() *Enum_baseContext {
	var p = new(Enum_baseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enum_base
	return p
}

func (*Enum_baseContext) IsEnum_baseContext() {}

func NewEnum_baseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_baseContext {
	var p = new(Enum_baseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enum_base

	return p
}

func (s *Enum_baseContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_baseContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *Enum_baseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_baseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_baseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnum_base(s)
	}
}

func (s *Enum_baseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnum_base(s)
	}
}

func (s *Enum_baseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitEnum_base(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Enum_base() (localctx IEnum_baseContext) {
	localctx = NewEnum_baseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, PandaParserRULE_enum_base)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		p.Match(PandaParserColon)
	}
	{
		p.SetState(738)
		p.Type_specifier_sequence()
	}

	return localctx
}

// IEnumerator_listContext is an interface to support dynamic dispatch.
type IEnumerator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerator_listContext differentiates from other interfaces.
	IsEnumerator_listContext()
}

type Enumerator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerator_listContext() *Enumerator_listContext {
	var p = new(Enumerator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enumerator_list
	return p
}

func (*Enumerator_listContext) IsEnumerator_listContext() {}

func NewEnumerator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumerator_listContext {
	var p = new(Enumerator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enumerator_list

	return p
}

func (s *Enumerator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumerator_listContext) Enumerator_definition() IEnumerator_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerator_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerator_definitionContext)
}

func (s *Enumerator_listContext) Enumerator_list() IEnumerator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumerator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumerator_listContext)
}

func (s *Enumerator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumerator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enumerator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnumerator_list(s)
	}
}

func (s *Enumerator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnumerator_list(s)
	}
}

func (s *Enumerator_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitEnumerator_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Enumerator_list() (localctx IEnumerator_listContext) {
	return p.enumerator_list(0)
}

func (p *PandaParser) enumerator_list(_p int) (localctx IEnumerator_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewEnumerator_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEnumerator_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 108
	p.EnterRecursionRule(localctx, 108, PandaParserRULE_enumerator_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.Enumerator_definition()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewEnumerator_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_enumerator_list)
			p.SetState(743)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(744)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(745)
				p.Enumerator_definition()
			}

		}
		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumerator_definitionContext is an interface to support dynamic dispatch.
type IEnumerator_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumerator_definitionContext differentiates from other interfaces.
	IsEnumerator_definitionContext()
}

type Enumerator_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumerator_definitionContext() *Enumerator_definitionContext {
	var p = new(Enumerator_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enumerator_definition
	return p
}

func (*Enumerator_definitionContext) IsEnumerator_definitionContext() {}

func NewEnumerator_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enumerator_definitionContext {
	var p = new(Enumerator_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enumerator_definition

	return p
}

func (s *Enumerator_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Enumerator_definitionContext) Enumerator() IEnumeratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *Enumerator_definitionContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Enumerator_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enumerator_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enumerator_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnumerator_definition(s)
	}
}

func (s *Enumerator_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnumerator_definition(s)
	}
}

func (s *Enumerator_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitEnumerator_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Enumerator_definition() (localctx IEnumerator_definitionContext) {
	localctx = NewEnumerator_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, PandaParserRULE_enumerator_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.Enumerator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Enumerator()
		}
		{
			p.SetState(753)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(754)
			p.Constant_expression()
		}

	}

	return localctx
}

// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_enumerator
	return p
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterEnumerator(s)
	}
}

func (s *EnumeratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitEnumerator(s)
	}
}

func (s *EnumeratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitEnumerator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Enumerator() (localctx IEnumeratorContext) {
	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, PandaParserRULE_enumerator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.Match(PandaParserIdentifier)
	}

	return localctx
}

// INamespace_nameContext is an interface to support dynamic dispatch.
type INamespace_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespace_nameContext differentiates from other interfaces.
	IsNamespace_nameContext()
}

type Namespace_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespace_nameContext() *Namespace_nameContext {
	var p = new(Namespace_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_namespace_name
	return p
}

func (*Namespace_nameContext) IsNamespace_nameContext() {}

func NewNamespace_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Namespace_nameContext {
	var p = new(Namespace_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_namespace_name

	return p
}

func (s *Namespace_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Namespace_nameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Namespace_nameContext) Namespace_name() INamespace_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Namespace_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Namespace_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Namespace_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNamespace_name(s)
	}
}

func (s *Namespace_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNamespace_name(s)
	}
}

func (s *Namespace_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitNamespace_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Namespace_name() (localctx INamespace_nameContext) {
	return p.namespace_name(0)
}

func (p *PandaParser) namespace_name(_p int) (localctx INamespace_nameContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewNamespace_nameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INamespace_nameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 114
	p.EnterRecursionRule(localctx, 114, PandaParserRULE_namespace_name, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.Match(PandaParserIdentifier)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewNamespace_nameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_namespace_name)
			p.SetState(763)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(764)
				p.Match(PandaParserDot)
			}
			{
				p.SetState(765)
				p.Match(PandaParserIdentifier)
			}

		}
		p.SetState(770)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
	}

	return localctx
}

// INamespace_definitionContext is an interface to support dynamic dispatch.
type INamespace_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespace_definitionContext differentiates from other interfaces.
	IsNamespace_definitionContext()
}

type Namespace_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespace_definitionContext() *Namespace_definitionContext {
	var p = new(Namespace_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_namespace_definition
	return p
}

func (*Namespace_definitionContext) IsNamespace_definitionContext() {}

func NewNamespace_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Namespace_definitionContext {
	var p = new(Namespace_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_namespace_definition

	return p
}

func (s *Namespace_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Namespace_definitionContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PandaParserNamespace, 0)
}

func (s *Namespace_definitionContext) Namespace_name() INamespace_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Namespace_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Namespace_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Namespace_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNamespace_definition(s)
	}
}

func (s *Namespace_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNamespace_definition(s)
	}
}

func (s *Namespace_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitNamespace_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Namespace_definition() (localctx INamespace_definitionContext) {
	localctx = NewNamespace_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, PandaParserRULE_namespace_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.Match(PandaParserNamespace)
	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserIdentifier {
		{
			p.SetState(772)
			p.namespace_name(0)
		}

	}
	{
		p.SetState(775)
		p.Match(PandaParserSemi)
	}

	return localctx
}

// IInclude_definitionContext is an interface to support dynamic dispatch.
type IInclude_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInclude_definitionContext differentiates from other interfaces.
	IsInclude_definitionContext()
}

type Include_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclude_definitionContext() *Include_definitionContext {
	var p = new(Include_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_include_definition
	return p
}

func (*Include_definitionContext) IsInclude_definitionContext() {}

func NewInclude_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Include_definitionContext {
	var p = new(Include_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_include_definition

	return p
}

func (s *Include_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Include_definitionContext) Include() antlr.TerminalNode {
	return s.GetToken(PandaParserInclude, 0)
}

func (s *Include_definitionContext) Namespace_name() INamespace_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespace_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespace_nameContext)
}

func (s *Include_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Include_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Include_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInclude_definition(s)
	}
}

func (s *Include_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInclude_definition(s)
	}
}

func (s *Include_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitInclude_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Include_definition() (localctx IInclude_definitionContext) {
	localctx = NewInclude_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, PandaParserRULE_include_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Match(PandaParserInclude)
	}
	{
		p.SetState(778)
		p.namespace_name(0)
	}
	{
		p.SetState(779)
		p.Match(PandaParserSemi)
	}

	return localctx
}

// IInclude_definition_sequenceContext is an interface to support dynamic dispatch.
type IInclude_definition_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInclude_definition_sequenceContext differentiates from other interfaces.
	IsInclude_definition_sequenceContext()
}

type Include_definition_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclude_definition_sequenceContext() *Include_definition_sequenceContext {
	var p = new(Include_definition_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_include_definition_sequence
	return p
}

func (*Include_definition_sequenceContext) IsInclude_definition_sequenceContext() {}

func NewInclude_definition_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Include_definition_sequenceContext {
	var p = new(Include_definition_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_include_definition_sequence

	return p
}

func (s *Include_definition_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Include_definition_sequenceContext) Include_definition() IInclude_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclude_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclude_definitionContext)
}

func (s *Include_definition_sequenceContext) Include_definition_sequence() IInclude_definition_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInclude_definition_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInclude_definition_sequenceContext)
}

func (s *Include_definition_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Include_definition_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Include_definition_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInclude_definition_sequence(s)
	}
}

func (s *Include_definition_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInclude_definition_sequence(s)
	}
}

func (s *Include_definition_sequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitInclude_definition_sequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Include_definition_sequence() (localctx IInclude_definition_sequenceContext) {
	return p.include_definition_sequence(0)
}

func (p *PandaParser) include_definition_sequence(_p int) (localctx IInclude_definition_sequenceContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInclude_definition_sequenceContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInclude_definition_sequenceContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 120
	p.EnterRecursionRule(localctx, 120, PandaParserRULE_include_definition_sequence, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(782)
		p.Include_definition()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInclude_definition_sequenceContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_include_definition_sequence)
			p.SetState(784)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(785)
				p.Include_definition()
			}

		}
		p.SetState(790)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
	}

	return localctx
}

// IInit_declarator_listContext is an interface to support dynamic dispatch.
type IInit_declarator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declarator_listContext differentiates from other interfaces.
	IsInit_declarator_listContext()
}

type Init_declarator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declarator_listContext() *Init_declarator_listContext {
	var p = new(Init_declarator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_init_declarator_list
	return p
}

func (*Init_declarator_listContext) IsInit_declarator_listContext() {}

func NewInit_declarator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declarator_listContext {
	var p = new(Init_declarator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_init_declarator_list

	return p
}

func (s *Init_declarator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declarator_listContext) Init_declarator() IInit_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declaratorContext)
}

func (s *Init_declarator_listContext) Init_declarator_list() IInit_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declarator_listContext)
}

func (s *Init_declarator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declarator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_declarator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInit_declarator_list(s)
	}
}

func (s *Init_declarator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInit_declarator_list(s)
	}
}

func (s *Init_declarator_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitInit_declarator_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Init_declarator_list() (localctx IInit_declarator_listContext) {
	return p.init_declarator_list(0)
}

func (p *PandaParser) init_declarator_list(_p int) (localctx IInit_declarator_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInit_declarator_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInit_declarator_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, PandaParserRULE_init_declarator_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Init_declarator()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInit_declarator_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_init_declarator_list)
			p.SetState(794)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(795)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(796)
				p.Init_declarator()
			}

		}
		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
	}

	return localctx
}

// IInit_declaratorContext is an interface to support dynamic dispatch.
type IInit_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declaratorContext differentiates from other interfaces.
	IsInit_declaratorContext()
}

type Init_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declaratorContext() *Init_declaratorContext {
	var p = new(Init_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_init_declarator
	return p
}

func (*Init_declaratorContext) IsInit_declaratorContext() {}

func NewInit_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declaratorContext {
	var p = new(Init_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_init_declarator

	return p
}

func (s *Init_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Init_declaratorContext) Initializer() IInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *Init_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInit_declarator(s)
	}
}

func (s *Init_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInit_declarator(s)
	}
}

func (s *Init_declaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitInit_declarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Init_declarator() (localctx IInit_declaratorContext) {
	localctx = NewInit_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, PandaParserRULE_init_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.Declarator()
	}
	p.SetState(804)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(803)
			p.Initializer()
		}

	}

	return localctx
}

// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declarator
	return p
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) Ptr_declarator() IPtr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPtr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPtr_declaratorContext)
}

func (s *DeclaratorContext) Noptr_declarator() INoptr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INoptr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INoptr_declaratorContext)
}

func (s *DeclaratorContext) Parameters_and_qualifiers() IParameters_and_qualifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameters_and_qualifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameters_and_qualifiersContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclarator(s)
	}
}

func (s *DeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclarator(s)
	}
}

func (s *DeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Declarator() (localctx IDeclaratorContext) {
	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, PandaParserRULE_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(806)
			p.Ptr_declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(807)
			p.noptr_declarator(0)
		}
		{
			p.SetState(808)
			p.Parameters_and_qualifiers()
		}

	}

	return localctx
}

// IPtr_declaratorContext is an interface to support dynamic dispatch.
type IPtr_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPtr_declaratorContext differentiates from other interfaces.
	IsPtr_declaratorContext()
}

type Ptr_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPtr_declaratorContext() *Ptr_declaratorContext {
	var p = new(Ptr_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_ptr_declarator
	return p
}

func (*Ptr_declaratorContext) IsPtr_declaratorContext() {}

func NewPtr_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ptr_declaratorContext {
	var p = new(Ptr_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_ptr_declarator

	return p
}

func (s *Ptr_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Ptr_declaratorContext) Noptr_declarator() INoptr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INoptr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INoptr_declaratorContext)
}

func (s *Ptr_declaratorContext) Ref_operator() IRef_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRef_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRef_operatorContext)
}

func (s *Ptr_declaratorContext) Ptr_declarator() IPtr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPtr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPtr_declaratorContext)
}

func (s *Ptr_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ptr_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ptr_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterPtr_declarator(s)
	}
}

func (s *Ptr_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitPtr_declarator(s)
	}
}

func (s *Ptr_declaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitPtr_declarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Ptr_declarator() (localctx IPtr_declaratorContext) {
	localctx = NewPtr_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, PandaParserRULE_ptr_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(816)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserOperator, PandaParserLeftParen, PandaParserEllipsis, PandaParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(812)
			p.noptr_declarator(0)
		}

	case PandaParserAnd:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(813)
			p.Ref_operator()
		}
		{
			p.SetState(814)
			p.Ptr_declarator()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INoptr_declaratorContext is an interface to support dynamic dispatch.
type INoptr_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNoptr_declaratorContext differentiates from other interfaces.
	IsNoptr_declaratorContext()
}

type Noptr_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoptr_declaratorContext() *Noptr_declaratorContext {
	var p = new(Noptr_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_noptr_declarator
	return p
}

func (*Noptr_declaratorContext) IsNoptr_declaratorContext() {}

func NewNoptr_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Noptr_declaratorContext {
	var p = new(Noptr_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_noptr_declarator

	return p
}

func (s *Noptr_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Noptr_declaratorContext) Declarator_id() IDeclarator_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclarator_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclarator_idContext)
}

func (s *Noptr_declaratorContext) Ptr_declarator() IPtr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPtr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPtr_declaratorContext)
}

func (s *Noptr_declaratorContext) Noptr_declarator() INoptr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INoptr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INoptr_declaratorContext)
}

func (s *Noptr_declaratorContext) Parameters_and_qualifiers() IParameters_and_qualifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameters_and_qualifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameters_and_qualifiersContext)
}

func (s *Noptr_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Noptr_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Noptr_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterNoptr_declarator(s)
	}
}

func (s *Noptr_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitNoptr_declarator(s)
	}
}

func (s *Noptr_declaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitNoptr_declarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Noptr_declarator() (localctx INoptr_declaratorContext) {
	return p.noptr_declarator(0)
}

func (p *PandaParser) noptr_declarator(_p int) (localctx INoptr_declaratorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewNoptr_declaratorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INoptr_declaratorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, PandaParserRULE_noptr_declarator, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(824)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserOperator, PandaParserEllipsis, PandaParserIdentifier:
		{
			p.SetState(819)
			p.Declarator_id()
		}

	case PandaParserLeftParen:
		{
			p.SetState(820)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(821)
			p.Ptr_declarator()
		}
		{
			p.SetState(822)
			p.Match(PandaParserRightParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewNoptr_declaratorContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_noptr_declarator)
			p.SetState(826)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(827)
				p.Parameters_and_qualifiers()
			}

		}
		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())
	}

	return localctx
}

// IParameters_and_qualifiersContext is an interface to support dynamic dispatch.
type IParameters_and_qualifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameters_and_qualifiersContext differentiates from other interfaces.
	IsParameters_and_qualifiersContext()
}

type Parameters_and_qualifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameters_and_qualifiersContext() *Parameters_and_qualifiersContext {
	var p = new(Parameters_and_qualifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_parameters_and_qualifiers
	return p
}

func (*Parameters_and_qualifiersContext) IsParameters_and_qualifiersContext() {}

func NewParameters_and_qualifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameters_and_qualifiersContext {
	var p = new(Parameters_and_qualifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_parameters_and_qualifiers

	return p
}

func (s *Parameters_and_qualifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameters_and_qualifiersContext) Parameter_declaration_clause() IParameter_declaration_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_clauseContext)
}

func (s *Parameters_and_qualifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameters_and_qualifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameters_and_qualifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterParameters_and_qualifiers(s)
	}
}

func (s *Parameters_and_qualifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitParameters_and_qualifiers(s)
	}
}

func (s *Parameters_and_qualifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitParameters_and_qualifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Parameters_and_qualifiers() (localctx IParameters_and_qualifiersContext) {
	localctx = NewParameters_and_qualifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, PandaParserRULE_parameters_and_qualifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.Match(PandaParserLeftParen)
	}
	{
		p.SetState(834)
		p.Parameter_declaration_clause()
	}
	{
		p.SetState(835)
		p.Match(PandaParserRightParen)
	}

	return localctx
}

// IRef_operatorContext is an interface to support dynamic dispatch.
type IRef_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRef_operatorContext differentiates from other interfaces.
	IsRef_operatorContext()
}

type Ref_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRef_operatorContext() *Ref_operatorContext {
	var p = new(Ref_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_ref_operator
	return p
}

func (*Ref_operatorContext) IsRef_operatorContext() {}

func NewRef_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ref_operatorContext {
	var p = new(Ref_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_ref_operator

	return p
}

func (s *Ref_operatorContext) GetParser() antlr.Parser { return s.parser }
func (s *Ref_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ref_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ref_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterRef_operator(s)
	}
}

func (s *Ref_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitRef_operator(s)
	}
}

func (s *Ref_operatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitRef_operator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Ref_operator() (localctx IRef_operatorContext) {
	localctx = NewRef_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, PandaParserRULE_ref_operator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(837)
		p.Match(PandaParserAnd)
	}

	return localctx
}

// IDeclarator_idContext is an interface to support dynamic dispatch.
type IDeclarator_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclarator_idContext differentiates from other interfaces.
	IsDeclarator_idContext()
}

type Declarator_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarator_idContext() *Declarator_idContext {
	var p = new(Declarator_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_declarator_id
	return p
}

func (*Declarator_idContext) IsDeclarator_idContext() {}

func NewDeclarator_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declarator_idContext {
	var p = new(Declarator_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_declarator_id

	return p
}

func (s *Declarator_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Declarator_idContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Declarator_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declarator_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declarator_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterDeclarator_id(s)
	}
}

func (s *Declarator_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitDeclarator_id(s)
	}
}

func (s *Declarator_idContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitDeclarator_id(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Declarator_id() (localctx IDeclarator_idContext) {
	localctx = NewDeclarator_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, PandaParserRULE_declarator_id)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserEllipsis {
		{
			p.SetState(839)
			p.Match(PandaParserEllipsis)
		}

	}
	{
		p.SetState(842)
		p.Id_expression()
	}

	return localctx
}

// IType_idContext is an interface to support dynamic dispatch.
type IType_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_idContext differentiates from other interfaces.
	IsType_idContext()
}

type Type_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_idContext() *Type_idContext {
	var p = new(Type_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_id
	return p
}

func (*Type_idContext) IsType_idContext() {}

func NewType_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_idContext {
	var p = new(Type_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_id

	return p
}

func (s *Type_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_idContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *Type_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_id(s)
	}
}

func (s *Type_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_id(s)
	}
}

func (s *Type_idContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitType_id(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Type_id() (localctx IType_idContext) {
	localctx = NewType_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, PandaParserRULE_type_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(844)
		p.Type_specifier_sequence()
	}

	return localctx
}

// IParameter_declaration_clauseContext is an interface to support dynamic dispatch.
type IParameter_declaration_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declaration_clauseContext differentiates from other interfaces.
	IsParameter_declaration_clauseContext()
}

type Parameter_declaration_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declaration_clauseContext() *Parameter_declaration_clauseContext {
	var p = new(Parameter_declaration_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_parameter_declaration_clause
	return p
}

func (*Parameter_declaration_clauseContext) IsParameter_declaration_clauseContext() {}

func NewParameter_declaration_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declaration_clauseContext {
	var p = new(Parameter_declaration_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_parameter_declaration_clause

	return p
}

func (s *Parameter_declaration_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declaration_clauseContext) Parameter_declaration_list() IParameter_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_listContext)
}

func (s *Parameter_declaration_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declaration_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declaration_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterParameter_declaration_clause(s)
	}
}

func (s *Parameter_declaration_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitParameter_declaration_clause(s)
	}
}

func (s *Parameter_declaration_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitParameter_declaration_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Parameter_declaration_clause() (localctx IParameter_declaration_clauseContext) {
	localctx = NewParameter_declaration_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, PandaParserRULE_parameter_declaration_clause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserConst)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PandaParserPrivate-32))|(1<<(PandaParserProtected-32))|(1<<(PandaParserPublic-32))|(1<<(PandaParserStatic-32))|(1<<(PandaParserShort-32))|(1<<(PandaParserUint-32))|(1<<(PandaParserUint8-32))|(1<<(PandaParserUint16-32))|(1<<(PandaParserUint32-32))|(1<<(PandaParserUint64-32))|(1<<(PandaParserUlong-32))|(1<<(PandaParserUshort-32))|(1<<(PandaParserVar-32))|(1<<(PandaParserVoid-32)))) != 0) || _la == PandaParserIdentifier {
			{
				p.SetState(846)
				p.parameter_declaration_list(0)
			}

		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserEllipsis {
			{
				p.SetState(849)
				p.Match(PandaParserEllipsis)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(852)
			p.parameter_declaration_list(0)
		}
		{
			p.SetState(853)
			p.Match(PandaParserComma)
		}
		{
			p.SetState(854)
			p.Match(PandaParserEllipsis)
		}

	}

	return localctx
}

// IParameter_declaration_listContext is an interface to support dynamic dispatch.
type IParameter_declaration_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declaration_listContext differentiates from other interfaces.
	IsParameter_declaration_listContext()
}

type Parameter_declaration_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declaration_listContext() *Parameter_declaration_listContext {
	var p = new(Parameter_declaration_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_parameter_declaration_list
	return p
}

func (*Parameter_declaration_listContext) IsParameter_declaration_listContext() {}

func NewParameter_declaration_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declaration_listContext {
	var p = new(Parameter_declaration_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_parameter_declaration_list

	return p
}

func (s *Parameter_declaration_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declaration_listContext) Parameter_declaration() IParameter_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declarationContext)
}

func (s *Parameter_declaration_listContext) Parameter_declaration_list() IParameter_declaration_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declaration_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declaration_listContext)
}

func (s *Parameter_declaration_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declaration_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declaration_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterParameter_declaration_list(s)
	}
}

func (s *Parameter_declaration_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitParameter_declaration_list(s)
	}
}

func (s *Parameter_declaration_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitParameter_declaration_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Parameter_declaration_list() (localctx IParameter_declaration_listContext) {
	return p.parameter_declaration_list(0)
}

func (p *PandaParser) parameter_declaration_list(_p int) (localctx IParameter_declaration_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewParameter_declaration_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IParameter_declaration_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 142
	p.EnterRecursionRule(localctx, 142, PandaParserRULE_parameter_declaration_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(859)
		p.Parameter_declaration()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewParameter_declaration_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_parameter_declaration_list)
			p.SetState(861)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(862)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(863)
				p.Parameter_declaration()
			}

		}
		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
	}

	return localctx
}

// IParameter_declarationContext is an interface to support dynamic dispatch.
type IParameter_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declarationContext differentiates from other interfaces.
	IsParameter_declarationContext()
}

type Parameter_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declarationContext() *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_parameter_declaration
	return p
}

func (*Parameter_declarationContext) IsParameter_declarationContext() {}

func NewParameter_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declarationContext {
	var p = new(Parameter_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_parameter_declaration

	return p
}

func (s *Parameter_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declarationContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Parameter_declarationContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Parameter_declarationContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *Parameter_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitParameter_declaration(s)
	}
}

func (s *Parameter_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitParameter_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Parameter_declaration() (localctx IParameter_declarationContext) {
	localctx = NewParameter_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, PandaParserRULE_parameter_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(869)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(870)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(872)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(873)
			p.Declarator()
		}
		{
			p.SetState(874)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(875)
			p.Initializer_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(877)
			p.Decl_specifier_sequence()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(878)
			p.Decl_specifier_sequence()
		}
		{
			p.SetState(879)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(880)
			p.Initializer_clause()
		}

	}

	return localctx
}

// IFunction_definitionContext is an interface to support dynamic dispatch.
type IFunction_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_definitionContext differentiates from other interfaces.
	IsFunction_definitionContext()
}

type Function_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_definitionContext() *Function_definitionContext {
	var p = new(Function_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_function_definition
	return p
}

func (*Function_definitionContext) IsFunction_definitionContext() {}

func NewFunction_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_definitionContext {
	var p = new(Function_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_function_definition

	return p
}

func (s *Function_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_definitionContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Function_definitionContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Function_definitionContext) Modifier_specifier_sequence() IModifier_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifier_specifier_sequenceContext)
}

func (s *Function_definitionContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Function_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterFunction_definition(s)
	}
}

func (s *Function_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitFunction_definition(s)
	}
}

func (s *Function_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitFunction_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Function_definition() (localctx IFunction_definitionContext) {
	localctx = NewFunction_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, PandaParserRULE_function_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(885)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(884)
			p.modifier_specifier_sequence(0)
		}

	}
	p.SetState(888)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(887)
			p.Decl_specifier_sequence()
		}

	}
	{
		p.SetState(890)
		p.Declarator()
	}
	{
		p.SetState(891)
		p.Compound_statement()
	}

	return localctx
}

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_initializer
	return p
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) Brace_or_equal_initializer() IBrace_or_equal_initializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBrace_or_equal_initializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBrace_or_equal_initializerContext)
}

func (s *InitializerContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInitializer(s)
	}
}

func (s *InitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInitializer(s)
	}
}

func (s *InitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Initializer() (localctx IInitializerContext) {
	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, PandaParserRULE_initializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(898)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserLeftBrace, PandaParserAssign:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(893)
			p.Brace_or_equal_initializer()
		}

	case PandaParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(894)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(895)
			p.Expression_list()
		}
		{
			p.SetState(896)
			p.Match(PandaParserRightParen)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBrace_or_equal_initializerContext is an interface to support dynamic dispatch.
type IBrace_or_equal_initializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBrace_or_equal_initializerContext differentiates from other interfaces.
	IsBrace_or_equal_initializerContext()
}

type Brace_or_equal_initializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBrace_or_equal_initializerContext() *Brace_or_equal_initializerContext {
	var p = new(Brace_or_equal_initializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_brace_or_equal_initializer
	return p
}

func (*Brace_or_equal_initializerContext) IsBrace_or_equal_initializerContext() {}

func NewBrace_or_equal_initializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Brace_or_equal_initializerContext {
	var p = new(Brace_or_equal_initializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_brace_or_equal_initializer

	return p
}

func (s *Brace_or_equal_initializerContext) GetParser() antlr.Parser { return s.parser }

func (s *Brace_or_equal_initializerContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *Brace_or_equal_initializerContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *Brace_or_equal_initializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Brace_or_equal_initializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Brace_or_equal_initializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBrace_or_equal_initializer(s)
	}
}

func (s *Brace_or_equal_initializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBrace_or_equal_initializer(s)
	}
}

func (s *Brace_or_equal_initializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitBrace_or_equal_initializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Brace_or_equal_initializer() (localctx IBrace_or_equal_initializerContext) {
	localctx = NewBrace_or_equal_initializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, PandaParserRULE_brace_or_equal_initializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(903)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserAssign:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(900)
			p.Match(PandaParserAssign)
		}
		{
			p.SetState(901)
			p.Initializer_clause()
		}

	case PandaParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(902)
			p.Braced_init_list()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializer_clauseContext is an interface to support dynamic dispatch.
type IInitializer_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializer_clauseContext differentiates from other interfaces.
	IsInitializer_clauseContext()
}

type Initializer_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializer_clauseContext() *Initializer_clauseContext {
	var p = new(Initializer_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_initializer_clause
	return p
}

func (*Initializer_clauseContext) IsInitializer_clauseContext() {}

func NewInitializer_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initializer_clauseContext {
	var p = new(Initializer_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_initializer_clause

	return p
}

func (s *Initializer_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Initializer_clauseContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Initializer_clauseContext) Braced_init_list() IBraced_init_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBraced_init_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBraced_init_listContext)
}

func (s *Initializer_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initializer_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initializer_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInitializer_clause(s)
	}
}

func (s *Initializer_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInitializer_clause(s)
	}
}

func (s *Initializer_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitInitializer_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Initializer_clause() (localctx IInitializer_clauseContext) {
	localctx = NewInitializer_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, PandaParserRULE_initializer_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(907)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserBool, PandaParserCast, PandaParserDouble, PandaParserFloat32, PandaParserFloat64, PandaParserFloat, PandaParserInt, PandaParserInt8, PandaParserInt16, PandaParserInt32, PandaParserInt64, PandaParserLong, PandaParserNew, PandaParserOperator, PandaParserShort, PandaParserThis, PandaParserThrow, PandaParserUint, PandaParserUint8, PandaParserUint16, PandaParserUint32, PandaParserUint64, PandaParserUlong, PandaParserUshort, PandaParserVar, PandaParserVoid, PandaParserLeftParen, PandaParserPlus, PandaParserMinus, PandaParserOr, PandaParserTilde, PandaParserNot, PandaParserPlusPlus, PandaParserMinusMinus, PandaParserIdentifier, PandaParserIntegerLiteral, PandaParserFloatLiteral, PandaParserStringLiteral, PandaParserBooleanLiteral, PandaParserPointerLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(905)
			p.Assignment_expression()
		}

	case PandaParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(906)
			p.Braced_init_list()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializer_listContext is an interface to support dynamic dispatch.
type IInitializer_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializer_listContext differentiates from other interfaces.
	IsInitializer_listContext()
}

type Initializer_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializer_listContext() *Initializer_listContext {
	var p = new(Initializer_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_initializer_list
	return p
}

func (*Initializer_listContext) IsInitializer_listContext() {}

func NewInitializer_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Initializer_listContext {
	var p = new(Initializer_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_initializer_list

	return p
}

func (s *Initializer_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Initializer_listContext) Initializer_clause() IInitializer_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_clauseContext)
}

func (s *Initializer_listContext) Initializer_list() IInitializer_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_listContext)
}

func (s *Initializer_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Initializer_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Initializer_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterInitializer_list(s)
	}
}

func (s *Initializer_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitInitializer_list(s)
	}
}

func (s *Initializer_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitInitializer_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Initializer_list() (localctx IInitializer_listContext) {
	return p.initializer_list(0)
}

func (p *PandaParser) initializer_list(_p int) (localctx IInitializer_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewInitializer_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IInitializer_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 154
	p.EnterRecursionRule(localctx, 154, PandaParserRULE_initializer_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(910)
		p.Initializer_clause()
	}
	p.SetState(912)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(911)
			p.Match(PandaParserEllipsis)
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(922)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewInitializer_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_initializer_list)
			p.SetState(914)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(915)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(916)
				p.Initializer_clause()
			}
			p.SetState(918)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(917)
					p.Match(PandaParserEllipsis)
				}

			}

		}
		p.SetState(924)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())
	}

	return localctx
}

// IBraced_init_listContext is an interface to support dynamic dispatch.
type IBraced_init_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBraced_init_listContext differentiates from other interfaces.
	IsBraced_init_listContext()
}

type Braced_init_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraced_init_listContext() *Braced_init_listContext {
	var p = new(Braced_init_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_braced_init_list
	return p
}

func (*Braced_init_listContext) IsBraced_init_listContext() {}

func NewBraced_init_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Braced_init_listContext {
	var p = new(Braced_init_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_braced_init_list

	return p
}

func (s *Braced_init_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Braced_init_listContext) Initializer_list() IInitializer_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInitializer_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInitializer_listContext)
}

func (s *Braced_init_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Braced_init_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Braced_init_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBraced_init_list(s)
	}
}

func (s *Braced_init_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBraced_init_list(s)
	}
}

func (s *Braced_init_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitBraced_init_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Braced_init_list() (localctx IBraced_init_listContext) {
	localctx = NewBraced_init_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, PandaParserRULE_braced_init_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(925)
			p.Match(PandaParserLeftBrace)
		}
		{
			p.SetState(926)
			p.initializer_list(0)
		}
		p.SetState(928)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserComma {
			{
				p.SetState(927)
				p.Match(PandaParserComma)
			}

		}
		{
			p.SetState(930)
			p.Match(PandaParserRightBrace)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(932)
			p.Match(PandaParserLeftBrace)
		}
		{
			p.SetState(933)
			p.Match(PandaParserRightBrace)
		}

	}

	return localctx
}

// IClass_definitionContext is an interface to support dynamic dispatch.
type IClass_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_definitionContext differentiates from other interfaces.
	IsClass_definitionContext()
}

type Class_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_definitionContext() *Class_definitionContext {
	var p = new(Class_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_class_definition
	return p
}

func (*Class_definitionContext) IsClass_definitionContext() {}

func NewClass_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_definitionContext {
	var p = new(Class_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_class_definition

	return p
}

func (s *Class_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_definitionContext) Class() antlr.TerminalNode {
	return s.GetToken(PandaParserClass, 0)
}

func (s *Class_definitionContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Class_definitionContext) Base_clause() IBase_clauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_clauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_clauseContext)
}

func (s *Class_definitionContext) Member_specification() IMember_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_specificationContext)
}

func (s *Class_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterClass_definition(s)
	}
}

func (s *Class_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitClass_definition(s)
	}
}

func (s *Class_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitClass_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Class_definition() (localctx IClass_definitionContext) {
	localctx = NewClass_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, PandaParserRULE_class_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(936)
		p.Match(PandaParserClass)
	}
	{
		p.SetState(937)
		p.Class_name()
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PandaParserColon {
		{
			p.SetState(938)
			p.Base_clause()
		}

	}
	{
		p.SetState(941)
		p.Match(PandaParserLeftBrace)
	}
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-2)&-(0x1f+1)) == 0 && ((1<<uint((_la-2)))&((1<<(PandaParserBool-2))|(1<<(PandaParserConst-2))|(1<<(PandaParserDouble-2))|(1<<(PandaParserFloat32-2))|(1<<(PandaParserFloat64-2))|(1<<(PandaParserFloat-2))|(1<<(PandaParserInt-2))|(1<<(PandaParserInt8-2))|(1<<(PandaParserInt16-2))|(1<<(PandaParserInt32-2))|(1<<(PandaParserInt64-2))|(1<<(PandaParserLong-2))|(1<<(PandaParserOperator-2))|(1<<(PandaParserPrivate-2))|(1<<(PandaParserProtected-2)))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(PandaParserPublic-34))|(1<<(PandaParserStatic-34))|(1<<(PandaParserShort-34))|(1<<(PandaParserUint-34))|(1<<(PandaParserUint8-34))|(1<<(PandaParserUint16-34))|(1<<(PandaParserUint32-34))|(1<<(PandaParserUint64-34))|(1<<(PandaParserUlong-34))|(1<<(PandaParserUshort-34))|(1<<(PandaParserVar-34))|(1<<(PandaParserVoid-34))|(1<<(PandaParserLeftParen-34))|(1<<(PandaParserAnd-34)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(PandaParserSemi-93))|(1<<(PandaParserEllipsis-93))|(1<<(PandaParserIdentifier-93)))) != 0) {
		{
			p.SetState(942)
			p.Member_specification()
		}

	}
	{
		p.SetState(945)
		p.Match(PandaParserRightBrace)
	}

	return localctx
}

// IClass_nameContext is an interface to support dynamic dispatch.
type IClass_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_nameContext differentiates from other interfaces.
	IsClass_nameContext()
}

type Class_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_nameContext() *Class_nameContext {
	var p = new(Class_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_class_name
	return p
}

func (*Class_nameContext) IsClass_nameContext() {}

func NewClass_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_nameContext {
	var p = new(Class_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_class_name

	return p
}

func (s *Class_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Class_nameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Class_nameContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Class_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterClass_name(s)
	}
}

func (s *Class_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitClass_name(s)
	}
}

func (s *Class_nameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitClass_name(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Class_name() (localctx IClass_nameContext) {
	localctx = NewClass_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, PandaParserRULE_class_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(949)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(947)
			p.Match(PandaParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(948)
			p.Template_id()
		}

	}

	return localctx
}

// IMember_specificationContext is an interface to support dynamic dispatch.
type IMember_specificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_specificationContext differentiates from other interfaces.
	IsMember_specificationContext()
}

type Member_specificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_specificationContext() *Member_specificationContext {
	var p = new(Member_specificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_member_specification
	return p
}

func (*Member_specificationContext) IsMember_specificationContext() {}

func NewMember_specificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_specificationContext {
	var p = new(Member_specificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_member_specification

	return p
}

func (s *Member_specificationContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_specificationContext) Member_declaration() IMember_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_declarationContext)
}

func (s *Member_specificationContext) Member_specification() IMember_specificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_specificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_specificationContext)
}

func (s *Member_specificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_specificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_specificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMember_specification(s)
	}
}

func (s *Member_specificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMember_specification(s)
	}
}

func (s *Member_specificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitMember_specification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Member_specification() (localctx IMember_specificationContext) {
	localctx = NewMember_specificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, PandaParserRULE_member_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(951)
		p.Member_declaration()
	}
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-2)&-(0x1f+1)) == 0 && ((1<<uint((_la-2)))&((1<<(PandaParserBool-2))|(1<<(PandaParserConst-2))|(1<<(PandaParserDouble-2))|(1<<(PandaParserFloat32-2))|(1<<(PandaParserFloat64-2))|(1<<(PandaParserFloat-2))|(1<<(PandaParserInt-2))|(1<<(PandaParserInt8-2))|(1<<(PandaParserInt16-2))|(1<<(PandaParserInt32-2))|(1<<(PandaParserInt64-2))|(1<<(PandaParserLong-2))|(1<<(PandaParserOperator-2))|(1<<(PandaParserPrivate-2))|(1<<(PandaParserProtected-2)))) != 0) || (((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(PandaParserPublic-34))|(1<<(PandaParserStatic-34))|(1<<(PandaParserShort-34))|(1<<(PandaParserUint-34))|(1<<(PandaParserUint8-34))|(1<<(PandaParserUint16-34))|(1<<(PandaParserUint32-34))|(1<<(PandaParserUint64-34))|(1<<(PandaParserUlong-34))|(1<<(PandaParserUshort-34))|(1<<(PandaParserVar-34))|(1<<(PandaParserVoid-34))|(1<<(PandaParserLeftParen-34))|(1<<(PandaParserAnd-34)))) != 0) || (((_la-93)&-(0x1f+1)) == 0 && ((1<<uint((_la-93)))&((1<<(PandaParserSemi-93))|(1<<(PandaParserEllipsis-93))|(1<<(PandaParserIdentifier-93)))) != 0) {
		{
			p.SetState(952)
			p.Member_specification()
		}

	}

	return localctx
}

// IMember_declarationContext is an interface to support dynamic dispatch.
type IMember_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_declarationContext differentiates from other interfaces.
	IsMember_declarationContext()
}

type Member_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_declarationContext() *Member_declarationContext {
	var p = new(Member_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_member_declaration
	return p
}

func (*Member_declarationContext) IsMember_declarationContext() {}

func NewMember_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_declarationContext {
	var p = new(Member_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_member_declaration

	return p
}

func (s *Member_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_declarationContext) Decl_specifier_sequence() IDecl_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_specifier_sequenceContext)
}

func (s *Member_declarationContext) Member_declarator_list() IMember_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_declarator_listContext)
}

func (s *Member_declarationContext) Function_definition() IFunction_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_definitionContext)
}

func (s *Member_declarationContext) Empty_declaration() IEmpty_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmpty_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmpty_declarationContext)
}

func (s *Member_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMember_declaration(s)
	}
}

func (s *Member_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMember_declaration(s)
	}
}

func (s *Member_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitMember_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Member_declaration() (localctx IMember_declarationContext) {
	localctx = NewMember_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, PandaParserRULE_member_declaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(964)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(956)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(955)
				p.Decl_specifier_sequence()
			}

		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PandaParserOperator || _la == PandaParserLeftParen || _la == PandaParserAnd || _la == PandaParserEllipsis || _la == PandaParserIdentifier {
			{
				p.SetState(958)
				p.member_declarator_list(0)
			}

		}
		{
			p.SetState(961)
			p.Match(PandaParserSemi)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(962)
			p.Function_definition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(963)
			p.Empty_declaration()
		}

	}

	return localctx
}

// IMember_declarator_listContext is an interface to support dynamic dispatch.
type IMember_declarator_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_declarator_listContext differentiates from other interfaces.
	IsMember_declarator_listContext()
}

type Member_declarator_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_declarator_listContext() *Member_declarator_listContext {
	var p = new(Member_declarator_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_member_declarator_list
	return p
}

func (*Member_declarator_listContext) IsMember_declarator_listContext() {}

func NewMember_declarator_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_declarator_listContext {
	var p = new(Member_declarator_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_member_declarator_list

	return p
}

func (s *Member_declarator_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_declarator_listContext) Member_declarator() IMember_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_declaratorContext)
}

func (s *Member_declarator_listContext) Member_declarator_list() IMember_declarator_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_declarator_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_declarator_listContext)
}

func (s *Member_declarator_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_declarator_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_declarator_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMember_declarator_list(s)
	}
}

func (s *Member_declarator_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMember_declarator_list(s)
	}
}

func (s *Member_declarator_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitMember_declarator_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Member_declarator_list() (localctx IMember_declarator_listContext) {
	return p.member_declarator_list(0)
}

func (p *PandaParser) member_declarator_list(_p int) (localctx IMember_declarator_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewMember_declarator_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMember_declarator_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, PandaParserRULE_member_declarator_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(967)
		p.Member_declarator()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMember_declarator_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_member_declarator_list)
			p.SetState(969)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(970)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(971)
				p.Member_declarator()
			}

		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
	}

	return localctx
}

// IMember_declaratorContext is an interface to support dynamic dispatch.
type IMember_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_declaratorContext differentiates from other interfaces.
	IsMember_declaratorContext()
}

type Member_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_declaratorContext() *Member_declaratorContext {
	var p = new(Member_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_member_declarator
	return p
}

func (*Member_declaratorContext) IsMember_declaratorContext() {}

func NewMember_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_declaratorContext {
	var p = new(Member_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_member_declarator

	return p
}

func (s *Member_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_declaratorContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Member_declaratorContext) Brace_or_equal_initializer() IBrace_or_equal_initializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBrace_or_equal_initializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBrace_or_equal_initializerContext)
}

func (s *Member_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterMember_declarator(s)
	}
}

func (s *Member_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitMember_declarator(s)
	}
}

func (s *Member_declaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitMember_declarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Member_declarator() (localctx IMember_declaratorContext) {
	localctx = NewMember_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, PandaParserRULE_member_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(978)
			p.Declarator()
		}
		p.SetState(980)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(979)
				p.Brace_or_equal_initializer()
			}

		}

	}

	return localctx
}

// IModifier_specifier_sequenceContext is an interface to support dynamic dispatch.
type IModifier_specifier_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifier_specifier_sequenceContext differentiates from other interfaces.
	IsModifier_specifier_sequenceContext()
}

type Modifier_specifier_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifier_specifier_sequenceContext() *Modifier_specifier_sequenceContext {
	var p = new(Modifier_specifier_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_modifier_specifier_sequence
	return p
}

func (*Modifier_specifier_sequenceContext) IsModifier_specifier_sequenceContext() {}

func NewModifier_specifier_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modifier_specifier_sequenceContext {
	var p = new(Modifier_specifier_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_modifier_specifier_sequence

	return p
}

func (s *Modifier_specifier_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Modifier_specifier_sequenceContext) Modifier_specifier() IModifier_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifier_specifierContext)
}

func (s *Modifier_specifier_sequenceContext) Modifier_specifier_sequence() IModifier_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifier_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifier_specifier_sequenceContext)
}

func (s *Modifier_specifier_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modifier_specifier_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modifier_specifier_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterModifier_specifier_sequence(s)
	}
}

func (s *Modifier_specifier_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitModifier_specifier_sequence(s)
	}
}

func (s *Modifier_specifier_sequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitModifier_specifier_sequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Modifier_specifier_sequence() (localctx IModifier_specifier_sequenceContext) {
	return p.modifier_specifier_sequence(0)
}

func (p *PandaParser) modifier_specifier_sequence(_p int) (localctx IModifier_specifier_sequenceContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewModifier_specifier_sequenceContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IModifier_specifier_sequenceContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 170
	p.EnterRecursionRule(localctx, 170, PandaParserRULE_modifier_specifier_sequence, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(985)
		p.Modifier_specifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewModifier_specifier_sequenceContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_modifier_specifier_sequence)
			p.SetState(987)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(988)
				p.Modifier_specifier()
			}

		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())
	}

	return localctx
}

// IModifier_specifierContext is an interface to support dynamic dispatch.
type IModifier_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifier_specifierContext differentiates from other interfaces.
	IsModifier_specifierContext()
}

type Modifier_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifier_specifierContext() *Modifier_specifierContext {
	var p = new(Modifier_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_modifier_specifier
	return p
}

func (*Modifier_specifierContext) IsModifier_specifierContext() {}

func NewModifier_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Modifier_specifierContext {
	var p = new(Modifier_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_modifier_specifier

	return p
}

func (s *Modifier_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Modifier_specifierContext) Static() antlr.TerminalNode {
	return s.GetToken(PandaParserStatic, 0)
}

func (s *Modifier_specifierContext) Const() antlr.TerminalNode {
	return s.GetToken(PandaParserConst, 0)
}

func (s *Modifier_specifierContext) Access_specifier() IAccess_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_specifierContext)
}

func (s *Modifier_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Modifier_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Modifier_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterModifier_specifier(s)
	}
}

func (s *Modifier_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitModifier_specifier(s)
	}
}

func (s *Modifier_specifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitModifier_specifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Modifier_specifier() (localctx IModifier_specifierContext) {
	localctx = NewModifier_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, PandaParserRULE_modifier_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(997)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserStatic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(994)
			p.Match(PandaParserStatic)
		}

	case PandaParserConst:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(995)
			p.Match(PandaParserConst)
		}

	case PandaParserPrivate, PandaParserProtected, PandaParserPublic:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(996)
			p.Access_specifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAccess_specifierContext is an interface to support dynamic dispatch.
type IAccess_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccess_specifierContext differentiates from other interfaces.
	IsAccess_specifierContext()
}

type Access_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccess_specifierContext() *Access_specifierContext {
	var p = new(Access_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_access_specifier
	return p
}

func (*Access_specifierContext) IsAccess_specifierContext() {}

func NewAccess_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_specifierContext {
	var p = new(Access_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_access_specifier

	return p
}

func (s *Access_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_specifierContext) Private() antlr.TerminalNode {
	return s.GetToken(PandaParserPrivate, 0)
}

func (s *Access_specifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(PandaParserProtected, 0)
}

func (s *Access_specifierContext) Public() antlr.TerminalNode {
	return s.GetToken(PandaParserPublic, 0)
}

func (s *Access_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterAccess_specifier(s)
	}
}

func (s *Access_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitAccess_specifier(s)
	}
}

func (s *Access_specifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitAccess_specifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Access_specifier() (localctx IAccess_specifierContext) {
	localctx = NewAccess_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, PandaParserRULE_access_specifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(999)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PandaParserPrivate-32))|(1<<(PandaParserProtected-32))|(1<<(PandaParserPublic-32)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBase_clauseContext is an interface to support dynamic dispatch.
type IBase_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_clauseContext differentiates from other interfaces.
	IsBase_clauseContext()
}

type Base_clauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_clauseContext() *Base_clauseContext {
	var p = new(Base_clauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_base_clause
	return p
}

func (*Base_clauseContext) IsBase_clauseContext() {}

func NewBase_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_clauseContext {
	var p = new(Base_clauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_base_clause

	return p
}

func (s *Base_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_clauseContext) Base_specifier_list() IBase_specifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_specifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_specifier_listContext)
}

func (s *Base_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBase_clause(s)
	}
}

func (s *Base_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBase_clause(s)
	}
}

func (s *Base_clauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitBase_clause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Base_clause() (localctx IBase_clauseContext) {
	localctx = NewBase_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, PandaParserRULE_base_clause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.Match(PandaParserColon)
	}
	{
		p.SetState(1002)
		p.base_specifier_list(0)
	}

	return localctx
}

// IBase_specifier_listContext is an interface to support dynamic dispatch.
type IBase_specifier_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_specifier_listContext differentiates from other interfaces.
	IsBase_specifier_listContext()
}

type Base_specifier_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_specifier_listContext() *Base_specifier_listContext {
	var p = new(Base_specifier_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_base_specifier_list
	return p
}

func (*Base_specifier_listContext) IsBase_specifier_listContext() {}

func NewBase_specifier_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_specifier_listContext {
	var p = new(Base_specifier_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_base_specifier_list

	return p
}

func (s *Base_specifier_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_specifier_listContext) Base_specifier() IBase_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_specifierContext)
}

func (s *Base_specifier_listContext) Base_specifier_list() IBase_specifier_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_specifier_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_specifier_listContext)
}

func (s *Base_specifier_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_specifier_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_specifier_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBase_specifier_list(s)
	}
}

func (s *Base_specifier_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBase_specifier_list(s)
	}
}

func (s *Base_specifier_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitBase_specifier_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Base_specifier_list() (localctx IBase_specifier_listContext) {
	return p.base_specifier_list(0)
}

func (p *PandaParser) base_specifier_list(_p int) (localctx IBase_specifier_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBase_specifier_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBase_specifier_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 178
	p.EnterRecursionRule(localctx, 178, PandaParserRULE_base_specifier_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1005)
		p.Base_specifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBase_specifier_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_base_specifier_list)
			p.SetState(1007)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1008)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(1009)
				p.Base_specifier()
			}

		}
		p.SetState(1014)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
	}

	return localctx
}

// IBase_specifierContext is an interface to support dynamic dispatch.
type IBase_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_specifierContext differentiates from other interfaces.
	IsBase_specifierContext()
}

type Base_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_specifierContext() *Base_specifierContext {
	var p = new(Base_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_base_specifier
	return p
}

func (*Base_specifierContext) IsBase_specifierContext() {}

func NewBase_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_specifierContext {
	var p = new(Base_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_base_specifier

	return p
}

func (s *Base_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_specifierContext) Class_name() IClass_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_nameContext)
}

func (s *Base_specifierContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Base_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterBase_specifier(s)
	}
}

func (s *Base_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitBase_specifier(s)
	}
}

func (s *Base_specifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitBase_specifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Base_specifier() (localctx IBase_specifierContext) {
	localctx = NewBase_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, PandaParserRULE_base_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1016)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1015)
			p.nested_name_specifier(0)
		}

	}
	{
		p.SetState(1018)
		p.Class_name()
	}

	return localctx
}

// IOperator_function_idContext is an interface to support dynamic dispatch.
type IOperator_function_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperator_function_idContext differentiates from other interfaces.
	IsOperator_function_idContext()
}

type Operator_function_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperator_function_idContext() *Operator_function_idContext {
	var p = new(Operator_function_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_operator_function_id
	return p
}

func (*Operator_function_idContext) IsOperator_function_idContext() {}

func NewOperator_function_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Operator_function_idContext {
	var p = new(Operator_function_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_operator_function_id

	return p
}

func (s *Operator_function_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Operator_function_idContext) Operator() antlr.TerminalNode {
	return s.GetToken(PandaParserOperator, 0)
}

func (s *Operator_function_idContext) Operators() IOperatorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperatorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperatorsContext)
}

func (s *Operator_function_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Operator_function_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Operator_function_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterOperator_function_id(s)
	}
}

func (s *Operator_function_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitOperator_function_id(s)
	}
}

func (s *Operator_function_idContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitOperator_function_id(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Operator_function_id() (localctx IOperator_function_idContext) {
	localctx = NewOperator_function_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, PandaParserRULE_operator_function_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.Match(PandaParserOperator)
	}
	{
		p.SetState(1021)
		p.Operators()
	}

	return localctx
}

// ITemplate_idContext is an interface to support dynamic dispatch.
type ITemplate_idContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_idContext differentiates from other interfaces.
	IsTemplate_idContext()
}

type Template_idContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_idContext() *Template_idContext {
	var p = new(Template_idContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_id
	return p
}

func (*Template_idContext) IsTemplate_idContext() {}

func NewTemplate_idContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_idContext {
	var p = new(Template_idContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_id

	return p
}

func (s *Template_idContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_idContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Template_idContext) Template_definition() ITemplate_definitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_definitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_definitionContext)
}

func (s *Template_idContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_idContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_idContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_id(s)
	}
}

func (s *Template_idContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_id(s)
	}
}

func (s *Template_idContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitTemplate_id(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Template_id() (localctx ITemplate_idContext) {
	localctx = NewTemplate_idContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, PandaParserRULE_template_id)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1023)
		p.Match(PandaParserIdentifier)
	}
	{
		p.SetState(1024)
		p.Template_definition()
	}

	return localctx
}

// ITemplate_definitionContext is an interface to support dynamic dispatch.
type ITemplate_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_definitionContext differentiates from other interfaces.
	IsTemplate_definitionContext()
}

type Template_definitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_definitionContext() *Template_definitionContext {
	var p = new(Template_definitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_definition
	return p
}

func (*Template_definitionContext) IsTemplate_definitionContext() {}

func NewTemplate_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_definitionContext {
	var p = new(Template_definitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_definition

	return p
}

func (s *Template_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_definitionContext) Template_argument_list() ITemplate_argument_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_argument_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_argument_listContext)
}

func (s *Template_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_definition(s)
	}
}

func (s *Template_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_definition(s)
	}
}

func (s *Template_definitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitTemplate_definition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Template_definition() (localctx ITemplate_definitionContext) {
	localctx = NewTemplate_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, PandaParserRULE_template_definition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Match(PandaParserLess)
	}
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PandaParserBool)|(1<<PandaParserCast)|(1<<PandaParserDouble)|(1<<PandaParserFloat32)|(1<<PandaParserFloat64)|(1<<PandaParserFloat)|(1<<PandaParserInt)|(1<<PandaParserInt8)|(1<<PandaParserInt16)|(1<<PandaParserInt32)|(1<<PandaParserInt64)|(1<<PandaParserLong)|(1<<PandaParserNew)|(1<<PandaParserOperator))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(PandaParserShort-37))|(1<<(PandaParserThis-37))|(1<<(PandaParserUint-37))|(1<<(PandaParserUint8-37))|(1<<(PandaParserUint16-37))|(1<<(PandaParserUint32-37))|(1<<(PandaParserUint64-37))|(1<<(PandaParserUlong-37))|(1<<(PandaParserUshort-37))|(1<<(PandaParserVar-37))|(1<<(PandaParserVoid-37))|(1<<(PandaParserLeftParen-37))|(1<<(PandaParserPlus-37))|(1<<(PandaParserMinus-37))|(1<<(PandaParserOr-37))|(1<<(PandaParserTilde-37))|(1<<(PandaParserNot-37)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(PandaParserPlusPlus-88))|(1<<(PandaParserMinusMinus-88))|(1<<(PandaParserIdentifier-88))|(1<<(PandaParserIntegerLiteral-88))|(1<<(PandaParserFloatLiteral-88))|(1<<(PandaParserStringLiteral-88))|(1<<(PandaParserBooleanLiteral-88))|(1<<(PandaParserPointerLiteral-88)))) != 0) {
		{
			p.SetState(1027)
			p.template_argument_list(0)
		}

	}
	{
		p.SetState(1030)
		p.Match(PandaParserGreater)
	}

	return localctx
}

// ITemplate_argument_listContext is an interface to support dynamic dispatch.
type ITemplate_argument_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_argument_listContext differentiates from other interfaces.
	IsTemplate_argument_listContext()
}

type Template_argument_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_argument_listContext() *Template_argument_listContext {
	var p = new(Template_argument_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_argument_list
	return p
}

func (*Template_argument_listContext) IsTemplate_argument_listContext() {}

func NewTemplate_argument_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_argument_listContext {
	var p = new(Template_argument_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_argument_list

	return p
}

func (s *Template_argument_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_argument_listContext) Template_argument() ITemplate_argumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_argumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_argumentContext)
}

func (s *Template_argument_listContext) Template_argument_list() ITemplate_argument_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_argument_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_argument_listContext)
}

func (s *Template_argument_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_argument_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_argument_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_argument_list(s)
	}
}

func (s *Template_argument_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_argument_list(s)
	}
}

func (s *Template_argument_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitTemplate_argument_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Template_argument_list() (localctx ITemplate_argument_listContext) {
	return p.template_argument_list(0)
}

func (p *PandaParser) template_argument_list(_p int) (localctx ITemplate_argument_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewTemplate_argument_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITemplate_argument_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 188
	p.EnterRecursionRule(localctx, 188, PandaParserRULE_template_argument_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1033)
		p.Template_argument()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTemplate_argument_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_template_argument_list)
			p.SetState(1035)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1036)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(1037)
				p.Template_argument()
			}

		}
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
	}

	return localctx
}

// ITemplate_argumentContext is an interface to support dynamic dispatch.
type ITemplate_argumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_argumentContext differentiates from other interfaces.
	IsTemplate_argumentContext()
}

type Template_argumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_argumentContext() *Template_argumentContext {
	var p = new(Template_argumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_template_argument
	return p
}

func (*Template_argumentContext) IsTemplate_argumentContext() {}

func NewTemplate_argumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_argumentContext {
	var p = new(Template_argumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_template_argument

	return p
}

func (s *Template_argumentContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_argumentContext) Type_id() IType_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Template_argumentContext) Constant_expression() IConstant_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_expressionContext)
}

func (s *Template_argumentContext) Id_expression() IId_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IId_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IId_expressionContext)
}

func (s *Template_argumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_argumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_argumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTemplate_argument(s)
	}
}

func (s *Template_argumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTemplate_argument(s)
	}
}

func (s *Template_argumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitTemplate_argument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Template_argument() (localctx ITemplate_argumentContext) {
	localctx = NewTemplate_argumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, PandaParserRULE_template_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1046)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1043)
			p.Type_id()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1044)
			p.Constant_expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1045)
			p.Id_expression()
		}

	}

	return localctx
}

// IType_name_specifierContext is an interface to support dynamic dispatch.
type IType_name_specifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_name_specifierContext differentiates from other interfaces.
	IsType_name_specifierContext()
}

type Type_name_specifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_name_specifierContext() *Type_name_specifierContext {
	var p = new(Type_name_specifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_name_specifier
	return p
}

func (*Type_name_specifierContext) IsType_name_specifierContext() {}

func NewType_name_specifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_name_specifierContext {
	var p = new(Type_name_specifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_name_specifier

	return p
}

func (s *Type_name_specifierContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_name_specifierContext) Nested_name_specifier() INested_name_specifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INested_name_specifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INested_name_specifierContext)
}

func (s *Type_name_specifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(PandaParserIdentifier, 0)
}

func (s *Type_name_specifierContext) Template_id() ITemplate_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_idContext)
}

func (s *Type_name_specifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_name_specifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_name_specifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_name_specifier(s)
	}
}

func (s *Type_name_specifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_name_specifier(s)
	}
}

func (s *Type_name_specifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitType_name_specifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Type_name_specifier() (localctx IType_name_specifierContext) {
	localctx = NewType_name_specifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, PandaParserRULE_type_name_specifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1048)
			p.nested_name_specifier(0)
		}
		{
			p.SetState(1049)
			p.Match(PandaParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1051)
			p.nested_name_specifier(0)
		}
		{
			p.SetState(1052)
			p.Template_id()
		}

	}

	return localctx
}

// IType_id_listContext is an interface to support dynamic dispatch.
type IType_id_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_id_listContext differentiates from other interfaces.
	IsType_id_listContext()
}

type Type_id_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_id_listContext() *Type_id_listContext {
	var p = new(Type_id_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_type_id_list
	return p
}

func (*Type_id_listContext) IsType_id_listContext() {}

func NewType_id_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_id_listContext {
	var p = new(Type_id_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_type_id_list

	return p
}

func (s *Type_id_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_id_listContext) Type_id() IType_idContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_idContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_idContext)
}

func (s *Type_id_listContext) Type_id_list() IType_id_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_id_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_id_listContext)
}

func (s *Type_id_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_id_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_id_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterType_id_list(s)
	}
}

func (s *Type_id_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitType_id_list(s)
	}
}

func (s *Type_id_listContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitType_id_list(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Type_id_list() (localctx IType_id_listContext) {
	return p.type_id_list(0)
}

func (p *PandaParser) type_id_list(_p int) (localctx IType_id_listContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewType_id_listContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IType_id_listContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 194
	p.EnterRecursionRule(localctx, 194, PandaParserRULE_type_id_list, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1057)
		p.Type_id()
	}
	p.SetState(1059)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1058)
			p.Match(PandaParserEllipsis)
		}

	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewType_id_listContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, PandaParserRULE_type_id_list)
			p.SetState(1061)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1062)
				p.Match(PandaParserComma)
			}
			{
				p.SetState(1063)
				p.Type_id()
			}
			p.SetState(1065)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1064)
					p.Match(PandaParserEllipsis)
				}

			}

		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext())
	}

	return localctx
}

// ITry_blockContext is an interface to support dynamic dispatch.
type ITry_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_blockContext differentiates from other interfaces.
	IsTry_blockContext()
}

type Try_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_blockContext() *Try_blockContext {
	var p = new(Try_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_try_block
	return p
}

func (*Try_blockContext) IsTry_blockContext() {}

func NewTry_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_blockContext {
	var p = new(Try_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_try_block

	return p
}

func (s *Try_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_blockContext) Try() antlr.TerminalNode {
	return s.GetToken(PandaParserTry, 0)
}

func (s *Try_blockContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *Try_blockContext) Handler_sequence() IHandler_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHandler_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHandler_sequenceContext)
}

func (s *Try_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Try_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterTry_block(s)
	}
}

func (s *Try_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitTry_block(s)
	}
}

func (s *Try_blockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitTry_block(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Try_block() (localctx ITry_blockContext) {
	localctx = NewTry_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, PandaParserRULE_try_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1072)
		p.Match(PandaParserTry)
	}
	{
		p.SetState(1073)
		p.Compound_statement()
	}
	{
		p.SetState(1074)
		p.Handler_sequence()
	}

	return localctx
}

// IHandler_sequenceContext is an interface to support dynamic dispatch.
type IHandler_sequenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHandler_sequenceContext differentiates from other interfaces.
	IsHandler_sequenceContext()
}

type Handler_sequenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandler_sequenceContext() *Handler_sequenceContext {
	var p = new(Handler_sequenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_handler_sequence
	return p
}

func (*Handler_sequenceContext) IsHandler_sequenceContext() {}

func NewHandler_sequenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Handler_sequenceContext {
	var p = new(Handler_sequenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_handler_sequence

	return p
}

func (s *Handler_sequenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Handler_sequenceContext) Handler() IHandlerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHandlerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHandlerContext)
}

func (s *Handler_sequenceContext) Handler_sequence() IHandler_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHandler_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHandler_sequenceContext)
}

func (s *Handler_sequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Handler_sequenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Handler_sequenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterHandler_sequence(s)
	}
}

func (s *Handler_sequenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitHandler_sequence(s)
	}
}

func (s *Handler_sequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitHandler_sequence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Handler_sequence() (localctx IHandler_sequenceContext) {
	localctx = NewHandler_sequenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, PandaParserRULE_handler_sequence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1076)
		p.Handler()
	}
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1077)
			p.Handler_sequence()
		}

	}

	return localctx
}

// IHandlerContext is an interface to support dynamic dispatch.
type IHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHandlerContext differentiates from other interfaces.
	IsHandlerContext()
}

type HandlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerContext() *HandlerContext {
	var p = new(HandlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_handler
	return p
}

func (*HandlerContext) IsHandlerContext() {}

func NewHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerContext {
	var p = new(HandlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_handler

	return p
}

func (s *HandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerContext) Catch() antlr.TerminalNode {
	return s.GetToken(PandaParserCatch, 0)
}

func (s *HandlerContext) Exception_declaration() IException_declarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_declarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_declarationContext)
}

func (s *HandlerContext) Compound_statement() ICompound_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompound_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompound_statementContext)
}

func (s *HandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterHandler(s)
	}
}

func (s *HandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitHandler(s)
	}
}

func (s *HandlerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitHandler(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Handler() (localctx IHandlerContext) {
	localctx = NewHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, PandaParserRULE_handler)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1080)
		p.Match(PandaParserCatch)
	}
	{
		p.SetState(1081)
		p.Match(PandaParserLeftParen)
	}
	{
		p.SetState(1082)
		p.Exception_declaration()
	}
	{
		p.SetState(1083)
		p.Match(PandaParserRightParen)
	}
	{
		p.SetState(1084)
		p.Compound_statement()
	}

	return localctx
}

// IException_declarationContext is an interface to support dynamic dispatch.
type IException_declarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_declarationContext differentiates from other interfaces.
	IsException_declarationContext()
}

type Exception_declarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_declarationContext() *Exception_declarationContext {
	var p = new(Exception_declarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_exception_declaration
	return p
}

func (*Exception_declarationContext) IsException_declarationContext() {}

func NewException_declarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_declarationContext {
	var p = new(Exception_declarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_exception_declaration

	return p
}

func (s *Exception_declarationContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_declarationContext) Type_specifier_sequence() IType_specifier_sequenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specifier_sequenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specifier_sequenceContext)
}

func (s *Exception_declarationContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Exception_declarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_declarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_declarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterException_declaration(s)
	}
}

func (s *Exception_declarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitException_declaration(s)
	}
}

func (s *Exception_declarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitException_declaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Exception_declaration() (localctx IException_declarationContext) {
	localctx = NewException_declarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, PandaParserRULE_exception_declaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1086)
			p.Type_specifier_sequence()
		}
		{
			p.SetState(1087)
			p.Declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1089)
			p.Type_specifier_sequence()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1090)
			p.Match(PandaParserEllipsis)
		}

	}

	return localctx
}

// IThrow_expressionContext is an interface to support dynamic dispatch.
type IThrow_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrow_expressionContext differentiates from other interfaces.
	IsThrow_expressionContext()
}

type Throw_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrow_expressionContext() *Throw_expressionContext {
	var p = new(Throw_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_throw_expression
	return p
}

func (*Throw_expressionContext) IsThrow_expressionContext() {}

func NewThrow_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Throw_expressionContext {
	var p = new(Throw_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_throw_expression

	return p
}

func (s *Throw_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Throw_expressionContext) Throw() antlr.TerminalNode {
	return s.GetToken(PandaParserThrow, 0)
}

func (s *Throw_expressionContext) Assignment_expression() IAssignment_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_expressionContext)
}

func (s *Throw_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Throw_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Throw_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterThrow_expression(s)
	}
}

func (s *Throw_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitThrow_expression(s)
	}
}

func (s *Throw_expressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitThrow_expression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Throw_expression() (localctx IThrow_expressionContext) {
	localctx = NewThrow_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, PandaParserRULE_throw_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		p.Match(PandaParserThrow)
	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1094)
			p.Assignment_expression()
		}

	}

	return localctx
}

// IOperatorsContext is an interface to support dynamic dispatch.
type IOperatorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperatorsContext differentiates from other interfaces.
	IsOperatorsContext()
}

type OperatorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperatorsContext() *OperatorsContext {
	var p = new(OperatorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_operators
	return p
}

func (*OperatorsContext) IsOperatorsContext() {}

func NewOperatorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorsContext {
	var p = new(OperatorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_operators

	return p
}

func (s *OperatorsContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorsContext) New() antlr.TerminalNode {
	return s.GetToken(PandaParserNew, 0)
}

func (s *OperatorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterOperators(s)
	}
}

func (s *OperatorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitOperators(s)
	}
}

func (s *OperatorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitOperators(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Operators() (localctx IOperatorsContext) {
	localctx = NewOperatorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, PandaParserRULE_operators)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1135)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PandaParserNew:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1097)
			p.Match(PandaParserNew)
		}

	case PandaParserPlus:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1098)
			p.Match(PandaParserPlus)
		}

	case PandaParserMinus:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1099)
			p.Match(PandaParserMinus)
		}

	case PandaParserStar:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1100)
			p.Match(PandaParserStar)
		}

	case PandaParserDiv:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1101)
			p.Match(PandaParserDiv)
		}

	case PandaParserMod:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1102)
			p.Match(PandaParserMod)
		}

	case PandaParserCaret:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1103)
			p.Match(PandaParserCaret)
		}

	case PandaParserAnd:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1104)
			p.Match(PandaParserAnd)
		}

	case PandaParserOr:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1105)
			p.Match(PandaParserOr)
		}

	case PandaParserTilde:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1106)
			p.Match(PandaParserTilde)
		}

	case PandaParserNot:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1107)
			p.Match(PandaParserNot)
		}

	case PandaParserAssign:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1108)
			p.Match(PandaParserAssign)
		}

	case PandaParserLess:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1109)
			p.Match(PandaParserLess)
		}

	case PandaParserGreater:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1110)
			p.Match(PandaParserGreater)
		}

	case PandaParserPlusAssign:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1111)
			p.Match(PandaParserPlusAssign)
		}

	case PandaParserMinusAssign:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1112)
			p.Match(PandaParserMinusAssign)
		}

	case PandaParserDivAssign:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1113)
			p.Match(PandaParserDivAssign)
		}

	case PandaParserModAssign:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1114)
			p.Match(PandaParserModAssign)
		}

	case PandaParserXorAssign:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1115)
			p.Match(PandaParserXorAssign)
		}

	case PandaParserAndAssign:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1116)
			p.Match(PandaParserAndAssign)
		}

	case PandaParserOrAssign:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1117)
			p.Match(PandaParserOrAssign)
		}

	case PandaParserLeftShift:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1118)
			p.Match(PandaParserLeftShift)
		}

	case PandaParserRightShift:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1119)
			p.Match(PandaParserRightShift)
		}

	case PandaParserRightShiftAssign:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1120)
			p.Match(PandaParserRightShiftAssign)
		}

	case PandaParserLeftShiftAssign:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1121)
			p.Match(PandaParserLeftShiftAssign)
		}

	case PandaParserEqual:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1122)
			p.Match(PandaParserEqual)
		}

	case PandaParserNotEqual:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1123)
			p.Match(PandaParserNotEqual)
		}

	case PandaParserLessEqual:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1124)
			p.Match(PandaParserLessEqual)
		}

	case PandaParserGreaterEqual:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1125)
			p.Match(PandaParserGreaterEqual)
		}

	case PandaParserAndAnd:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1126)
			p.Match(PandaParserAndAnd)
		}

	case PandaParserOrOr:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1127)
			p.Match(PandaParserOrOr)
		}

	case PandaParserPlusPlus:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1128)
			p.Match(PandaParserPlusPlus)
		}

	case PandaParserMinusMinus:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1129)
			p.Match(PandaParserMinusMinus)
		}

	case PandaParserComma:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1130)
			p.Match(PandaParserComma)
		}

	case PandaParserLeftParen:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1131)
			p.Match(PandaParserLeftParen)
		}
		{
			p.SetState(1132)
			p.Match(PandaParserRightParen)
		}

	case PandaParserLeftBracket:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1133)
			p.Match(PandaParserLeftBracket)
		}
		{
			p.SetState(1134)
			p.Match(PandaParserRightBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PandaParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PandaParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserIntegerLiteral, 0)
}

func (s *LiteralContext) FloatLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserFloatLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserStringLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserBooleanLiteral, 0)
}

func (s *LiteralContext) PointerLiteral() antlr.TerminalNode {
	return s.GetToken(PandaParserPointerLiteral, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PandaParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PandaParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PandaParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, PandaParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(PandaParserIntegerLiteral-97))|(1<<(PandaParserFloatLiteral-97))|(1<<(PandaParserStringLiteral-97))|(1<<(PandaParserBooleanLiteral-97))|(1<<(PandaParserPointerLiteral-97)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *PandaParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 5:
		var t *Nested_name_specifierContext = nil
		if localctx != nil {
			t = localctx.(*Nested_name_specifierContext)
		}
		return p.Nested_name_specifier_Sempred(t, predIndex)

	case 6:
		var t *Post_fix_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Post_fix_expressionContext)
		}
		return p.Post_fix_expression_Sempred(t, predIndex)

	case 12:
		var t *Multiplicative_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Multiplicative_expressionContext)
		}
		return p.Multiplicative_expression_Sempred(t, predIndex)

	case 13:
		var t *Additive_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Additive_expressionContext)
		}
		return p.Additive_expression_Sempred(t, predIndex)

	case 14:
		var t *Shift_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Shift_expressionContext)
		}
		return p.Shift_expression_Sempred(t, predIndex)

	case 16:
		var t *Relational_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Relational_expressionContext)
		}
		return p.Relational_expression_Sempred(t, predIndex)

	case 17:
		var t *Equality_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Equality_expressionContext)
		}
		return p.Equality_expression_Sempred(t, predIndex)

	case 18:
		var t *And_expressionContext = nil
		if localctx != nil {
			t = localctx.(*And_expressionContext)
		}
		return p.And_expression_Sempred(t, predIndex)

	case 19:
		var t *Exclusiveor_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Exclusiveor_expressionContext)
		}
		return p.Exclusiveor_expression_Sempred(t, predIndex)

	case 20:
		var t *Inclusiveor_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Inclusiveor_expressionContext)
		}
		return p.Inclusiveor_expression_Sempred(t, predIndex)

	case 21:
		var t *Logical_and_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Logical_and_expressionContext)
		}
		return p.Logical_and_expression_Sempred(t, predIndex)

	case 22:
		var t *Logical_or_expressionContext = nil
		if localctx != nil {
			t = localctx.(*Logical_or_expressionContext)
		}
		return p.Logical_or_expression_Sempred(t, predIndex)

	case 26:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 32:
		var t *Statement_sequenceContext = nil
		if localctx != nil {
			t = localctx.(*Statement_sequenceContext)
		}
		return p.Statement_sequence_Sempred(t, predIndex)

	case 41:
		var t *Declaration_sequenceContext = nil
		if localctx != nil {
			t = localctx.(*Declaration_sequenceContext)
		}
		return p.Declaration_sequence_Sempred(t, predIndex)

	case 54:
		var t *Enumerator_listContext = nil
		if localctx != nil {
			t = localctx.(*Enumerator_listContext)
		}
		return p.Enumerator_list_Sempred(t, predIndex)

	case 57:
		var t *Namespace_nameContext = nil
		if localctx != nil {
			t = localctx.(*Namespace_nameContext)
		}
		return p.Namespace_name_Sempred(t, predIndex)

	case 60:
		var t *Include_definition_sequenceContext = nil
		if localctx != nil {
			t = localctx.(*Include_definition_sequenceContext)
		}
		return p.Include_definition_sequence_Sempred(t, predIndex)

	case 61:
		var t *Init_declarator_listContext = nil
		if localctx != nil {
			t = localctx.(*Init_declarator_listContext)
		}
		return p.Init_declarator_list_Sempred(t, predIndex)

	case 65:
		var t *Noptr_declaratorContext = nil
		if localctx != nil {
			t = localctx.(*Noptr_declaratorContext)
		}
		return p.Noptr_declarator_Sempred(t, predIndex)

	case 71:
		var t *Parameter_declaration_listContext = nil
		if localctx != nil {
			t = localctx.(*Parameter_declaration_listContext)
		}
		return p.Parameter_declaration_list_Sempred(t, predIndex)

	case 77:
		var t *Initializer_listContext = nil
		if localctx != nil {
			t = localctx.(*Initializer_listContext)
		}
		return p.Initializer_list_Sempred(t, predIndex)

	case 83:
		var t *Member_declarator_listContext = nil
		if localctx != nil {
			t = localctx.(*Member_declarator_listContext)
		}
		return p.Member_declarator_list_Sempred(t, predIndex)

	case 85:
		var t *Modifier_specifier_sequenceContext = nil
		if localctx != nil {
			t = localctx.(*Modifier_specifier_sequenceContext)
		}
		return p.Modifier_specifier_sequence_Sempred(t, predIndex)

	case 89:
		var t *Base_specifier_listContext = nil
		if localctx != nil {
			t = localctx.(*Base_specifier_listContext)
		}
		return p.Base_specifier_list_Sempred(t, predIndex)

	case 94:
		var t *Template_argument_listContext = nil
		if localctx != nil {
			t = localctx.(*Template_argument_listContext)
		}
		return p.Template_argument_list_Sempred(t, predIndex)

	case 97:
		var t *Type_id_listContext = nil
		if localctx != nil {
			t = localctx.(*Type_id_listContext)
		}
		return p.Type_id_list_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *PandaParser) Nested_name_specifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Post_fix_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Multiplicative_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Additive_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Shift_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Relational_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Equality_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 17:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) And_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 19:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Exclusiveor_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 20:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Inclusiveor_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 21:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Logical_and_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 22:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Logical_or_expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 23:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 24:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Statement_sequence_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 25:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Declaration_sequence_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 26:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Enumerator_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 27:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Namespace_name_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 28:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Include_definition_sequence_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 29:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Init_declarator_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 30:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Noptr_declarator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 31:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Parameter_declaration_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 32:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Initializer_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 33:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Member_declarator_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 34:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Modifier_specifier_sequence_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 35:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Base_specifier_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 36:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Template_argument_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 37:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *PandaParser) Type_id_list_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 38:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
